/*
 * This file was generated automatically by xsubpp version 1.9508 from the 
 * contents of Qt.xs. Do not edit this file, edit Qt.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#include <stdio.h>
#include <qcolor.h>
#include <qglobal.h>
#include <qstring.h>
#include <qapplication.h>
#include <qmetaobject.h>
#include <qsqlquery.h>
#include <qsqldriver.h>
#include <qsqldatabase.h>
#include <qsqlrecord.h>
#include <qhash.h>
#include <qobjectdefs.h>
#include "recordlist.h"
#include "record.h"
#include "table.h"
#include "smoke.h"

#undef DEBUG
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#ifndef __USE_POSIX
#define __USE_POSIX
#endif
#ifndef __USE_XOPEN
#define __USE_XOPEN
#endif
#ifdef _BOOL
#define HAS_BOOL
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifndef QT_VERSION_STR
#define QT_VERSION_STR "Unknown"
#endif

#undef free
#undef malloc

#include "marshall.h"
#include "perlqt.h"
#include "smokeperl.h"

#ifndef IN_BYTES
#define IN_BYTES IN_BYTE
#endif

#ifndef IN_LOCALE
#define IN_LOCALE (PL_curcop->op_private & HINT_LOCALE)
#endif


extern Smoke *qt_Smoke;
extern void init_qt_Smoke();

int do_debug = 0;//0xffffffff;

HV *pointer_map = 0;
SV *sv_qapp = 0;
int object_count = 0;
void *_current_object = 0;    // TODO: ask myself if this is stupid

bool temporary_virtual_function_success = false;

static QHash<QByteArray,Smoke::Index*> *methcache = 0;
static QHash<QByteArray,Smoke::Index*> *classcache = 0;

SV *sv_this = 0;

Smoke::Index _current_object_class = 0;
Smoke::Index _current_method = 0;

extern TypeHandler Qt_handlers[];
void install_handlers(TypeHandler *);

void *sv_to_ptr(SV *sv) {  // ptr on success, null on fail
	smokeperl_object *o = sv_obj_info(sv);
	return o ? o->ptr : 0;
}

bool isQObject(Smoke *smoke, Smoke::Index classId)
{
	if(!strcmp(smoke->classes[classId].className, "QObject"))
		return true;
	for(Smoke::Index *p = smoke->inheritanceList + smoke->classes[classId].parents;	*p;	p++) {
		if(isQObject(smoke, *p))
			return true;
	}
	return false;
}

int isDerivedFrom(Smoke *smoke, Smoke::Index classId, Smoke::Index baseId, int cnt)
{
	if(classId == baseId)
		return cnt;
	cnt++;
	for(Smoke::Index *p = smoke->inheritanceList + smoke->classes[classId].parents; *p; p++) {
		if(isDerivedFrom(smoke, *p, baseId, cnt) != -1)
			return cnt;
	}
	return -1;
}

int isDerivedFrom(Smoke *smoke, const char *className, const char *baseClassName, int cnt)
{
	if(!smoke || !className || !baseClassName)
		return -1;
	Smoke::Index idClass = smoke->idClass(className);
	Smoke::Index idBase = smoke->idClass(baseClassName);
	return isDerivedFrom(smoke, idClass, idBase, cnt);
}

SV *getPointerObject(void *ptr)
{
	HV *hv = pointer_map;
	SV *keysv = newSViv((IV)ptr);
	STRLEN len;
	char *key = SvPV(keysv, len);
	SV **svp = hv_fetch(hv, key, len, 0);
	if(!svp){
		SvREFCNT_dec(keysv);
		return 0;
	}
    if(!SvOK(*svp)){
		hv_delete(hv, key, len, G_DISCARD);
		SvREFCNT_dec(keysv);
		return 0;
	}
	return *svp;
}

void unmapPointer(smokeperl_object *o, Smoke::Index classId, void *lastptr)
{
	HV *hv = pointer_map;
	void *ptr = o->smoke->cast(o->ptr, o->classId, classId);
	if(ptr != lastptr) {
		lastptr = ptr;
		SV *keysv = newSViv((IV)ptr);
		STRLEN len;
		char *key = SvPV(keysv, len);
		if(hv_exists(hv, key, len))
			hv_delete(hv, key, len, G_DISCARD);
		SvREFCNT_dec(keysv);
	}
    for(Smoke::Index *i = o->smoke->inheritanceList + o->smoke->classes[classId].parents; *i; i++) {
		unmapPointer(o, *i, lastptr);
	}
}

// Store pointer in pointer_map hash : "pointer_to_Qt_object" => weak ref to associated Perl object
// Recurse to store it also as casted to its parent classes.

void mapPointer(SV *obj, smokeperl_object *o, HV *hv, Smoke::Index classId, void *lastptr) {
	void *ptr = o->smoke->cast(o->ptr, o->classId, classId);
	if(ptr != lastptr) {
		lastptr = ptr;
		SV *keysv = newSViv((IV)ptr);
		STRLEN len;
		char *key = SvPV(keysv, len);
		SV *rv = newSVsv(obj);
		sv_rvweaken(rv);		// weak reference!
		hv_store(hv, key, len, rv, 0);
		SvREFCNT_dec(keysv);
	}
	for(Smoke::Index *i = o->smoke->inheritanceList + o->smoke->classes[classId].parents; *i; i++) {
		mapPointer(obj, o, hv, *i, lastptr);
	}
}

Marshall::HandlerFn getMarshallFn(const SmokeType &type);

class VirtualMethodReturnValue : public Marshall {
	Smoke *_smoke;
	Smoke::Index _method;
	Smoke::Stack _stack;
	SmokeType _st;
	SV *_retval;
public:
	const Smoke::Method & method()
	{
		return _smoke->methods[_method];
	}
	
	SmokeType type() { return _st; }
	
	Marshall::Action action() { return Marshall::FromSV; }
	
	Smoke::StackItem &item() { return _stack[0]; }
	
	SV *var() { return _retval; }
	
    void unsupported() {
		croak("Cannot handle '%s' as return-type of virtual method %s::%s",
			type().name(),
			_smoke->className(method().classId),
			_smoke->methodNames[method().name]);
    }
	
    Smoke *smoke() { return _smoke; }
	
	void next() {}
	
	bool cleanup() { return false; }
	
	VirtualMethodReturnValue(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, SV *retval) :
	_smoke(smoke), _method(meth), _stack(stack), _retval(retval) {
		_st.set(_smoke, method().ret);
		Marshall::HandlerFn fn = getMarshallFn(type());
		(*fn)(this);
	}
};

class VirtualMethodCall : public Marshall {
	Smoke *_smoke;
	Smoke::Index _method;
	Smoke::Stack _stack;
	GV *_gv;
	int _cur;
	Smoke::Index *_args;
	SV **_sp;
	bool _called;
	SV *_savethis;
	
public:
    SmokeType type() { return SmokeType(_smoke, _args[_cur]); }

	Marshall::Action action() { return Marshall::ToSV; }

	Smoke::StackItem &item() { return _stack[_cur + 1]; }

	SV *var() { return _sp[_cur]; }

	const Smoke::Method &method() { return _smoke->methods[_method]; }

	void unsupported() {
		croak("Cannot handle '%s' as argument of virtual method %s::%s",
			type().name(),
			_smoke->className(method().classId),
			_smoke->methodNames[method().name]);
    }

	Smoke *smoke() { return _smoke; }

	void callMethod() {
		dSP;
		if(_called)
			return;
		_called = true;
		SP = _sp + method().numArgs - 1;
		PUTBACK;
		int count = call_sv((SV*)GvCV(_gv), G_SCALAR);
		SPAGAIN;
		VirtualMethodReturnValue r(_smoke, _method, _stack, POPs);
		PUTBACK;
		FREETMPS;
		LEAVE;
	}

	void next() {
		int oldcur = _cur;
		_cur++;
		while(!_called && _cur < method().numArgs) {
			Marshall::HandlerFn fn = getMarshallFn(type());
			(*fn)(this);
			_cur++;
		}
		callMethod();
		_cur = oldcur;
    }

	bool cleanup() { return false; }   // is this right?
	
	VirtualMethodCall(Smoke *smoke, Smoke::Index meth, Smoke::Stack stack, SV *obj, GV *gv) :
	_smoke(smoke), _method(meth), _stack(stack), _gv(gv), _cur(-1), _sp(0), _called(false) {
		dSP;
		ENTER;
		SAVETMPS;
		PUSHMARK(SP);
		EXTEND(SP, method().numArgs);
		_savethis = sv_this;
		sv_this = newSVsv(obj);
		_sp = SP + 1;
		for(int i = 0; i < method().numArgs; i++)
			_sp[i] = sv_newmortal();
			_args = _smoke->argumentList + method().args;
		}
		~VirtualMethodCall() {
		SvREFCNT_dec(sv_this);
		sv_this = _savethis;
    }
};

class MethodReturnValue : public Marshall {
	Smoke *_smoke;
	Smoke::Index _method;
	SV *_retval;
	Smoke::Stack _stack;
public:
	MethodReturnValue(Smoke *smoke, Smoke::Index method, Smoke::Stack stack, SV *retval) :
	_smoke(smoke), _method(method), _retval(retval), _stack(stack) {
		Marshall::HandlerFn fn = getMarshallFn(type());
		(*fn)(this);
	}
	
	const Smoke::Method &method() { return _smoke->methods[_method]; }
	
	SmokeType type() { return SmokeType(_smoke, method().ret); }
	
	Marshall::Action action() { return Marshall::ToSV; }
	
	Smoke::StackItem &item() { return _stack[0]; }
	
	SV *var() { return _retval; }

	void unsupported() {
		croak("Cannot handle '%s' as return-type of %s::%s",
			type().name(),
			_smoke->className(method().classId),
			_smoke->methodNames[method().name]);
    }

	Smoke *smoke() { return _smoke; }

	void next() {}

	bool cleanup() { return true; }
};

class MethodCall : public Marshall {
	int _cur;
	Smoke *_smoke;
	Smoke::Stack _stack;
	Smoke::Index _method;
	Smoke::Index *_args;
	SV **_sp;
	int _items;
	SV *_retval;
	bool _called;
public:
	MethodCall(Smoke *smoke, Smoke::Index method, SV **sp, int items) :
	_smoke(smoke), _method(method), _sp(sp), _items(items), _cur(-1), _called(false)
	{
		_args = _smoke->argumentList + _smoke->methods[_method].args;
		_items = _smoke->methods[_method].numArgs;
		_stack = new Smoke::StackItem[items + 1];
		_retval = newSV(0);
    }
    ~MethodCall() {
		delete[] _stack;
		SvREFCNT_dec(_retval);
    }
    
	SmokeType type() { return SmokeType(_smoke, _args[_cur]); }
    
	Marshall::Action action() { return Marshall::FromSV; }
    
	Smoke::StackItem &item() { return _stack[_cur + 1]; }
    
	SV *var() {
		if(_cur < 0) return _retval;
		SvGETMAGIC(*(_sp + _cur));
		return *(_sp + _cur);
	}
	
	inline const Smoke::Method &method() { return _smoke->methods[_method]; }
    
	void unsupported() {
		croak("Cannot handle '%s' as argument to %s::%s",
			type().name(),
			_smoke->className(method().classId),
			_smoke->methodNames[method().name]);
    }
    
	Smoke *smoke() { return _smoke; }
    
	inline void callMethod() {
		if(_called)
			return;
		_called = true;
		Smoke::ClassFn fn = _smoke->classes[method().classId].classFn;
		void *ptr = _smoke->cast(
			_current_object,
			_current_object_class,
			method().classId
		);
		_items = -1;
		(*fn)(method().method, ptr, _stack);
		MethodReturnValue r(_smoke, _method, _stack, _retval);
    }
    void next() {
		int oldcur = _cur;
		_cur++;
	
		while(!_called && _cur < _items) {
			Marshall::HandlerFn fn = getMarshallFn(type());
			(*fn)(this);
			_cur++;
		}

		callMethod();
		_cur = oldcur;
	}
	bool cleanup() { return true; }
};
/*
class UnencapsulatedQObject : public QObject {
public:
	QConnectionList *public_receivers(int signal) const { return receivers(signal); }
	void public_activate_signal(QConnectionList *clist, QUObject *o) { activate_signal(clist, o); }
};
*/
class EmitSignal : public Marshall {
	QObject *_qobj;
	const QMetaObject * _meta;
	QMetaMethod _method;
	int _id;
	SV **_sp;
	int _items;
	int _cur;
	SmokeType * _types;
	Smoke::Stack _stack;
	bool _called;
public:
	EmitSignal(QObject *qobj, int id, SV **sp)
	: _qobj(qobj)
	, _meta( 0 )
	, _id( id )
	, _items(0)
	, _sp(sp)
	, _cur(-1)
	, _called(false)
	{
		_meta = _qobj->metaObject();
		_method = _meta->method( id + _meta->methodOffset() );
		_items = _method.parameterTypes().size();
		int cnt = _items;
		if( !cnt ) cnt = 1;
		_stack = new Smoke::StackItem[cnt];
		_types = new SmokeType[cnt];
    }

	~EmitSignal() {
		delete[] _stack;
		delete[] _types;
    }
	
	SmokeType type() { return _types[_cur]; }

	Marshall::Action action() { return Marshall::FromSV; }

	Smoke::StackItem &item() { return _stack[_cur]; }

	SV *var() { return _sp[_cur]; }

	void unsupported() {
		croak("Cannot handle '%s' as signal argument", type().name());
    }

	Smoke *smoke() { return type().smoke(); }

	void prepareTypes()
	{
		QList<QByteArray> argTypes = _method.parameterTypes();
		for(int i = 0; i < argTypes.size(); i++) {
			SmokeType & type = _types[i];
			Smoke::Index typeId = qt_Smoke->idType(argTypes.at(i).constData());
			if( !typeId ) {
				warn( "Couldn't find smoke type for type: %s",argTypes.at(i).constData());
				continue;
			}
			type = SmokeType(qt_Smoke, typeId);
		}
	}

	void emitSignal() {
		if(_called) return;
		_called = true;
		void ** args = (void**)malloc(sizeof(void*)*(_items+1));
		QList<QByteArray> argTypes = _method.parameterTypes();
		for(int i = 0; i < argTypes.size(); i++) {
			int qtypeId = QMetaType::type(argTypes.at(i).constData());
			Smoke::StackItem & it = _stack[i];
			SmokeType & type = _types[i];
			if( qtypeId == QMetaType::VoidStar || qtypeId == QMetaType::QObjectStar || qtypeId == QMetaType::QWidgetStar )
				args[i+1] = it.s_voidp;
			else
				args[i+1] = &it.s_voidp;
		}
		QMetaObject::activate(_qobj, _meta, _id, args );
		free(args);
    }

	void next()
	{
		int oldcur = _cur;
		_cur++;

		prepareTypes();

		while(!_called && _cur < _items) {
			Marshall::HandlerFn fn = getMarshallFn(type());
			(*fn)(this);
			_cur++;
		}
	
		emitSignal();
		_cur = oldcur;
    }
    bool cleanup() { return true; }
};

class InvokeMetaMethod : public Marshall
{
    QObject *_qobj;
	const QMetaObject * _meta;
	const QMetaMethod & _member;
	int _id;
	void ** _args;
	SmokeType * _types;
    GV *_gv;
    int _items;
    int _cur;
    bool _called;
    SV **_sp;
    Smoke::Stack _stack;
public:
	SmokeType type() { return _types[_cur]; }

	Marshall::Action action() { return Marshall::ToSV; }
	
	Smoke::StackItem &item() { return _stack[_cur]; }
	
	SV *var() { return _sp[_cur]; }
	
	Smoke *smoke() { return type().smoke(); }
	
	bool cleanup() { return false; }
	
	void unsupported() {
		croak("Cannot handle '%s' as slot argument\n", type().name());
    }

	void copyArguments() {
		QList<QByteArray> argTypes = _member.parameterTypes();
		for (int i = 0; i < argTypes.count(); ++i) {
			int qtypeId = QMetaType::type(argTypes.at(i).constData());
			Smoke::StackItem & it = _stack[i];
			void * s = _args[i+1];
			SmokeType & type = _types[i];
			Smoke::Index typeId = qt_Smoke->idType(argTypes.at(i).constData());

			if( !typeId ) {
				warn( "Couldn't find smoke type for type: %s",argTypes.at(i).constData());
				continue;
			}

			type = SmokeType(qt_Smoke, typeId);

			switch( qtypeId ) {
		        case QMetaType::Void:
					break;
				case QMetaType::Bool:
					it.s_bool = *(bool*)s;
					break;
				case QMetaType::Int:
					it.s_int = *(int*)s;
					break;
				case QMetaType::UInt:
					it.s_uint = *(unsigned int*)s;
					break;
				case QMetaType::Double:
					it.s_double = *(double*)s;
					break;
				case QMetaType::Long:
					it.s_long = *(long*)s;
					break;
				case QMetaType::Short:
					it.s_short = *(short*)s;
					break;
				case QMetaType::Char:
					it.s_char = *(char*)s;
					break;
				case QMetaType::ULong:
					it.s_ulong = *(unsigned long*)s;
					break;
				case QMetaType::UShort:
					it.s_ushort = *(unsigned short*)s;
					break;
				case QMetaType::UChar:
					it.s_uchar = *(unsigned char*)s;
					break;
				case QMetaType::Float:
					it.s_float = *(float*)s;
					break;
				case QMetaType::QObjectStar:
				case QMetaType::QWidgetStar:
				case QMetaType::User:
				case QMetaType::QChar:
				case QMetaType::QString:
				case QMetaType::QByteArray:
				case QMetaType::VoidStar:
					it.s_voidp = s;
					break;
			}
		}
	}
	
	void invokeSlot() {
		dSP;
		if(_called) return;
		_called = true;
	
		SP = _sp + _items - 1;
		PUTBACK;
		int count = call_sv((SV*)GvCV(_gv), G_SCALAR);
		SPAGAIN;
		SP -= count;
		PUTBACK;
		FREETMPS;
		LEAVE;
	}

	void next() {
		int oldcur = _cur;
		_cur++;
	
		while(!_called && _cur < _items) {
			Marshall::HandlerFn fn = getMarshallFn(type());
			(*fn)(this);
			_cur++;
		}
	
		invokeSlot();
		_cur = oldcur;
    }

	InvokeMetaMethod(QObject *qobj, const QMetaObject *meta, const QMetaMethod & _method, int id, void ** args, GV *gv)
	: _qobj(qobj)
	, _meta(meta)
	, _member(_method)
	, _id(id)
	, _args(args)
	, _types(0)
	, _gv(gv)
	, _items(_member.parameterTypes().size())
	, _cur(-1)
	, _called(false)
	{
		dSP;
		ENTER;
		SAVETMPS;
		PUSHMARK(SP);
		EXTEND(SP, _items);
		PUTBACK;
		_sp = SP + 1;
		for(int i = 0; i < _items; i++)
			_sp[i] = sv_newmortal();
		_stack = new Smoke::StackItem[_items];
		_types = new SmokeType[_items];
		copyArguments();
	}

	~InvokeMetaMethod() {
		delete[] _stack;
		delete[] _types;
	}
};

class QtSmokeBinding : public SmokeBinding {
public:
	QtSmokeBinding(Smoke *s)
	: SmokeBinding(s)
	{}
	
	void deleted(Smoke::Index classId, void *ptr) {
		SV *obj = getPointerObject(ptr);
		smokeperl_object *o = sv_obj_info(obj);
		if(do_debug && (do_debug & qtdb_gc)) {
			fprintf(stderr, "%p->~%s()\n", ptr, smoke->className(classId));
		}
		if(!o || !o->ptr) {
			return;
		}
		unmapPointer(o, o->classId, 0);
		o->ptr = 0;
    }
    
	bool callMethod(Smoke::Index method, void *ptr, Smoke::Stack args, bool isAbstract)
	{
		SV *obj = getPointerObject(ptr);
		smokeperl_object *o = sv_obj_info(obj);
		if(do_debug && (do_debug & qtdb_virtual)) fprintf(stderr, "virtual %p->%s::%s() called\n", ptr,
			smoke->classes[smoke->methods[method].classId].className,
			smoke->methodNames[smoke->methods[method].name]
		);
	
		if(!o) {
			if(!PL_dirty && (do_debug && (do_debug & qtdb_virtual)) )   // if not in global destruction
			fprintf(stderr, "Cannot find object for virtual method\n");
			return false;
		}
		HV *stash = SvSTASH(SvRV(obj));
		if(*HvNAME(stash) == ' ')
			stash = gv_stashpv(HvNAME(stash) + 1, TRUE);
		const char * methodName = smoke->methodNames[smoke->methods[method].name];
		GV *gv = gv_fetchmethod_autoload(stash, methodName, 0);
		if(!gv)
			return false;

		VirtualMethodCall c(smoke, method, args, obj, gv);
		// exception variable, just temporary
		temporary_virtual_function_success = true;
		c.next();
		bool ret = temporary_virtual_function_success;
		temporary_virtual_function_success = true;
		return ret;
    }
	
	int strreg(QList<QByteArray> & strings, const char * s )
	{
		int idx = 0;
		if( !s )
			s = "";
		for (int i = 0; i < strings.size(); ++i) {
			const QByteArray &str = strings.at(i);
			if (str == s)
				return idx;
			idx += str.length() + 1;
		}
		strings.append(s);
		return idx;
	}

	QMetaObject * qt_getMetaObject(const QObject*qobj, const QMetaObject *parent)
	{
		SV *obj = getPointerObject((void*)qobj);
		HV * stash = SvSTASH(SvRV(obj));

		// $meta = $stash->{META}
		SV **svp = hv_fetch(stash, "META", 4, 0);
		if(!svp)
			return 0;
		HV *hv = GvHV((GV*)*svp);
		if(!hv)
			return 0;
		
		svp = hv_fetch(hv, "changed", 7, 0);
		if( svp && SvIV(*svp) > 0 ) {
			// Update the metaObject
			QList<QByteArray> strings;
			int nsigs=0, nslots=0;
			HV * signalshv=0, * slotshv=0;

			svp = hv_fetch(hv, "signal", 6, 0);
			if(svp) {
				signalshv = (HV*)SvRV(*svp);
				nsigs = hv_iterinit( signalshv );
			}
			svp = hv_fetch(hv, "slot", 4, 0);
			if(svp) {
				slotshv = (HV*)SvRV(*svp);
				nslots = hv_iterinit( slotshv );
			}

			int methods = nsigs+nslots;
			uint * metadata = new uint[10+5*methods];

			int index = 10;

			metadata[0] = 1; // Version
			metadata[1] = 0; // Classname
			metadata[2] = metadata[3] = 0; // ClassInfo
			metadata[4] = methods;
			metadata[5] = methods > 0 ? index : 0; // methods
			index += methods * 5;
			metadata[6] = metadata[7] = 0; // properties
			metadata[8] = metadata[9] = 0; // enums/sets

			index = 10;

			// Signals
			if( signalshv && nsigs > 0 ) {
				char * key;
				SV * val;
				I32 len;
				while( (val = hv_iternextsv(signalshv,&key,&len)) ) {
					HV * sighv = (HV*)SvRV(val);
					svp = hv_fetch(sighv,"prototype",9,0);
					char * proto = 0;
					if( svp )
						proto = SvPV_nolen(*svp);
					metadata[index++] = strreg(strings,proto);
					metadata[index++] = strreg(strings,0);
					metadata[index++] = strreg(strings,0);
					metadata[index++] = strreg(strings,0);
					metadata[index++] = 0x05;
				}
			}
			
			// Slots
			if( slotshv && nslots > 0 ) {
				char * key;
				SV * val;
				I32 len;
				while( (val = hv_iternextsv(slotshv,&key,&len)) ) {
					HV * sighv = (HV*)SvRV(val);
					svp = hv_fetch(sighv,"prototype",9,0);
					char * proto = 0;
					if( svp )
						proto = SvPV_nolen(*svp);
					metadata[index++] = strreg(strings,proto);
					metadata[index++] = strreg(strings,0);
					metadata[index++] = strreg(strings,0);
					metadata[index++] = strreg(strings,0);
					metadata[index++] = 0x0a;
				}
			}

			char * stringdata = 0;
			{
				int sdlen = 0;
				for (int i = 0; i < strings.size(); ++i) {
					QByteArray s = strings.at(i);
					sdlen += s.length() + 1;
				}
	
				stringdata = new char[sdlen];
				int pos = 0;
				for (int i = 0; i < strings.size(); ++i) {
					QByteArray s = strings.at(i);
					qstrcpy( stringdata + pos, s.constData() );
					pos += s.length();
					stringdata[pos++] = 0;
				}
			}

			QMetaObject * meta = new QMetaObject();
			meta->d.superdata = parent;
			meta->d.stringdata = stringdata;
			meta->d.data = metadata;
			meta->d.extradata = 0;

			SV * to_store = 0;

			{
				HV *hv = newHV();
				SV *obj = newRV_noinc((SV*)hv);
				
				smokeperl_object o;
				o.smoke = qt_Smoke;
				o.classId = qt_Smoke->idClass("QMetaObject");
				o.ptr = meta;
				o.allocated = true;
				sv_magic((SV*)hv, sv_qapp, '~', (char*)&o, sizeof(o));
				MAGIC *mg = mg_find((SV*)hv, '~');
				mg->mg_virtual = &vtbl_smoke;
				char *buf = qt_Smoke->binding->className(o.classId);
				sv_bless(obj, gv_stashpv(buf, TRUE));
				delete[] buf;
				to_store = obj;
			}

			hv_store(hv,"object",6, to_store,0);
			hv_delete(hv,"changed",7,0);

			return meta;
		}

		// $metaobject = $meta->{object}
		// aka. Class->staticMetaObject
		svp = hv_fetch(hv, "object", 6, 0);
		if(!svp)
			return 0;
		smokeperl_object *ometa = sv_obj_info(*svp);
		if(!ometa)
			return 0;
		return (QMetaObject*)ometa->ptr;
	}

	int qt_metacall( const QObject * caller, QMetaObject::Call type, int id, void ** args )
	{

		SV * obj = getPointerObject((void*)caller);
		smokeperl_object *o = sv_obj_info(obj);
	
		if(!o) {
			fprintf(stderr, "Cannot find object for metacall\n");
			return false;
		}

		const QMetaObject * mo = caller->metaObject();
		QMetaMethod meth = mo->method(id + mo->methodOffset());
		
		const char * sig = meth.signature();
		int ne = 0;
		while( sig[ne] && sig[ne] != '(' ) ne++;

		if( sig[ne] != '(' ) {
			warn( "MetaMethod signature contains no (" );
			return id;
		}

		char * methname = new char[ne+1];
		strncpy(methname,sig,ne);
		methname[ne] = 0;

		HV *stash = SvSTASH(SvRV(obj));
		if(*HvNAME(stash) == ' ')
			stash = gv_stashpv(HvNAME(stash) + 1, TRUE);

		GV *gv = gv_fetchmethod_autoload(stash, methname, 0);
		delete [] methname;

		if(!gv) {
			warn( "Couldn't find perl method for metamethod" );
			return false;
		}

		InvokeMetaMethod iv((QObject*)caller,mo,meth,id,args,gv);
		iv.next();
		return id;
	}

	char *className(Smoke::Index classId) {
		const char *className = smoke->className(classId);
		if( !className )
			return 0;
		bool isQClass = (*className == 'Q');
		char *buf = new char[strlen(className) + (isQClass ? 6 : 15)];
		strcpy(buf, isQClass ? "Qt::" : "Blur::Model::");
		strcat(buf, className + (isQClass ? 1 : 0));
		return buf;
	}
};

// ----------------   Helpers -------------------

SV *catArguments(SV** sp, int n)
{
	SV* r=newSVpvf("");
	for(int i = 0; i < n; i++) {
		if(i)
			sv_catpv(r, ", ");
		if(!SvOK(sp[i])) {
			sv_catpv(r, "undef");
		} else if(SvROK(sp[i])) {
			smokeperl_object *o = sv_obj_info(sp[i]);
			if(o)
				sv_catpv(r, o->smoke->className(o->classId));
			else
				sv_catsv(r, sp[i]);
		} else {
			bool isString = SvPOK(sp[i]);
			STRLEN len;
			char *s = SvPV(sp[i], len);
			if(isString)
				sv_catpv(r, "'");
			sv_catpvn(r, s, len > 10 ? 10 : len);
			if(len > 10)
				sv_catpv(r, "...");
			if(isString)
				sv_catpv(r, "'");
		}
	}
	return r;
}

Smoke::Index package_classid(const char *p)
{
	Smoke::Index *item = classcache->value(p);
	if(item)
		return *item;
	char *nisa = new char[strlen(p)+6];
	strcpy(nisa, p);
	strcat(nisa, "::ISA");
	AV* isa=get_av(nisa, true);
	delete[] nisa;
	for(int i=0; i<=av_len(isa); i++) {
		SV** np = av_fetch(isa, i, 0);
		if(np) {
			Smoke::Index ix = package_classid(SvPV_nolen(*np));
			if(ix) {
				classcache->insert(p, new Smoke::Index(ix));
				return ix;
			}
		}
	}
	return (Smoke::Index) 0;
}

char *get_SVt(SV *sv)
{
	char *r;
	if(!SvOK(sv))
		r = "u";
	else if(SvIOK(sv))
		r = "i";
	else if(SvNOK(sv))
		r = "n";
	else if(SvPOK(sv))
		r = "s";
	else if(SvROK(sv)) {
		smokeperl_object *o = sv_obj_info(sv);
		if(!o) {
			switch (SvTYPE(SvRV(sv))) {
				case SVt_PVAV:
					r = "a";
					break;
	//                case SVt_PV:
	//                case SVt_PVMG:
	//                  r = "p";
				default:
					r = "r";
			}
		} else
			r = (char*)o->smoke->className(o->classId);
	} else
		r = "U";
	return r;
}

SV *prettyPrintMethod(Smoke::Index id)
{
	SV *r = newSVpvf("");
	Smoke::Method &meth = qt_Smoke->methods[id];
	const char *tname = qt_Smoke->types[meth.ret].name;
	if(meth.flags & Smoke::mf_static)
		sv_catpv(r, "static ");
	sv_catpvf(r, "%s ", (tname ? tname:"void"));
	sv_catpvf(r, "%s::%s(", qt_Smoke->classes[meth.classId].className, qt_Smoke->methodNames[meth.name]);
	for(int i = 0; i < meth.numArgs; i++) {
		if(i)
			sv_catpv(r, ", ");
		tname = qt_Smoke->types[qt_Smoke->argumentList[meth.args+i]].name;
		sv_catpv(r, (tname ? tname:"void"));
	}
	sv_catpv(r, ")");
	if(meth.flags & Smoke::mf_const)
		sv_catpv(r, " const");
	return r;
}

// --------------- Unary Keywords && Attributes ------------------


// implements unary 'this'
XS(XS_this) {
	dXSARGS;
	ST(0) = sv_this;
	XSRETURN(1);
}

// implements unary attributes: 'foo' means 'this->{foo}'
XS(XS_attr) {
	dXSARGS;
	char *key = GvNAME(CvGV(cv));
	U32 klen = strlen(key);
	SV **svp = 0;
	if(SvROK(sv_this) && SvTYPE(SvRV(sv_this)) == SVt_PVHV) {
		HV *hv = (HV*)SvRV(sv_this);
		svp = hv_fetch(hv, key, klen, 1);
	}
	if(svp) {
		ST(0) = *svp;
		XSRETURN(1);
	}
	XSRETURN_UNDEF;
}

// implements unary SUPER attribute: 'SUPER' means ${(CopSTASH)::_INTERNAL_STATIC_}{SUPER}
XS(XS_super) {
	dXSARGS;
	char *key = "SUPER";
	U32 klen = strlen(key);
	SV **svp = 0;
	if(SvROK(sv_this) && SvTYPE(SvRV(sv_this)) == SVt_PVHV) {
		HV *cs = (HV*)CopSTASH(PL_curcop);
		if(!cs) XSRETURN_UNDEF;
			svp = hv_fetch(cs, "_INTERNAL_STATIC_", 17, 0);
		if(!svp) XSRETURN_UNDEF;
			cs = GvHV((GV*)*svp);
		if(!cs) XSRETURN_UNDEF;
			svp = hv_fetch(cs, "SUPER", 5, 0);
	}
	if(svp) {
		ST(0) = *svp;
		XSRETURN(1);
	}
	XSRETURN_UNDEF;
}

//---------- XS Autoload (for all functions except fully qualified statics & enums) ---------

static inline bool isQtOrBlurModel(char *p) {
	return 
		(p[0] == 'Q' && p[1] && p[1] == 't' && ((p[2] && p[2] == ':') || !p[2]))
		|| (!strncmp(p,"Blur::Model::",13));
}

/* Applied below to support returning arrays
-	ENTER;
-	SAVETMPS;
 	PUSHMARK(SP - items + withObject);
 	PUTBACK;
-	int count = call_sv((SV*)GvCV(gv), G_SCALAR|G_EVAL);
+        I32 gimme = GIMME_V;
+	int count = call_sv((SV*)GvCV(gv), gimme|G_EVAL);
 	SPAGAIN;
-	SV *ret = newSVsv(TOPs);
-	SP -= count;
-	PUTBACK;
-	FREETMPS;
-	LEAVE;
+        SP -= count;
+        if (withObject) // shift the stack
+            for (int i=0; i<count; i++)
+                ST(i) = ST(i+1);
+        PUTBACK;
 
 	if(withObject && !isSuper) {
 	    SvREFCNT_dec(sv_this);
@@ -1014,8 +1013,10 @@ XS(XS_AUTOLOAD) {
 
         if(SvTRUE(ERRSV))
             croak(SvPV_nolen(ERRSV));
-	ST(0) = sv_2mortal(ret);
-	XSRETURN(1);
+        if (gimme == G_VOID)
+            XSRETURN_UNDEF;
+        else
+	    XSRETURN(count);
     }
     else if(!strcmp(method, "DESTROY")) {
         SV *old_this;
*/

bool avoid_fetchmethod = false;
XS(XS_AUTOLOAD) {
	// Err, XS autoload is borked. Lets try...
	dXSARGS;
	SV *sv = get_sv("Qt::AutoLoad::AUTOLOAD", TRUE);
	char *package = SvPV_nolen(sv);
	char *method = 0;
	for(char *s = package; *s ; s++)
		if(*s == ':') method = s;
	if(!method) XSRETURN_NO;
	
	*(method++ - 1) = 0;	// sorry for showing off. :)
	
	int withObject = 0;//(*package == ' ') ? 1 : 0;
	if( items > 0 ) {
		smokeperl_object * obj = sv_obj_info(ST(0));
		if( obj ) {
			Smoke::Index idx = package_classid( package );
			if( idx == obj->classId ) //|| (isDerivedFrom( qt_Smoke, )
				withObject = 1;
		}
	}

	if(do_debug && (do_debug & qtdb_autoload))
		warn("In XS Autoload for %s%s%s()\n", package, withObject ? "->" : "::", method);
	
	int isSuper = 0;
	if( withObject ) {
		if( *package == ' ' )
			package++;
		if( *package == ' ') {
			isSuper = 1;
			if( *(package+1) == ' ' ) package++;
			
			char *super = new char[strlen(package) + 7];
			package++;
			strcpy(super, package);
			strcat(super, "::SUPER");
			package = super;
		}
	}

    if( !withObject && isQtOrBlurModel(package) )
		avoid_fetchmethod = true;

	HV *stash = gv_stashpv(package, TRUE);
	
	// check for user-defined methods in the REAL stash; skip prefix
	GV *gv = 0;
	if(avoid_fetchmethod) {
		avoid_fetchmethod = false;
		//gv = gv_fetchmeth(stash, method, 0,-1);
	} else
		gv = gv_fetchmethod_autoload(stash, method, 0);

	// If we've made it here, we need to set sv_this
	if(gv) {
		if(do_debug && (do_debug & qtdb_autoload))
			warn("\tfound in %s's Perl stash\n", package);

		// call the defined Perl method with new 'this'
		SV *old_this;
		if(withObject && !isSuper) {
			old_this = sv_this;
			sv_this = newSVsv(ST(0));
		}

// Modified this line to pass the this object, was
//		PUSHMARK(SP - items + withObject);
		PUSHMARK(SP - items);
		PUTBACK;
		I32 gimme = GIMME_V;
		int count = call_sv((SV*)GvCV(gv), gimme|G_EVAL);
		SPAGAIN;
		SP -= count;
//		if( withObject )
//			for( int i=0; i<count; i++ )
//				ST(i) = ST(i+1);
		PUTBACK;
		
		if(withObject && !isSuper) {
			SvREFCNT_dec(sv_this);
			sv_this = old_this;
		}
		else if(isSuper)
			delete[] package;

		if(SvTRUE(ERRSV))
			croak(SvPV_nolen(ERRSV));
		if(gimme == G_VOID)
			XSRETURN_UNDEF;
		else
			XSRETURN(count);
	}
	else if(!strcmp(method, "DESTROY")) {
		SV *old_this;
		if(withObject && !isSuper) {
			old_this = sv_this;
			sv_this = newSVsv(ST(0));
		}
		smokeperl_object *o = sv_obj_info(sv_this);
	
		if(!(o && o->ptr && (o->allocated || getPointerObject(o->ptr)))) {
			if(isSuper)
				delete[] package;
			if(withObject && !isSuper) {
				SvREFCNT_dec(sv_this);
				sv_this = old_this;
			}
			XSRETURN_YES;
		}
		const char *key = "has been hidden";
		U32 klen = 15;
		SV **svp = 0;
		if(SvROK(sv_this) && SvTYPE(SvRV(sv_this)) == SVt_PVHV) {
			HV *hv = (HV*)SvRV(sv_this);
			svp = hv_fetch(hv, key, klen, 0);
		}
		if(svp) {
			if(isSuper)
					delete[] package;
				if(withObject && !isSuper) {
				SvREFCNT_dec(sv_this);
				sv_this = old_this;
			}
			XSRETURN_YES;
		}
		gv = gv_fetchmethod_autoload(stash, "ON_DESTROY", 0);
		if( !gv )
			croak( "Couldn't find ON_DESTROY method for %s=%p\n", package, o->ptr);
		PUSHMARK(SP);
		call_sv((SV*)GvCV(gv), G_SCALAR|G_NOARGS);
		SPAGAIN;
		int ret = POPi;
		PUTBACK;
		if(withObject && !isSuper) {
			SvREFCNT_dec(sv_this);
			sv_this = old_this;
		}
		if( do_debug && ret && (do_debug & qtdb_gc) )
			fprintf(stderr, "Increasing refcount in DESTROY for %s=%p (still has a parent)\n", package, o->ptr);
    } else {
		
		if( items > 18 )  XSRETURN_NO; // current max number of args in Qt is 13.

		// save the stack -- we'll need it
		SV **savestack = new SV*[items+1];
		SV *saveobj = ST(0);
		SV *old_this;

		Copy(SP - items + 1 + withObject, savestack, items-withObject, SV*);

		// Get the classid (eventually converting SUPER to the right Qt class)
		Smoke::Index cid = package_classid(package);
		// Look in the cache
		char *cname = (char*)qt_Smoke->className(cid);
		if( !cname ) {
			warn( package );
			XSRETURN_NO;
		}

		int lcname = strlen(cname);
		int lmethod = strlen(method);
		char mcid[256];
		strncpy(mcid, cname, lcname);
		char *ptr = mcid + lcname;
		*(ptr++) = ';';
		strncpy(ptr, method, lmethod);
		ptr += lmethod;
		for(int i=withObject ; i<items ; i++)
		{
			*(ptr++) = ';';
			char *t = get_SVt(ST(i));
			int tlen = strlen(t);
			strncpy(ptr, t, tlen );
			ptr += tlen;
		}
		*ptr = 0;

		Smoke::Index *rcid = methcache->value(mcid);
		Smoke::Index mid=0;
		
		
		// This is for Record column data getting and setting
		// The process works like this.
		// 1. Make sure the object inherits from Record
		static Smoke::Index Record_cid = 0;
		if( Record_cid == 0 )
			Record_cid = qt_Smoke->idClass( "Record" );
		bool isRecordClass = (isDerivedFrom( qt_Smoke, cid, Record_cid, 1 ) >= 0);
		
		// 2. Make sure there isn't a c++ method with this name and number of args
		bool hasMethod = false;
		if( isRecordClass ) {
			do {
				int methl = strlen(method);
				int methid = qt_Smoke->idMethodName( method );
				if( methid == 0 )
					break;
				int hitcount = 1;
				while( !strncmp( method, qt_Smoke->methodNames[methid+hitcount], methl ) ) hitcount++;
				for( int i=0; i<hitcount; i++ )
					if( qt_Smoke->findMethod( cid, methid+i ) != 0 && (strlen(qt_Smoke->methodNames[methid+i])-methl==items-1) ) {
						hasMethod = true;
						break;
					}
			} while( 0 );
		}
		
		// 3. Find a column, if it is found, push the index onto the stack,
		// and then get the setValue/getValue method id
		if( !hasMethod && !rcid && withObject && isRecordClass ) {
			SV * my_sv_this = ST(0);
			smokeperl_object *o = sv_obj_info(my_sv_this);
			if(o && o->ptr) {
				Record * rec = (Record*)o->ptr;
				bool set = false;
				QString col( method );
				if( !strncmp( method, "set", 3 ) ) {
					//warn( "It is a set method\n" );
					set = true;
					col = col.mid(3);
					col[0] = QChar(col[0]).toLower();
				}
				if( items >= 2 ) {
					set = true;
				}
				
				int colPos = rec->table()->schema()->fieldPos( col );
				// Lets try case-insensitive, and check both methodname and fieldname
				if( colPos == -1 ) {
					col = col.toLower();
					FieldList fl = rec->table()->schema()->columns();
					int i=0;
					for( FieldIter it = fl.begin(); it != fl.end(); ++it, ++i ) {
						if( col == (*it)->name().toLower() || col == (*it)->methodName().toLower() ) {
							colPos = i;
							break;
						}
					}
				}
				if( colPos >= 0 ) {
					const char * valueMethName = set ? "setValue$$" : "getValue$";
					Smoke::Index mnid = qt_Smoke->idMethodName( valueMethName );
					if( mnid ) {
						// Index into the methodMap
						Smoke::Index mmid = qt_Smoke->idMethod( Record_cid, mnid );
						
						mid = qt_Smoke->methodMaps[mmid].method;
						
						// Ambiguious method, this is expected
						if( mid < 0 ) {
							mid = -mid;
							// It is the first one, hopefully this doesn't change
							if( qt_Smoke->ambiguousMethodList[mid] == 0 )
								mid++;
							bool works = false;
							while( !works ) {
								Smoke::Index ambMeth = qt_Smoke->ambiguousMethodList[mid++];
								if( !ambMeth )
									break;
								Smoke::Index argsIndex = qt_Smoke->methods[ambMeth].args;
								if( !argsIndex )
									continue;
								Smoke::Index arg1typeid = qt_Smoke->argumentList[argsIndex];
								if( qt_Smoke->types[arg1typeid].flags & Smoke::t_int ) {
									mid = ambMeth;
									works = true;
									break;
								}
							}
							
							if( !works )
								mid = 0;
						}
							
						if( mid ) {
							rcid = &mid;
							for( int i=items-withObject; i>0; i-- )
								savestack[i] = savestack[i-1];
							savestack[0] = newSViv( colPos );
							items++;
						} else
							warn( "Couldn't find the method index for for method: %s\n", SvPV_nolen(sv_2mortal(newSVpvf(method))) );
						
					} else
						warn( "Couldn't find methodname index for method: %s\n", SvPV_nolen(sv_2mortal(newSVpvf(method))) );
				} else {
				//	warn( "Column not found: %s\n", SvPV_nolen(sv_2mortal(newSVpvf(method))));
				}
			} else
				warn( "Invalid object pointer" );
		}
	
		if(rcid) {
			// Got a hit
			_current_method = *rcid;
			if(withObject && !isSuper) {
				old_this = sv_this;
				sv_this = newSVsv(ST(0));
			}
		} else {

			// Find the C++ method to call. I'll do that from Perl for now
			ENTER;
			SAVETMPS;
			PUSHMARK(SP - items + withObject);
			EXTEND(SP, 3);
			PUSHs(sv_2mortal(newSViv((IV)cid)));
			PUSHs(sv_2mortal(newSVpv(method, 0)));
			PUSHs(sv_2mortal(newSVpv(package, 0)));
			PUTBACK;
			if(withObject && !isSuper) {
				old_this = sv_this;
				sv_this = newSVsv(saveobj);
			}
			call_pv("Qt::_internal::do_autoload", G_DISCARD|G_EVAL);
			if( SvTRUE(ERRSV) ) {
				POPs;
			}
			FREETMPS;
			LEAVE;
	
			// Restore sv_this on error, so that eval{ } works
			if(SvTRUE(ERRSV)) {
				if(withObject && !isSuper) {
					SvREFCNT_dec(sv_this);
					sv_this = old_this;
				}
				else if(isSuper)
					delete[] package;
				delete[] savestack;
				croak(SvPV_nolen(ERRSV));
			}
	
			// Success. Cache result.
			methcache->insert(mcid, new Smoke::Index(_current_method));
		}
		// FIXME: I shouldn't have to set the current object
		{
			smokeperl_object *o = sv_obj_info(sv_this);
			if(o && o->ptr) {
				_current_object = o->ptr;
				_current_object_class = o->classId;
			} else {
				_current_object = 0;
			}
		}
		// honor debugging channels
		if(do_debug && (do_debug & qtdb_calls)) {
			warn("Calling method\t%s\n", SvPV_nolen(sv_2mortal(prettyPrintMethod(_current_method))));
			if(do_debug & qtdb_verbose)
				warn("with arguments (%s)\n", SvPV_nolen(sv_2mortal(catArguments(savestack, items-withObject))));
		}
		MethodCall c(qt_Smoke, _current_method, savestack, items-withObject);
		c.next();
		if(savestack)
			delete[] savestack;
		
		if(do_debug && (do_debug & qtdb_calls)) {
			warn("Finished Calling method\t%s\n", SvPV_nolen(sv_2mortal(prettyPrintMethod(_current_method))));
		}
	
		if(withObject && !isSuper) {
			SvREFCNT_dec(sv_this);
			sv_this = old_this;
		}
		else if(isSuper)
			delete[] package;
	
		SV *ret = c.var();
		SvREFCNT_inc(ret);
		ST(0) = sv_2mortal(ret);
		XSRETURN(1);
	}
	if(isSuper)
		delete[] package;
	XSRETURN_YES;
}


//----------------- Sig/Slot ------------------

XS(XS_Qt___internal_signal) {
	dXSARGS;

	smokeperl_object *o = sv_obj_info(ST(2));
	QObject *qobj = (QObject*)o->smoke->cast(
		o->ptr,
		o->classId,
		o->smoke->idClass("QObject")
    );
	if(qobj->signalsBlocked())
		XSRETURN_UNDEF;

	int index = SvIV(ST(0));
	int argcnt = SvIV(ST(1));

	if(items < argcnt+3)
		croak("Insufficient arguments to emit signal");

	EmitSignal signal(qobj, index, &ST(3));
	signal.next();

	XSRETURN_UNDEF;
}

// -------------------       Tied types        ------------------------

XS(XS_Qt___internal__QString_FETCH)
{
	dXSARGS;
	if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::QString::FETCH(obj)");
    {
		SV*	obj = ST(0);
		SV *	RETVAL;
		if (!SvROK(obj))
			croak("?");
		IV tmp = SvIV((SV*)SvRV(obj));
		QString *s = (QString*) tmp;
		RETVAL = newSV(0);
		if( s )
		{
			if(!(IN_BYTES))
			{
			sv_setpv_mg(RETVAL, (const char *)s->toUtf8());
				SvUTF8_on(RETVAL);
			}
			else if(IN_LOCALE)
				sv_setpv_mg(RETVAL, (const char *)s->toLocal8Bit());
			else
				sv_setpv_mg(RETVAL, (const char *)s->toLatin1());
		}
		else
			sv_setsv_mg(RETVAL, &PL_sv_undef);
		ST(0) = RETVAL;
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}

XS(XS_Qt___internal__QString_STORE)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Qt::_internal::QString::STORE(obj, what)");
	{
		SV*	obj = ST(0);
		SV*	what = ST(1);
		if (!SvROK(obj))
			croak("?");
		IV tmp = SvIV((SV*)SvRV(obj));
		QString *s = (QString*) tmp;
		s->truncate(0);
		if(SvOK(what)) {
			if(SvUTF8(what)) 
				s->append(QString::fromUtf8(SvPV_nolen(what)));
			else if(IN_LOCALE)
				s->append(QString::fromLocal8Bit(SvPV_nolen(what)));
			else
				s->append(QString::fromLatin1(SvPV_nolen(what)));
		}  
	}
	XSRETURN_EMPTY;
}

XS(XS_Qt___internal__QString_DESTROY)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Qt::_internal::QString::DESTROY(obj)");
    {
		SV*	obj = ST(0);
		if (!SvROK(obj))
			croak("?");
		IV tmp = SvIV((SV*)SvRV(obj));
		QString *s = (QString*) tmp;
		delete s;
	}
	XSRETURN_EMPTY;
}

XS(XS_Qt___internal__QByteArray_FETCH)
{
	dXSARGS;
	if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::QByteArray::FETCH(obj)");
    {
		SV*	obj = ST(0);
		SV *	RETVAL;
		if (!SvROK(obj))
			croak("?");
		IV tmp = SvIV((SV*)SvRV(obj));
		QByteArray *s = (QByteArray*) tmp;
		RETVAL = newSV(0);
		if( s )
		{
			sv_setpvn_mg(RETVAL, s->data(), s->size());
		} else
			sv_setsv_mg(RETVAL, &PL_sv_undef);
		ST(0) = RETVAL;
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}

XS(XS_Qt___internal__QByteArray_STORE)
{
	dXSARGS;
	if (items != 2)
	Perl_croak(aTHX_ "Usage: Qt::_internal::QByteArray::STORE(obj, what)");
	{
		SV*	obj = ST(0);
		SV*	what = ST(1);
		if (!SvROK(obj))
			croak("?");
		IV tmp = SvIV((SV*)SvRV(obj));
		QByteArray *s = (QByteArray*) tmp;
		
		if(SvOK(what)) {
			STRLEN len;
			char* tmp2 = SvPV(what, len); 
			s->resize(len);
			Copy((void*)tmp2, (void*)s->data(), len, char);
		}  else
			s->truncate(0);
	}
	XSRETURN_EMPTY;
}

XS(XS_Qt___internal__QByteArray_DESTROY)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Qt::_internal::QByteArray::DESTROY(obj)");
	{
		SV*	obj = ST(0);
		if (!SvROK(obj))
			croak("?");
		IV tmp = SvIV((SV*)SvRV(obj));
		QByteArray *s = (QByteArray*) tmp;
		delete s;
	}
	XSRETURN_EMPTY;
}

XS(XS_Qt___internal__QRgbStar_FETCH)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Qt::_internal::QRgbStar::FETCH(obj)");
	{
		SV*	obj = ST(0);
		SV *	RETVAL;
		if (!SvROK(obj))
			croak("?");
		IV tmp = SvIV((SV*)SvRV(obj));
		QRgb *s = (QRgb*) tmp;
		AV* ar = newAV();
		RETVAL = newRV_noinc((SV*)ar);
		for(int i=0; s[i] ; i++)
		{
			SV *item = newSViv((IV)s[i]);
			if(!av_store(ar, (I32)i, item))
				SvREFCNT_dec( item );
		}
		ST(0) = RETVAL;
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}

XS(XS_Qt___internal__QRgbStar_STORE)
{
	dXSARGS;
	if (items != 2)
	Perl_croak(aTHX_ "Usage: Qt::_internal::QRgbStar::STORE(obj, sv)");
	{
		SV*	obj = ST(0);
		SV*	sv = ST(1);
		if (!SvROK(obj))
			croak("?");
		IV tmp = SvIV((SV*)SvRV(obj));
		QRgb *s = (QRgb*) tmp;
		if(!SvROK(sv) || SvTYPE(SvRV(sv)) != SVt_PVAV || av_len((AV*)SvRV(sv)) < 0) {
			s = new QRgb[1];
			s[0] = 0; 
			sv_setref_pv(obj, "Qt::_internal::QRgbStar", (void*)s);
			return;
		}
		AV *list = (AV*)SvRV(sv);
		int count = av_len(list);
		s = new QRgb[count + 2];
		int i;
		for(i = 0; i <= count; i++) {
			SV **item = av_fetch(list, i, 0);
			if(!item || !SvOK(*item)) {
				s[i] = 0;
				continue;
			}
			s[i] = SvIV(*item);
		}
		s[i] = 0;
		sv_setref_pv(obj, "Qt::_internal::QRgbStar", (void*)s); 
	}
	XSRETURN_EMPTY;
}

XS(XS_Qt___internal__QRgbStar_DESTROY)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Qt::_internal::QRgbStar::DESTROY(obj)");
	{
		SV*	obj = ST(0);
		if (!SvROK(obj))
			croak("?");
		IV tmp = SvIV((SV*)SvRV(obj));
		QRgb *s = (QRgb*) tmp;
		delete[] s;
	}
	XSRETURN_EMPTY;
}

XS(XS_Qt___internal_getMethStat)
{
    dXSARGS;
    if (items != 0)
		Perl_croak(aTHX_ "Usage: Qt::_internal::getMethStat()");
	SP -= items;
	{
		XPUSHs(sv_2mortal(newSViv((int)methcache->size())));
		XPUSHs(sv_2mortal(newSViv((int)methcache->count())));
		PUTBACK;
		return;
    }
}

XS(XS_Qt___internal_getClassStat)
{
	dXSARGS;
	if (items != 0)
		Perl_croak(aTHX_ "Usage: Qt::_internal::getClassStat()");
	SP -= items;
	{
		XPUSHs(sv_2mortal(newSViv((int)classcache->size())));
		XPUSHs(sv_2mortal(newSViv((int)classcache->count())));
		PUTBACK;
		return;
    }
}

XS(XS_Qt___internal_getIsa)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Qt::_internal::getIsa(classId)");
	SP -= items;
	{
		int	classId = (int)SvIV(ST(0));
		Smoke::Index *parents =
		qt_Smoke->inheritanceList +
		qt_Smoke->classes[classId].parents;
		while(*parents)
			XPUSHs(sv_2mortal(newSVpv(qt_Smoke->classes[*parents++].className, 0)));
		PUTBACK;
		return;
	}
}

XS(XS_Qt___internal_dontRecurse)
{
	dXSARGS;
	if (items != 0)
		Perl_croak(aTHX_ "Usage: Qt::_internal::dontRecurse()");
	{
		avoid_fetchmethod = true;
	}
	XSRETURN_EMPTY;
}

XS(XS_Qt___internal_sv_to_ptr)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Qt::_internal::sv_to_ptr(sv)");
	{
		SV*	sv = ST(0);
		void *	RETVAL;
		dXSTARG;
		
		RETVAL = sv_to_ptr(sv);
		XSprePUSH; PUSHi(PTR2IV(RETVAL));
	}
	XSRETURN(1);
}

XS(XS_Qt___internal_setDebug)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Qt::_internal::setDebug(on)");
	{
		int	on = (int)SvIV(ST(0));
		do_debug = on;
	}
	XSRETURN_EMPTY;
}

XS(XS_Qt___internal_debug)
{
	dXSARGS;
	if (items != 0)
		Perl_croak(aTHX_ "Usage: Qt::_internal::debug()");
	{
		int	RETVAL;
		dXSTARG;
		RETVAL = do_debug;
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}

XS(XS_Qt___internal_getTypeNameOfArg)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Qt::_internal::getTypeNameOfArg(method, idx)");
	{
		int	method = (int)SvIV(ST(0));
		int	idx = (int)SvIV(ST(1));
		char *	RETVAL;
		dXSTARG;
		Smoke::Method &m = qt_Smoke->methods[method];
		Smoke::Index *args = qt_Smoke->argumentList + m.args;
		RETVAL = (char*)qt_Smoke->types[args[idx]].name;
		sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
	}
	XSRETURN(1);
}

XS(XS_Qt___internal_classIsa)
{
	dXSARGS;
	if (items != 2)
	Perl_croak(aTHX_ "Usage: Qt::_internal::classIsa(className, base)");
	{
		char *	className = (char *)SvPV(ST(0),PL_na);
		char *	base = (char *)SvPV(ST(1),PL_na);
		int	RETVAL;
		dXSTARG;
		RETVAL = isDerivedFrom(qt_Smoke, className, base, 0);
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}

XS(XS_Qt___internal_insert_pclassid)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Qt::_internal::insert_pclassid(p, ix)");
	{
		char *	p = (char *)SvPV(ST(0),PL_na);
		int	ix = (int)SvIV(ST(1));
		classcache->insert(p, new Smoke::Index((Smoke::Index)ix));
	}
	XSRETURN_EMPTY;
}

XS(XS_Qt___internal_find_pclassid)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Qt::_internal::find_pclassid(p)");
	{
		char *	p = (char *)SvPV(ST(0),PL_na);
		int	RETVAL;
		dXSTARG;
		Smoke::Index *r = classcache->value(p);
		if(r)
			RETVAL = (int)*r;
		else
			RETVAL = 0;
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}

XS(XS_Qt___internal_insert_mcid)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Qt::_internal::insert_mcid(mcid, ix)");
	{
		char *	mcid = (char *)SvPV(ST(0),PL_na);
		int	ix = (int)SvIV(ST(1));
		methcache->insert(mcid, new Smoke::Index((Smoke::Index)ix));
	}
	XSRETURN_EMPTY;
}

XS(XS_Qt___internal_find_mcid)
{
	dXSARGS;
	if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::find_mcid(mcid)");
	{
		char *	mcid = (char *)SvPV(ST(0),PL_na);
		int	RETVAL;
		dXSTARG;
		Smoke::Index *r = methcache->value(mcid);
		if(r)
			RETVAL = (int)*r;
		else
			RETVAL = 0;
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}

XS(XS_Qt___internal_getSVt)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Qt::_internal::getSVt(sv)");
	{
		SV *	sv = ST(0);
		char *	RETVAL;
		dXSTARG;
		RETVAL=get_SVt(sv);
		sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
	}
	XSRETURN(1);
}

XS(XS_Qt___internal_dumpObjects)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Qt::_internal::dumpObjects()");
    {
    hv_iterinit(pointer_map);
    HE *e;
    while(e = hv_iternext(pointer_map)) {
	STRLEN len;
	SV *sv = HeVAL(e);
	printf("key = %s, refcnt = %d, weak = %d, ref? %d\n", HePV(e, len), SvREFCNT(sv), SvWEAKREF(sv), SvROK(sv)?1:0);
	if(SvRV(sv))
	    printf("REFCNT = %d\n", SvREFCNT(SvRV(sv)));
	//SvREFCNT_dec(HeVAL(e));
	//HeVAL(e) = &PL_sv_undef;
    }
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_dangle)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::dangle(obj)");
    {
		SV *	obj = ST(0);
		if(SvRV(obj))
			SvREFCNT_inc(SvRV(obj));
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_setAllocated)
{
    dXSARGS;
    if (items != 2)
		Perl_croak(aTHX_ "Usage: Qt::_internal::setAllocated(obj, b)");
    {
	SV *	obj = ST(0);
	bool	b = (int)SvIV(ST(1));
    smokeperl_object *o = sv_obj_info(obj);
    if(o)
		o->allocated = b;
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_setqapp)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::setqapp(obj)");
    {
	SV *	obj = ST(0);
    if(!obj || !SvROK(obj))
        croak("Invalid Qt::Application object. Couldn't set Qt::app()\n");
    sv_qapp = SvRV(obj);
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_setThis)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::setThis(obj)");
    {
	SV *	obj = ST(0);
    sv_setsv_mg(sv_this, obj);
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_deleteObject)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::deleteObject(obj)");
    {
	SV *	obj = ST(0);
    smokeperl_object *o = sv_obj_info(obj);
    if(!o) { XSRETURN_EMPTY; }
    QObject *qobj = (QObject*)o->smoke->cast(o->ptr, o->classId, o->smoke->idClass("QObject"));
    delete qobj;
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_mapObject)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::mapObject(obj)");
    {
	SV *	obj = ST(0);
    smokeperl_object *o = sv_obj_info(obj);
    if(!o)
        XSRETURN_EMPTY;
    SmokeClass c( o->smoke, o->classId );
    if(!c.hasVirtual() ) {
	XSRETURN_EMPTY;
   }
    mapPointer(obj, o, pointer_map, o->classId, 0);
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_isQObject)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::isQObject(obj)");
    {
	SV *	obj = ST(0);
	bool	RETVAL;
    RETVAL = 0;
    smokeperl_object *o = sv_obj_info(obj);
    if(o && isQObject(o->smoke, o->classId))
	RETVAL = 1;
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt___internal_isValidAllocatedPointer)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::isValidAllocatedPointer(obj)");
    {
	SV *	obj = ST(0);
	bool	RETVAL;
    RETVAL = 0;
    smokeperl_object *o = sv_obj_info(obj);
    if(o && o->ptr && o->allocated)
	RETVAL = 1;
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt___internal_findAllocatedObjectFor)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::findAllocatedObjectFor(obj)");
    {
	SV *	obj = ST(0);
	SV *	RETVAL;
    RETVAL = &PL_sv_undef;
    smokeperl_object *o = sv_obj_info(obj);
    SV *ret;
    if(o && o->ptr && (ret = getPointerObject(o->ptr)))
        RETVAL = ret;
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt___internal_getGV)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::getGV(cv)");
    {
	SV *	cv = ST(0);
	SV *	RETVAL;
    RETVAL = (SvROK(cv) && (SvTYPE(SvRV(cv))==SVt_PVCV) ?
              SvREFCNT_inc(CvGV((CV*)SvRV(cv))) : &PL_sv_undef);
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt___internal_idClass)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::idClass(name)");
    {
	char *	name = (char *)SvPV(ST(0),PL_na);
	int	RETVAL;
	dXSTARG;
    RETVAL = qt_Smoke->idClass(name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Qt___internal_idMethodName)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Qt::_internal::idMethodName(name)");
	{
		char *	name = (char *)SvPV(ST(0),PL_na);
		int	RETVAL;
		dXSTARG;
		RETVAL = qt_Smoke->idMethodName(name);
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}

XS(XS_Qt___internal_idMethod)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Qt::_internal::idMethod(idclass, idmethodname)");
	{
		int	idclass = (int)SvIV(ST(0));
		int	idmethodname = (int)SvIV(ST(1));
		int	RETVAL;
		dXSTARG;
		RETVAL = qt_Smoke->idMethod(idclass, idmethodname);
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}

XS(XS_Qt___internal_findMethod)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Qt::_internal::findMethod(c, name)");
    SP -= items;
    {
	char *	c = (char *)SvPV(ST(0),PL_na);
	char *	name = (char *)SvPV(ST(1),PL_na);
    Smoke::Index meth = qt_Smoke->findMethod(c, name);
//    printf("DAMNIT on %s::%s => %d\n", c, name, meth);
    if(!meth) {
	// empty list
    } else if(meth > 0) {
	Smoke::Index i = qt_Smoke->methodMaps[meth].method;
	if(!i) {		// shouldn't happen
	    croak("Corrupt method %s::%s", c, name);
	} else if(i > 0) {	// single match
	    PUSHs(sv_2mortal(newSViv(
		(IV)qt_Smoke->methodMaps[meth].method
	    )));
	} else {		// multiple match
	    i = -i;		// turn into ambiguousMethodList index
	    while(qt_Smoke->ambiguousMethodList[i]) {
		PUSHs(sv_2mortal(newSViv(
		    (IV)qt_Smoke->ambiguousMethodList[i]
		)));
		i++;
	    }
	}
    }
	PUTBACK;
	return;
    }
}

XS(XS_Qt___internal_findMethodFromIds)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Qt::_internal::findMethodFromIds(idclass, idmethodname)");
    SP -= items;
    {
	int	idclass = (int)SvIV(ST(0));
	int	idmethodname = (int)SvIV(ST(1));
    Smoke::Index meth = qt_Smoke->findMethod(idclass, idmethodname);
    if(!meth) {
	// empty list
    } else if(meth > 0) {
	Smoke::Index i = qt_Smoke->methodMaps[meth].method;
	if(i >= 0) {	// single match
	    PUSHs(sv_2mortal(newSViv((IV)i)));
	} else {		// multiple match
	    i = -i;		// turn into ambiguousMethodList index
	    while(qt_Smoke->ambiguousMethodList[i]) {
		PUSHs(sv_2mortal(newSViv(
		    (IV)qt_Smoke->ambiguousMethodList[i]
		)));
		i++;
	    }
	}
    }
	PUTBACK;
	return;
    }
}

XS(XS_Qt___internal_findAllMethods)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::findAllMethods(classid, ...)");
    {
	SV*	classid = ST(0);
	HV *	RETVAL;
    RETVAL=newHV();
    if(SvIOK(classid)) {
        Smoke::Index c = (Smoke::Index) SvIV(classid);
        char * pat = 0L;
        if(items > 1 && SvPOK(ST(1)))
            pat = SvPV_nolen(ST(1));
        Smoke::Index imax = qt_Smoke->numMethodMaps;
        Smoke::Index imin = 0, icur = -1, methmin = 0, methmax = 0;
        int icmp = -1;
        while(imax >= imin) {
            icur = (imin + imax) / 2;
            icmp = qt_Smoke->leg(qt_Smoke->methodMaps[icur].classId, c);
            if(!icmp) {
                Smoke::Index pos = icur;
                while(icur && qt_Smoke->methodMaps[icur-1].classId == c)
                    icur --;
                methmin = icur;
                icur = pos;
                while(icur < imax && qt_Smoke->methodMaps[icur+1].classId == c)
                    icur ++;
                methmax = icur;
                break;
            }
            if (icmp > 0)
		imax = icur - 1;
	    else
		imin = icur + 1;
        }
        if(!icmp) {
            for(Smoke::Index i=methmin ; i <= methmax ; i++) {
                Smoke::Index m = qt_Smoke->methodMaps[i].name;
                if(!pat || !strncmp(qt_Smoke->methodNames[m], pat, strlen(pat))) {
                    Smoke::Index ix= qt_Smoke->methodMaps[i].method;
                    AV* meths = newAV();
                    if(ix >= 0) {	// single match
                        av_push(meths, newSViv((IV)ix));
                    } else {		// multiple match
                        ix = -ix;		// turn into ambiguousMethodList index
                        while(qt_Smoke->ambiguousMethodList[ix]) {
                          av_push(meths, newSViv((IV)qt_Smoke->ambiguousMethodList[ix]));
                          ix++;
                        }
                    }
                    hv_store(RETVAL, qt_Smoke->methodNames[m],strlen(qt_Smoke->methodNames[m]),newRV_inc((SV*)meths),0);
                }
            }
        }
    }
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt___internal_dumpCandidates)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::dumpCandidates(rmeths)");
    {
	SV *	rmeths = ST(0);
	SV *	RETVAL;
    if(SvROK(rmeths) && SvTYPE(SvRV(rmeths)) == SVt_PVAV) {
        AV *methods = (AV*)SvRV(rmeths);
        SV *errmsg = newSVpvf("");
        for(int i = 0; i <= av_len(methods); i++) {
                sv_catpv(errmsg, "\t");
                IV id = SvIV(*(av_fetch(methods, i, 0)));
                Smoke::Method &meth = qt_Smoke->methods[id];
                const char *tname = qt_Smoke->types[meth.ret].name;
                if(meth.flags & Smoke::mf_static) sv_catpv(errmsg, "static ");
                sv_catpvf(errmsg, "%s ", (tname ? tname:"void"));
                sv_catpvf(errmsg, "%s::%s(", qt_Smoke->classes[meth.classId].className, qt_Smoke->methodNames[meth.name]);
                for(int i = 0; i < meth.numArgs; i++) {
                        if(i) sv_catpv(errmsg, ", ");
                        tname = qt_Smoke->types[qt_Smoke->argumentList[meth.args+i]].name;
                        sv_catpv(errmsg, (tname ? tname:"void"));
                }
                sv_catpv(errmsg, ")");
                if(meth.flags & Smoke::mf_const) sv_catpv(errmsg, " const");
                sv_catpv(errmsg, "\n");
        }
        RETVAL=errmsg;
    }
    else
        RETVAL=newSVpvf("");
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt___internal_catArguments)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::catArguments(r_args)");
    {
	SV*	r_args = ST(0);
	SV *	RETVAL;
    RETVAL=newSVpvf("");
    if(SvROK(r_args) && SvTYPE(SvRV(r_args)) == SVt_PVAV) {
        AV* args=(AV*)SvRV(r_args);
        for(int i = 0; i <= av_len(args); i++) {
            SV **arg=av_fetch(args, i, 0);
	    if(i) sv_catpv(RETVAL, ", ");
	    if(!arg || !SvOK(*arg)) {
		sv_catpv(RETVAL, "undef");
	    } else if(SvROK(*arg)) {
		smokeperl_object *o = sv_obj_info(*arg);
		if(o)
		    sv_catpv(RETVAL, o->smoke->className(o->classId));
		else
		    sv_catsv(RETVAL, *arg);
	    } else {
		bool isString = SvPOK(*arg);
		STRLEN len;
		char *s = SvPV(*arg, len);
		if(isString) sv_catpv(RETVAL, "'");
		sv_catpvn(RETVAL, s, len > 10 ? 10 : len);
		if(len > 10) sv_catpv(RETVAL, "...");
		if(isString) sv_catpv(RETVAL, "'");
	    }
	}
    }
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt___internal_callMethod)
{
    dXSARGS;
    SP -= items;
    {
		SV *	RETVAL;
		if(_current_method) {
			MethodCall c(qt_Smoke, _current_method, &ST(0), items);
			c.next();
			SV *ret = c.var();
			SvREFCNT_inc(ret);
			PUSHs(sv_2mortal(ret));
		} else
			PUSHs(sv_newmortal());
		PUTBACK;
		return;
    }
}

XS(XS_Qt___internal_isObject)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::isObject(obj)");
    {
	SV *	obj = ST(0);
	bool	RETVAL;
    RETVAL = sv_to_ptr(obj) ? TRUE : FALSE;
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt___internal_setCurrentMethod)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::setCurrentMethod(meth)");
    {
	int	meth = (int)SvIV(ST(0));
    // FIXME: damn, this is lame, and it doesn't handle ambiguous methods
    _current_method = meth;  //qt_Smoke->methodMaps[meth].method;
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_getClassList)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Qt::_internal::getClassList()");
    {
	SV *	RETVAL;
    AV *av = newAV();
    for(int i = 1; i <= qt_Smoke->numClasses; i++) {
//printf("%s => %d\n", qt_Smoke->classes[i].className, i);

	if( qt_Smoke->classes[i].className )
		av_push(av, newSVpv(qt_Smoke->classes[i].className, 0));
//	hv_store(hv, qt_Smoke->classes[i].className, 0, newSViv(i), 0);
    }
    RETVAL = newRV((SV*)av);
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt___internal_installthis)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::installthis(package)");
    {
	char *	package = (char *)SvPV(ST(0),PL_na);
    if(!package) XSRETURN_EMPTY;
    char *name = new char[strlen(package) + 7];
    char *file = __FILE__;
    strcpy(name, package);
    strcat(name, "::this");
    // *{ $name } = sub () : lvalue;
    CV *thissub = newXS(name, XS_this, file);
    sv_setpv((SV*)thissub, "");    // sub this () : lvalue;
    delete[] name;
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_installattribute)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Qt::_internal::installattribute(package, name)");
    {
	char *	package = (char *)SvPV(ST(0),PL_na);
	char *	name = (char *)SvPV(ST(1),PL_na);
    if(!package || !name) XSRETURN_EMPTY;
    char *attr = new char[strlen(package) + strlen(name) + 3];
    sprintf(attr, "%s::%s", package, name);
    char *file = __FILE__;
    // *{ $attr } = sub () : lvalue;
    CV *attrsub = newXS(attr, XS_attr, file);
    sv_setpv((SV*)attrsub, "");
    CvLVALUE_on(attrsub);
    CvNODEBUG_on(attrsub);
    delete[] attr;
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_installsuper)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::installsuper(package)");
    {
	char *	package = (char *)SvPV(ST(0),PL_na);
    if(!package) XSRETURN_EMPTY;
    char *attr = new char[strlen(package) + 8];
    sprintf(attr, "%s::SUPER", package);
    char *file = __FILE__;
    CV *attrsub = newXS(attr, XS_super, file);
    sv_setpv((SV*)attrsub, "");
    delete[] attr;
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt___internal_installautoload)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Qt::_internal::installautoload(package)");
    {
	char *	package = (char *)SvPV(ST(0),PL_na);
    if(!package) XSRETURN_EMPTY;
    char *autoload = new char[strlen(package) + 11];
    strcpy(autoload, package);
    strcat(autoload, "::_UTOLOAD");
    char *file = __FILE__;
    // *{ $package."::AUTOLOAD" } = XS_AUTOLOAD
    newXS(autoload, XS_AUTOLOAD, file);
    delete[] autoload;
    }
    XSRETURN_EMPTY;
}

XS(XS_Qt_this)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Qt::this()");
    {
	SV *	RETVAL;
    RETVAL = newSVsv(sv_this);
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt_app)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Qt::app()");
    {
		SV *	RETVAL;
		if( !sv_qapp ) {
			RETVAL = newSV(0);
			sv_setsv_mg(RETVAL, &PL_sv_undef);
		} else {
			RETVAL = newRV_inc(sv_qapp);
		}
		ST(0) = RETVAL;
		sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt_version)
{
    dXSARGS;
    if (items != 0)
		Perl_croak(aTHX_ "Usage: Qt::version()");
    {
		SV *	RETVAL;
		RETVAL = newSVpv(QT_VERSION_STR,0);
		ST(0) = RETVAL;
		sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Qt_RecordList_perl_array)
{
	dXSARGS;
	if( items != 1 )
		Perl_croak(aTHX_ "Usage RecordList->perl_array();");
	{
		SV * obj = ST(0);
		smokeperl_object *o = sv_obj_info(obj);
		RecordList * rlp = 0;
		if( o ) {
			void * p = o->ptr;
//			printf( "XS_Qt_RecordList_perl_array: Class type: %s, Pointer: %p\n", o->smoke->className(o->classId), p );
			rlp = (RecordList*)o->smoke->cast(p,o->classId,o->smoke->idClass("RecordList"));
		}

		AV * av = newAV();
		SV * RETVAL = newRV_noinc((SV*)av);
		if( rlp ) {
//			warn( "RecordList->perl_array has %i items\n", rlp->size() );
			for( RecordIter it = rlp->begin(); it != rlp->end(); ++it ) {
				Record r( *it );
				Table * table( r.table() );
				SV *ret = newSV(0);
				HV *hv = newHV();
				SV *obj = newRV_noinc((SV*)hv);
				smokeperl_object no;
				no.smoke = o->smoke;
				QString classname = table->tableName();
				QByteArray ba = classname.toLatin1();
				const char * tn = ba.constData();
				int id = o->smoke->idClass(tn);
				if( id == 0 ) {
					qWarning() << "Failed to Id class " << table->tableName() << ", trying Record\n";
					tn = "Record";
					id = o->smoke->idClass(tn);
				}
				no.classId = id;
				no.ptr = table->schema()->createObject( r ); //new Record( *it );
				no.allocated = true;
				char * cn = new char[strlen(tn)+14];
				strncpy(cn, "Blur::Model::", 13);
				strcpy(cn+13, tn);
				HV * stash = gv_stashpv( cn, TRUE );
				sv_bless(obj, stash);
				delete [] cn;
				sv_magic((SV*)hv, sv_qapp, '~', (char*)&no, sizeof(no));
				MAGIC *mg = mg_find((SV*)hv, '~');
				mg->mg_virtual = &vtbl_smoke;
				sv_setsv_mg(ret, obj);
				av_push(av,ret);
				SvREFCNT_dec(obj);
			}
		}
		ST(0) = RETVAL;
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}

XS(XS_Qt_SqlQuery_fieldName)
{
	dXSARGS;
	if( items != 2 )
		Perl_croak(aTHX_ "Usage: Qt::SqlQuery->fieldName( int );");
	{
		SV * obj = ST(0);
		smokeperl_object * o = sv_obj_info(obj);
		SV * RETVAL=0;
		
		if( o ) {
			QSqlQuery * q = (QSqlQuery*)o->ptr;
			QString ret = q->record().fieldName( SvIV( ST(1) ) );
			COP *cop = cxstack[cxstack_ix].blk_oldcop;
			if(!(cop->op_private & HINT_BYTES))
			{
				RETVAL = newSVpv((const char *)ret.toUtf8(),0);
				SvUTF8_on(RETVAL);
			}
			else if(cop->op_private & HINT_LOCALE)
				RETVAL = newSVpv((const char *)ret.toLocal8Bit(),0);
			else
				RETVAL = newSVpv((const char *)ret.toLatin1(),0);
			ST(0) = RETVAL;
			sv_2mortal(ST(0));
		} else
			XSRETURN(0);
		
	}
	XSRETURN(1);
}


XS(XS_Qt_SqlQuery_fieldCount)
{
	dXSARGS;
	if( items != 1 )
		Perl_croak(aTHX_ "Usage: Qt::SqlQuery->fieldCount();");
	{
		SV * obj = ST(0);
		smokeperl_object * o = sv_obj_info(obj);
		SV * RETVAL=0;
		
		if( o ) {
			QSqlQuery * q = (QSqlQuery*)o->ptr;
			RETVAL = newSViv( q->record().count() );
			ST(0) = RETVAL;
			sv_2mortal(ST(0));
		} else
			XSRETURN(0);
		
	}
	XSRETURN(1);
}

extern void classes_loader();

#ifdef __cplusplus
extern "C"
#endif
#ifdef Q_OS_WIN
__declspec(dllexport)
#endif
 XS(boot_Qt)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

	newXS("Qt::_internal::QString::FETCH", XS_Qt___internal__QString_FETCH, file);
	newXS("Qt::_internal::QString::STORE", XS_Qt___internal__QString_STORE, file);
	newXS("Qt::_internal::QString::DESTROY", XS_Qt___internal__QString_DESTROY, file);
	newXS("Qt::_internal::QByteArray::FETCH", XS_Qt___internal__QByteArray_FETCH, file);
	newXS("Qt::_internal::QByteArray::STORE", XS_Qt___internal__QByteArray_STORE, file);
	newXS("Qt::_internal::QByteArray::DESTROY", XS_Qt___internal__QByteArray_DESTROY, file);
	newXS("Qt::_internal::QRgbStar::FETCH", XS_Qt___internal__QRgbStar_FETCH, file);
	newXS("Qt::_internal::QRgbStar::STORE", XS_Qt___internal__QRgbStar_STORE, file);
	newXS("Qt::_internal::QRgbStar::DESTROY", XS_Qt___internal__QRgbStar_DESTROY, file);
	newXS("Qt::_internal::getMethStat", XS_Qt___internal_getMethStat, file);
	newXS("Qt::_internal::getClassStat", XS_Qt___internal_getClassStat, file);
	newXS("Qt::_internal::getIsa", XS_Qt___internal_getIsa, file);
	newXS("Qt::_internal::dontRecurse", XS_Qt___internal_dontRecurse, file);
	newXS("Qt::_internal::sv_to_ptr", XS_Qt___internal_sv_to_ptr, file);
	newXS("Qt::_internal::setDebug", XS_Qt___internal_setDebug, file);
	newXS("Qt::_internal::debug", XS_Qt___internal_debug, file);
	newXS("Qt::_internal::getTypeNameOfArg", XS_Qt___internal_getTypeNameOfArg, file);
	newXS("Qt::_internal::classIsa", XS_Qt___internal_classIsa, file);
	newXS("Qt::_internal::insert_pclassid", XS_Qt___internal_insert_pclassid, file);
	newXS("Qt::_internal::find_pclassid", XS_Qt___internal_find_pclassid, file);
	newXS("Qt::_internal::insert_mcid", XS_Qt___internal_insert_mcid, file);
	newXS("Qt::_internal::find_mcid", XS_Qt___internal_find_mcid, file);
	newXS("Qt::_internal::getSVt", XS_Qt___internal_getSVt, file);
	newXS("Qt::_internal::dumpObjects", XS_Qt___internal_dumpObjects, file);
	newXS("Qt::_internal::dangle", XS_Qt___internal_dangle, file);
	newXS("Qt::_internal::setAllocated", XS_Qt___internal_setAllocated, file);
	newXS("Qt::_internal::setqapp", XS_Qt___internal_setqapp, file);
	newXS("Qt::_internal::setThis", XS_Qt___internal_setThis, file);
	newXS("Qt::_internal::deleteObject", XS_Qt___internal_deleteObject, file);
	newXS("Qt::_internal::mapObject", XS_Qt___internal_mapObject, file);
	newXS("Qt::_internal::isQObject", XS_Qt___internal_isQObject, file);
	newXS("Qt::_internal::isValidAllocatedPointer", XS_Qt___internal_isValidAllocatedPointer, file);
	newXS("Qt::_internal::findAllocatedObjectFor", XS_Qt___internal_findAllocatedObjectFor, file);
	newXS("Qt::_internal::getGV", XS_Qt___internal_getGV, file);
	newXS("Qt::_internal::idClass", XS_Qt___internal_idClass, file);
	newXS("Qt::_internal::idMethodName", XS_Qt___internal_idMethodName, file);
	newXS("Qt::_internal::idMethod", XS_Qt___internal_idMethod, file);
	newXS("Qt::_internal::findMethod", XS_Qt___internal_findMethod, file);
	newXS("Qt::_internal::findMethodFromIds", XS_Qt___internal_findMethodFromIds, file);
	newXS("Qt::_internal::findAllMethods", XS_Qt___internal_findAllMethods, file);
	newXS("Qt::_internal::dumpCandidates", XS_Qt___internal_dumpCandidates, file);
	newXS("Qt::_internal::catArguments", XS_Qt___internal_catArguments, file);
	newXS("Qt::_internal::callMethod", XS_Qt___internal_callMethod, file);
	newXS("Qt::_internal::isObject", XS_Qt___internal_isObject, file);
	newXS("Qt::_internal::setCurrentMethod", XS_Qt___internal_setCurrentMethod, file);
	newXS("Qt::_internal::getClassList", XS_Qt___internal_getClassList, file);
	newXS("Qt::_internal::installthis", XS_Qt___internal_installthis, file);
	newXS("Qt::_internal::installattribute", XS_Qt___internal_installattribute, file);
	newXS("Qt::_internal::installsuper", XS_Qt___internal_installsuper, file);
	newXS("Qt::_internal::installautoload", XS_Qt___internal_installautoload, file);
	newXS("Qt::_internal::signal", XS_Qt___internal_signal, file);
	newXS("Qt::this", XS_Qt_this, file);
	newXS("Qt::app", XS_Qt_app, file);
	newXS("Qt::version", XS_Qt_version, file);
	newXS("Blur::Model::RecordList::perl_array", XS_Qt_RecordList_perl_array, file);
	newXS("Qt::SqlQuery::fieldName", XS_Qt_SqlQuery_fieldName, file);
	newXS("Qt::SqlQuery::fieldCount", XS_Qt_SqlQuery_fieldCount, file);
    /* Initialisation Section */

    init_qt_Smoke();
    qt_Smoke->binding = new QtSmokeBinding(qt_Smoke);
    install_handlers(Qt_handlers);
    pointer_map = newHV();
    sv_this = newSV(0);
    methcache = new QHash<QByteArray,Smoke::Index*>();
    classcache = new QHash<QByteArray,Smoke::Index*>();

    /* End of Initialisation Section */

    XSRETURN_YES;
}

