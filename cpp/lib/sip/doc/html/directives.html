<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Directives &mdash; SIP 4.16.7 Reference Guide</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '4.16.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/logo_tn.ico"/>
    <link rel="top" title="SIP 4.16.7 Reference Guide" href="index.html" />
    <link rel="next" title="Annotations" href="annotations.html" />
    <link rel="prev" title="SIP Specification Files" href="specification_files.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="annotations.html" title="Annotations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="specification_files.html" title="SIP Specification Files"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SIP 4.16.7 Reference Guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="directives">
<h1>Directives<a class="headerlink" href="#directives" title="Permalink to this headline">¶</a></h1>
<p>In this section we describe each of the directives that can be used in
specification files.  All directives begin with <code class="docutils literal"><span class="pre">%</span></code> as the first
non-whitespace character in a line.</p>
<p>Some directives have arguments or contain blocks of code or documentation.  In
the following descriptions these are shown in <em>italics</em>.  Optional arguments
are enclosed in [<em>brackets</em>].</p>
<p>Some directives are used to specify handwritten code.  Handwritten code must
not define names that start with the prefix <code class="docutils literal"><span class="pre">sip</span></code>.</p>
<div class="section" id="revised-directive-syntax">
<h2>Revised Directive Syntax<a class="headerlink" href="#revised-directive-syntax" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.12.</span></p>
</div>
<p>The directive syntax used in older versions has some problems:</p>
<ul class="simple">
<li>it is inconsistent in places</li>
<li>it can be problematic to parse</li>
<li>it is inflexible.</li>
</ul>
<p>SIP v4.12 introduced a revised directive syntax that addresses these problems
and deprecates the old syntax.  Support for the old syntax will be removed in
SIP v5.</p>
<p>The revised syntax is:</p>
<div class="highlight-python"><div class="highlight"><pre>%Directive(arg = value, ...)
{
    %Sub-directive
    ...
};
</pre></div>
</div>
<p>A directive may have a number of arguments enclosed in parentheses followed by
a number of sub-directives enclosed in braces.  Individual arguments and
sub-directives may be optional.</p>
<p>Arguments may be specified in any order.  If no arguments are specified then
the parentheses can be omitted.  If a directive has only one compulsory
argument then its value may be specified after the directive name and instead
of the parentheses.</p>
<p>Sub-directives may be specified in any order.  If no sub-directives are
specified then the braces can be omitted.</p>
<p>If a directive is used to specify handwritten code then it may not have
sub-directives.  In this case the syntax is:</p>
<pre class="literal-block">
%Directive(arg = value, ...)
    <em>code</em>
%End
</pre>
<p>Ordinary C/C++ statements may also have sub-directives.  These will also be
enclosed in braces.</p>
<p>The documentation for each directive describes the revised syntax.  The older
syntax should be used if compatibility with versions of SIP prior to v4.12 is
required.</p>
</div>
<div class="section" id="list-of-directives">
<h2>List of Directives<a class="headerlink" href="#list-of-directives" title="Permalink to this headline">¶</a></h2>
<dl class="directive">
<dt id="directive-%AccessCode">
<code class="descname">%AccessCode</code><a class="headerlink" href="#directive-%AccessCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%AccessCode
    <em>code</em>
%End
</pre>
<p>This sub-directive is used in the declaration of an instance of a wrapped class
or structure, or a pointer to such an instance.  You use it to provide
handwritten code that overrides the default behaviour.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>class Klass;

Klass *klassInstance
{
    %AccessCode
        // In this contrived example the C++ library we are wrapping
        // defines klassInstance as Klass ** (which SIP doesn&#39;t support) so
        // we explicitly dereference it.
        if (klassInstance &amp;&amp; *klassInstance)
            return *klassInstance;

        // This will get converted to None.
        return 0;
    %End
};
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#directive-%GetCode"><code class="xref std std-directive docutils literal"><span class="pre">%GetCode</span></code></a>, <a class="reference internal" href="#directive-%SetCode"><code class="xref std std-directive docutils literal"><span class="pre">%SetCode</span></code></a></p>
</div>
<dl class="directive">
<dt id="directive-%API">
<code class="descname">%API</code><a class="headerlink" href="#directive-%API" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.9.</span></p>
</div>
<pre class="literal-block">
%API(name = <em>name</em>, version = <em>integer</em>)
</pre>
<p>This directive is used to define an API and set its default version number.  A
version number must be greater than or equal to 1.</p>
<p>See <a class="reference internal" href="using.html#ref-incompat-apis"><span>Managing Incompatible APIs</span></a> for more detail.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%API(name=PyQt4, version=1)
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%AutoPyName">
<code class="descname">%AutoPyName</code><a class="headerlink" href="#directive-%AutoPyName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.12.</span></p>
</div>
<pre class="literal-block">
%AutoPyName(remove_leading = <em>string</em>)
</pre>
<p>This is a sub-directive of the <a class="reference internal" href="#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a> directive used to specify a
rule for automatically providing Python names for classes, enums, functions,
methods, variables and exceptions.  The directive may be specified any number
of times and each rule will be applied in turn.  Rules will not be applied if
an item has been given an explicit Python name.</p>
<p><code class="docutils literal"><span class="pre">remove_leading</span></code> is a string that will be removed from the beginning of any
C++ or C name.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Module PyQt4.QtCore
{
    %AutoPyName(remove_leading=&quot;Q&quot;)
}
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%BIGetBufferCode">
<code class="descname">%BIGetBufferCode</code><a class="headerlink" href="#directive-%BIGetBufferCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%BIGetBufferCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference internal" href="#directive-%BIReleaseBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIReleaseBufferCode</span></code></a>) is used to
specify code that implements the buffer interface of Python v3.  If Python v2
is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>Py_buffer *sipBuffer</dt>
<dd>This is a pointer to the Python buffer structure that the handwritten code
must populate.</dd>
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>int sipFlags</dt>
<dd>These are the flags that specify what elements of the <code class="docutils literal"><span class="pre">sipBuffer</span></code>
structure must be populated.</dd>
<dt>int sipRes</dt>
<dd>The handwritten code should set this to 0 if there was no error or -1 if
there was an error.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal"><span class="pre">self</span></code>.</dd>
</dl>
<dl class="directive">
<dt id="directive-%BIGetCharBufferCode">
<code class="descname">%BIGetCharBufferCode</code><a class="headerlink" href="#directive-%BIGetCharBufferCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%BIGetCharBufferCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference internal" href="#directive-%BIGetReadBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetReadBufferCode</span></code></a>,
<a class="reference internal" href="#directive-%BIGetSegCountCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetSegCountCode</span></code></a> and <a class="reference internal" href="#directive-%BIGetWriteBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetWriteBufferCode</span></code></a>) is used
to specify code that implements the buffer interface of Python v2.  If Python
v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>void **sipPtrPtr</dt>
<dd>This is the pointer used to return the address of the character buffer.</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal"><span class="pre">SIP_SSIZE_T</span></code></a> sipRes</dt>
<dd>The handwritten code should set this to the length of the character buffer
or -1 if there was an error.</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal"><span class="pre">SIP_SSIZE_T</span></code></a> sipSegment</dt>
<dd>This is the number of the segment of the character buffer.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal"><span class="pre">self</span></code>.</dd>
</dl>
<dl class="directive">
<dt id="directive-%BIGetReadBufferCode">
<code class="descname">%BIGetReadBufferCode</code><a class="headerlink" href="#directive-%BIGetReadBufferCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%BIGetReadBufferCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference internal" href="#directive-%BIGetCharBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetCharBufferCode</span></code></a>,
<a class="reference internal" href="#directive-%BIGetSegCountCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetSegCountCode</span></code></a> and <a class="reference internal" href="#directive-%BIGetWriteBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetWriteBufferCode</span></code></a>) is used
to specify code that implements the buffer interface of Python v2.  If
Python v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>void **sipPtrPtr</dt>
<dd>This is the pointer used to return the address of the read buffer.</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal"><span class="pre">SIP_SSIZE_T</span></code></a> sipRes</dt>
<dd>The handwritten code should set this to the length of the read buffer or
-1 if there was an error.</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal"><span class="pre">SIP_SSIZE_T</span></code></a> sipSegment</dt>
<dd>This is the number of the segment of the read buffer.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal"><span class="pre">self</span></code>.</dd>
</dl>
<dl class="directive">
<dt id="directive-%BIGetSegCountCode">
<code class="descname">%BIGetSegCountCode</code><a class="headerlink" href="#directive-%BIGetSegCountCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%BIGetSegCountCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference internal" href="#directive-%BIGetCharBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetCharBufferCode</span></code></a>,
<a class="reference internal" href="#directive-%BIGetReadBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetReadBufferCode</span></code></a> and <a class="reference internal" href="#directive-%BIGetWriteBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetWriteBufferCode</span></code></a>) is
used to specify code that implements the buffer interface of Python v2.  If
Python v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal"><span class="pre">SIP_SSIZE_T</span></code></a> *sipLenPtr</dt>
<dd>This is the pointer used to return the total length in bytes of all
segments of the buffer.</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal"><span class="pre">SIP_SSIZE_T</span></code></a> sipRes</dt>
<dd>The handwritten code should set this to the number of segments that make
up the buffer.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal"><span class="pre">self</span></code>.</dd>
</dl>
<dl class="directive">
<dt id="directive-%BIGetWriteBufferCode">
<code class="descname">%BIGetWriteBufferCode</code><a class="headerlink" href="#directive-%BIGetWriteBufferCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%BIGetWriteBufferCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference internal" href="#directive-%BIGetCharBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetCharBufferCode</span></code></a>,
<a class="reference internal" href="#directive-%BIGetReadBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetReadBufferCode</span></code></a> and <a class="reference internal" href="#directive-%BIGetSegCountCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetSegCountCode</span></code></a> is used
to specify code that implements the buffer interface of Python v2.  If Python
v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>void **sipPtrPtr</dt>
<dd>This is the pointer used to return the address of the write buffer.</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal"><span class="pre">SIP_SSIZE_T</span></code></a> sipRes</dt>
<dd>The handwritten code should set this to the length of the write buffer or
-1 if there was an error.</dd>
<dt><a class="reference internal" href="c_api.html#c.SIP_SSIZE_T" title="SIP_SSIZE_T"><code class="xref c c-macro docutils literal"><span class="pre">SIP_SSIZE_T</span></code></a> sipSegment</dt>
<dd>This is the number of the segment of the write buffer.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal"><span class="pre">self</span></code>.</dd>
</dl>
<dl class="directive">
<dt id="directive-%BIReleaseBufferCode">
<code class="descname">%BIReleaseBufferCode</code><a class="headerlink" href="#directive-%BIReleaseBufferCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%BIReleaseBufferCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference internal" href="#directive-%BIGetBufferCode"><code class="xref std std-directive docutils literal"><span class="pre">%BIGetBufferCode</span></code></a>) is used to specify
code that implements the buffer interface of Python v3.  If Python v2 is being
used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>Py_buffer *sipBuffer</dt>
<dd>This is a pointer to the Python buffer structure.</dd>
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal"><span class="pre">self</span></code>.</dd>
</dl>
<dl class="directive">
<dt id="directive-%CModule">
<code class="descname">%CModule</code><a class="headerlink" href="#directive-%CModule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 4.12: </span>Use the <a class="reference internal" href="#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a> directive with the <code class="docutils literal"><span class="pre">language</span></code> argument set
to <code class="docutils literal"><span class="pre">&quot;C&quot;</span></code> instead.</p>
</div>
<pre class="literal-block">
%CModule <em>name</em> [<em>version</em>]
</pre>
<p>This directive is used to identify that the library being wrapped is a C
library and to define the name of the module and it&#8217;s optional version number.</p>
<p>See the <a class="reference internal" href="#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a> directive for an explanation of the version
number.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%CModule dbus 1
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%CompositeModule">
<code class="descname">%CompositeModule</code><a class="headerlink" href="#directive-%CompositeModule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%CompositeModule(name = <em>dotted-name</em>)
{
    [<a class="reference internal" href="#directive-%Docstring"><code class="xref std std-directive docutils literal"><span class="pre">%Docstring</span></code></a>]
};
</pre>
<p>A composite module is one that merges a number of related SIP generated
modules.  For example, a module that merges the modules <code class="docutils literal"><span class="pre">a_mod</span></code>, <code class="docutils literal"><span class="pre">b_mod</span></code>
and <code class="docutils literal"><span class="pre">c_mod</span></code> is equivalent to the following pure Python module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">a_mod</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">b_mod</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">c_mod</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Clearly the individual modules should not define module-level objects with the
same name.</p>
<p>This directive is used to specify the name of a composite module.  Any
subsequent <a class="reference internal" href="#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a> directive is interpreted as defining a
component module.</p>
<p>The optional <a class="reference internal" href="#directive-%Docstring"><code class="xref std std-directive docutils literal"><span class="pre">%Docstring</span></code></a> sub-directive is used to specify the
module&#8217;s docstring.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%CompositeModule PyQt4.Qt
%Include QtCore/QtCoremod.sip
%Include QtGui/QtGuimod.sip
</pre></div>
</div>
<p>The main purpose of a composite module is as a programmer convenience as they
don&#8217;t have to remember which individual module an object is defined in.</p>
<dl class="directive">
<dt id="directive-%ConsolidatedModule">
<code class="descname">%ConsolidatedModule</code><a class="headerlink" href="#directive-%ConsolidatedModule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 4.16.2: </span>This will not be supported in SIP v5.</p>
</div>
<pre class="literal-block">
%ConsolidatedModule(name = <em>dotted-name</em>)
{
    [<a class="reference internal" href="#directive-%Docstring"><code class="xref std std-directive docutils literal"><span class="pre">%Docstring</span></code></a>]
};
</pre>
<p>A consolidated module is one that consolidates the wrapper code of a number of
SIP generated modules (refered to as component modules in this context).</p>
<p>This directive is used to specify the name of a consolidated module.  Any
subsequent <a class="reference internal" href="#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a> directive is interpreted as defining a
component module.</p>
<p>The optional <a class="reference internal" href="#directive-%Docstring"><code class="xref std std-directive docutils literal"><span class="pre">%Docstring</span></code></a> sub-directive is used to specify the
module&#8217;s docstring.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%ConsolidatedModule PyQt4._qt
%Include QtCore/QtCoremod.sip
%Include QtGui/QtGuimod.sip
</pre></div>
</div>
<p>A consolidated module is not intended to be explicitly imported by an
application.  Instead it is imported by its component modules when they
themselves are imported.</p>
<p>Normally the wrapper code is contained in the component module and is linked
against the corresponding C or C++ library.  The advantage of a consolidated
module is that it allows all of the wrapped C or C++ libraries to be linked
against a single module.  If the linking is done statically then deployment of
generated modules can be greatly simplified.</p>
<p>It follows that a component module can be built in one of two ways, as a
normal standalone module, or as a component of a consolidated module.  When
building as a component the <code class="docutils literal"><span class="pre">-p</span></code> command line option should be used to
specify the name of the consolidated module.</p>
<dl class="directive">
<dt id="directive-%ConvertFromTypeCode">
<code class="descname">%ConvertFromTypeCode</code><a class="headerlink" href="#directive-%ConvertFromTypeCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%ConvertFromTypeCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the <a class="reference internal" href="#directive-%MappedType"><code class="xref std std-directive docutils literal"><span class="pre">%MappedType</span></code></a> directive (when
it is required) or of a class specification (when it is optional) to specify
the handwritten code that converts an instance of a C/C++ type to a Python
object.</p>
<p>If used as part of a class specification then instances of the class will be
automatically converted to the Python object, even though the class itself has
been wrapped.  This behaviour can be changed on a temporary basis from an
application by calling the <a class="reference internal" href="python_api.html#sip.enableautoconversion" title="sip.enableautoconversion"><code class="xref py py-func docutils literal"><span class="pre">sip.enableautoconversion()</span></code></a> function, or from
handwritten code by calling the <a class="reference internal" href="c_api.html#c.sipEnableAutoconversion" title="sipEnableAutoconversion"><code class="xref c c-func docutils literal"><span class="pre">sipEnableAutoconversion()</span></code></a> function.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the C/C++ instance to be converted.  It will never be
zero as the conversion from zero to <code class="docutils literal"><span class="pre">Py_None</span></code> is handled before the
handwritten code is called.</dd>
<dt>PyObject *sipTransferObj</dt>
<dd>This specifies any desired ownership changes to the returned object.  If it
is <code class="docutils literal"><span class="pre">NULL</span></code> then the ownership should be left unchanged.  If it is
<code class="docutils literal"><span class="pre">Py_None</span></code> then ownership should be transferred to Python.  Otherwise
ownership should be transferred to C/C++ and the returned object associated
with <em>sipTransferObj</em>.  The code can choose to interpret these changes in
any way.  For example, if the code is converting a C++ container of wrapped
classes to a Python list it is likely that the ownership changes should be
made to each element of the list.</dd>
</dl>
<p>The handwritten code must explicitly return a <code class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></code>.  If there was an
error then a Python exception must be raised and <code class="docutils literal"><span class="pre">NULL</span></code> returned.</p>
<p>The following example converts a <code class="docutils literal"><span class="pre">QList&lt;QWidget</span> <span class="pre">*&gt;</span></code> instance to a Python
list of <code class="docutils literal"><span class="pre">QWidget</span></code> instances:</p>
<div class="highlight-python"><div class="highlight"><pre>%ConvertFromTypeCode
    PyObject *l;

    // Create the Python list of the correct length.
    if ((l = PyList_New(sipCpp-&gt;size())) == NULL)
        return NULL;

    // Go through each element in the C++ instance and convert it to a
    // wrapped QWidget.
    for (int i = 0; i &lt; sipCpp-&gt;size(); ++i)
    {
        QWidget *w = sipCpp-&gt;at(i);
        PyObject *wobj;

        // Get the Python wrapper for the QWidget instance, creating a new
        // one if necessary, and handle any ownership transfer.
        if ((wobj = sipConvertFromType(w, sipType_QWidget, sipTransferObj)) == NULL)
        {
            // There was an error so garbage collect the Python list.
            Py_DECREF(l);
            return NULL;
        }

        // Add the wrapper to the list.
        PyList_SET_ITEM(l, i, wobj);
    }

    // Return the Python list.
    return l;
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%ConvertToSubClassCode">
<code class="descname">%ConvertToSubClassCode</code><a class="headerlink" href="#directive-%ConvertToSubClassCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%ConvertToSubClassCode
    <em>code</em>
%End
</pre>
<p>When SIP needs to wrap a C++ class instance it first checks to make sure it
hasn&#8217;t already done so.  If it has then it just returns a new reference to the
corresponding Python object.  Otherwise it creates a new Python object of the
appropriate type.  In C++ a function may be defined to return an instance of a
certain class, but can often return a sub-class instead.</p>
<p>This directive is used to specify handwritten code that exploits any available
real-time type information (RTTI) to see if there is a more specific Python
type that can be used when wrapping the C++ instance.  The RTTI may be
provided by the compiler or by the C++ instance itself.</p>
<p>The directive is included in the specification of one of the classes that the
handwritten code handles the type conversion for.  It doesn&#8217;t matter which
one, but a sensible choice would be the one at the root of that class
hierarchy in the module.</p>
<p>Note that if a class hierarchy extends over a number of modules then this
directive should be used in each of those modules to handle the part of the
hierarchy defined in that module.  SIP will ensure that the different pieces
of code are called in the right order to determine the most specific Python
type to use.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the C++ class instance.</dd>
<dt>void **sipCppRet</dt>
<dd>When the sub-class is derived from more than one super-class then it is
possible that the C++ address of the instance as the sub-class is
different to that of the super-class.  If so, then this must be set to the
C++ address of the instance when cast (usually using <code class="docutils literal"><span class="pre">static_cast</span></code>)
from the super-class to the sub-class.</dd>
<dt>const sipTypeDef *sipType</dt>
<dd><p class="first">The handwritten code must set this to the SIP generated type structure
that corresponds to the class instance.  (The type structure for class
<code class="docutils literal"><span class="pre">Klass</span></code> is <code class="docutils literal"><span class="pre">sipType_Klass</span></code>.)  If the RTTI of the class instance isn&#8217;t
recognised then <code class="docutils literal"><span class="pre">sipType</span></code> must be set to <code class="docutils literal"><span class="pre">NULL</span></code>.  The code doesn&#8217;t
have to recognise the exact class, only the most specific sub-class that
it can.</p>
<p class="last">The code may also set the value to a type that is apparently unrelated to
the requested type.  If this happens then the whole conversion process is
started again using the new type as the requested type.  This is typically
used to deal with classes that have more than one super-class that are
subject to this conversion process.  It allows the code for one super-class
to switch to the code for another (more appropriate) super-class.</p>
</dd>
<dt>sipWrapperType *sipClass</dt>
<dd><div class="first deprecated">
<p><span class="versionmodified">Deprecated since version 4.8: </span>Use <code class="docutils literal"><span class="pre">sipType</span></code> instead.</p>
</div>
<p class="last">The handwritten code must set this to the SIP generated Python type object
that corresponds to the class instance.  (The type object for class
<code class="docutils literal"><span class="pre">Klass</span></code> is <code class="docutils literal"><span class="pre">sipClass_Klass</span></code>.)  If the RTTI of the class instance isn&#8217;t
recognised then <code class="docutils literal"><span class="pre">sipClass</span></code> must be set to <code class="docutils literal"><span class="pre">NULL</span></code>.  The code doesn&#8217;t
have to recognise the exact class, only the most specific sub-class that
it can.</p>
</dd>
</dl>
<p>The handwritten code must not explicitly return.</p>
<p>The following example shows the sub-class conversion code for <code class="docutils literal"><span class="pre">QEvent</span></code> based
class hierarchy in PyQt:</p>
<div class="highlight-python"><div class="highlight"><pre>class QEvent
{
%ConvertToSubClassCode
    // QEvent sub-classes provide a unique type ID.
    switch (sipCpp-&gt;type())
    {
    case QEvent::Timer:
        sipType = sipType_QTimerEvent;
        break;

    case QEvent::KeyPress:
    case QEvent::KeyRelease:
        sipType = sipType_QKeyEvent;
        break;

    // Skip the remaining event types to keep the example short.

    default:
        // We don&#39;t recognise the type.
        sipType = NULL;
    }
%End

    // The rest of the class specification.

};
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%ConvertToTypeCode">
<code class="descname">%ConvertToTypeCode</code><a class="headerlink" href="#directive-%ConvertToTypeCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%ConvertToTypeCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify the handwritten code that converts a Python
object to a mapped type instance and to handle any ownership transfers.  It is
used as part of the <a class="reference internal" href="#directive-%MappedType"><code class="xref std std-directive docutils literal"><span class="pre">%MappedType</span></code></a> directive and as part of a class
specification.  The code is also called to determine if the Python object is of
the correct type prior to conversion.</p>
<p>When used as part of a class specification it can automatically convert
additional types of Python object.  For example, PyQt uses it in the
specification of the <code class="docutils literal"><span class="pre">QString</span></code> class to allow Python string objects and
unicode objects to be used wherever <code class="docutils literal"><span class="pre">QString</span></code> instances are expected.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>int *sipIsErr</dt>
<dd>If this is <code class="docutils literal"><span class="pre">NULL</span></code> then the code is being asked to check the type of the
Python object.  The check must not have any side effects.  Otherwise the
code is being asked to convert the Python object and a non-zero value
should be returned through this pointer if an error occurred during the
conversion.</dd>
<dt>PyObject *sipPy</dt>
<dd>This is the Python object to be converted.</dd>
<dt><em>type</em> **sipCppPtr</dt>
<dd>This is a pointer through which the address of the mapped type instance (or
zero if appropriate) is returned.  Its value is undefined if <code class="docutils literal"><span class="pre">sipIsErr</span></code>
is <code class="docutils literal"><span class="pre">NULL</span></code>.</dd>
<dt>PyObject *sipTransferObj</dt>
<dd>This specifies any desired ownership changes to <em>sipPy</em>.  If it is <code class="docutils literal"><span class="pre">NULL</span></code>
then the ownership should be left unchanged.  If it is <code class="docutils literal"><span class="pre">Py_None</span></code> then
ownership should be transferred to Python.  Otherwise ownership should be
transferred to C/C++ and <em>sipPy</em> associated with <em>sipTransferObj</em>.  The
code can choose to interpret these changes in any way.</dd>
</dl>
<p>The handwritten code must explicitly return an <code class="docutils literal"><span class="pre">int</span></code> the meaning of which
depends on the value of <code class="docutils literal"><span class="pre">sipIsErr</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">sipIsErr</span></code> is <code class="docutils literal"><span class="pre">NULL</span></code> then a non-zero value is returned if the Python
object has a type that can be converted to the mapped type.  Otherwise zero is
returned.</p>
<p>If <code class="docutils literal"><span class="pre">sipIsErr</span></code> is not <code class="docutils literal"><span class="pre">NULL</span></code> then a combination of the following flags is
returned.</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-macro docutils literal"><span class="pre">SIP_TEMPORARY</span></code> is set to indicate that the returned
instance is a temporary and should be released to avoid a memory
leak.</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">SIP_DERIVED_CLASS</span></code> is set to indicate that the type of the
returned instance is a derived class.  See
<a class="reference internal" href="c_api.html#ref-derived-classes"><span>Generated Derived Classes</span></a>.</li>
</ul>
</div></blockquote>
<p>The following example converts a Python list of <code class="docutils literal"><span class="pre">QPoint</span></code> instances to a
<code class="docutils literal"><span class="pre">QList&lt;QPoint&gt;</span></code> instance:</p>
<div class="highlight-python"><div class="highlight"><pre>%ConvertToTypeCode
    // See if we are just being asked to check the type of the Python
    // object.
    if (!sipIsErr)
    {
        // Checking whether or not None has been passed instead of a list
        // has already been done.
        if (!PyList_Check(sipPy))
            return 0;

        // Check the type of each element.  We specify SIP_NOT_NONE to
        // disallow None because it is a list of QPoint, not of a pointer
        // to a QPoint, so None isn&#39;t appropriate.
        for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
            if (!sipCanConvertToType(PyList_GET_ITEM(sipPy, i),
                                     sipType_QPoint, SIP_NOT_NONE))
                return 0;

        // The type is valid.
        return 1;
    }

    // Create the instance on the heap.
    QList&lt;QPoint&gt; *ql = new QList&lt;QPoint&gt;;

    for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
    {
        QPoint *qp;
        int state;

        // Get the address of the element&#39;s C++ instance.  Note that, in
        // this case, we don&#39;t apply any ownership changes to the list
        // elements, only to the list itself.
        qp = reinterpret_cast&lt;QPoint *&gt;(sipConvertToType(
                                                PyList_GET_ITEM(sipPy, i),
                                                sipType_QPoint, 0,
                                                SIP_NOT_NONE,
                                                &amp;state, sipIsErr));

        // Deal with any errors.
        if (*sipIsErr)
        {
            sipReleaseType(qp, sipType_QPoint, state);

            // Tidy up.
            delete ql;

            // There is no temporary instance.
            return 0;
        }

        ql-&gt;append(*qp);

        // A copy of the QPoint was appended to the list so we no longer
        // need it.  It may be a temporary instance that should be
        // destroyed, or a wrapped instance that should not be destroyed.
        // sipReleaseType() will do the right thing.
        sipReleaseType(qp, sipType_QPoint, state);
    }

    // Return the instance.
    *sipCppPtr = ql;

    // The instance should be regarded as temporary (and be destroyed as
    // soon as it has been used) unless it has been transferred from
    // Python.  sipGetState() is a convenience function that implements
    // this common transfer behaviour.
    return sipGetState(sipTransferObj);
%End
</pre></div>
</div>
<p>When used in a class specification the handwritten code replaces the code that
would normally be automatically generated.  This means that the handwritten
code must also handle instances of the class itself and not just the additional
types that are being supported.  This should be done by making calls to
<a class="reference internal" href="c_api.html#c.sipCanConvertToType" title="sipCanConvertToType"><code class="xref c c-func docutils literal"><span class="pre">sipCanConvertToType()</span></code></a> to check the object type and
<a class="reference internal" href="c_api.html#c.sipConvertToType" title="sipConvertToType"><code class="xref c c-func docutils literal"><span class="pre">sipConvertToType()</span></code></a> to convert the object.  The
<a class="reference internal" href="c_api.html#c.SIP_NO_CONVERTORS" title="SIP_NO_CONVERTORS"><code class="xref c c-macro docutils literal"><span class="pre">SIP_NO_CONVERTORS</span></code></a> flag <em>must</em> be passed to both these functions to
prevent recursive calls to the handwritten code.</p>
<dl class="directive">
<dt id="directive-%Copying">
<code class="descname">%Copying</code><a class="headerlink" href="#directive-%Copying" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%Copying
    <em>text</em>
%End
</pre>
<p>This directive is used to specify some arbitrary text that will be included at
the start of all source files generated by SIP.  It is normally used to include
copyright and licensing terms.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Copying
Copyright (c) 2015 Riverbank Computing Limited
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%DefaultDocstringFormat">
<code class="descname">%DefaultDocstringFormat</code><a class="headerlink" href="#directive-%DefaultDocstringFormat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.13.</span></p>
</div>
<div class="highlight-python"><div class="highlight"><pre>%DefaultDocstringFormat(name = [&quot;raw&quot; | &quot;deindented&quot;])
</pre></div>
</div>
<p>This directive is used to specify the default formatting of docstrings, i.e.
when the <a class="reference internal" href="#directive-%Docstring"><code class="xref std std-directive docutils literal"><span class="pre">%Docstring</span></code></a> directive does not specify an explicit format.</p>
<p>See the <a class="reference internal" href="#directive-%Docstring"><code class="xref std std-directive docutils literal"><span class="pre">%Docstring</span></code></a> directive for an explanation of the different
formats.  If the directive is not specified then the default format used is
<code class="docutils literal"><span class="pre">&quot;raw&quot;</span></code>.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%DefaultDocstringFormat &quot;deindented&quot;
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%DefaultEncoding">
<code class="descname">%DefaultEncoding</code><a class="headerlink" href="#directive-%DefaultEncoding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-python"><div class="highlight"><pre>%DefaultEncoding(name = [&quot;ASCII&quot; | &quot;Latin-1&quot; | &quot;UTF-8&quot; | &quot;None&quot;])
</pre></div>
</div>
<p>This directive is used to specify the default encoding used for <code class="docutils literal"><span class="pre">char</span></code>,
<code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span></code>, <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> or <code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> values.  An encoding of
<code class="docutils literal"><span class="pre">&quot;None&quot;</span></code> means that the value is unencoded.  The default can be overridden
for a particular value using the <a class="reference internal" href="annotations.html#argument-annotation-Encoding"><code class="xref std std-aanno docutils literal"><span class="pre">Encoding</span></code></a> annotation.</p>
<p>If the directive is not specified then the default encoding of the last
imported module is used, if any.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%DefaultEncoding &quot;Latin-1&quot;
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%DefaultMetatype">
<code class="descname">%DefaultMetatype</code><a class="headerlink" href="#directive-%DefaultMetatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%DefaultMetatype(name = <em>dotted-name</em>)
</pre>
<p>This directive is used to specify the Python type that should be used as the
meta-type for any C/C++ data type defined in the same module, and by importing
modules, that doesn&#8217;t have an explicit meta-type.</p>
<p>If this is not specified then <code class="docutils literal"><span class="pre">sip.wrappertype</span></code> is used.</p>
<p>You can also use the <a class="reference internal" href="annotations.html#class-annotation-Metatype"><code class="xref std std-canno docutils literal"><span class="pre">Metatype</span></code></a> class annotation to specify the
meta-type used by a particular C/C++ type.</p>
<p>See the section <a class="reference internal" href="using.html#ref-types-metatypes"><span>Types and Meta-types</span></a> for more details.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%DefaultMetatype PyQt4.QtCore.pyqtWrapperType
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%DefaultSupertype">
<code class="descname">%DefaultSupertype</code><a class="headerlink" href="#directive-%DefaultSupertype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%DefaultSupertype(name = <em>dotted-name</em>)
</pre>
<p>This directive is used to specify the Python type that should be used as the
super-type for any C/C++ data type defined in the same module that doesn&#8217;t have
an explicit super-type.</p>
<p>If this is not specified then <code class="docutils literal"><span class="pre">sip.wrapper</span></code> is used.</p>
<p>You can also use the <a class="reference internal" href="annotations.html#class-annotation-Supertype"><code class="xref std std-canno docutils literal"><span class="pre">Supertype</span></code></a> class annotation to specify the
super-type used by a particular C/C++ type.</p>
<p>See the section <a class="reference internal" href="using.html#ref-types-metatypes"><span>Types and Meta-types</span></a> for more details.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%DefaultSupertype sip.simplewrapper
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%Doc">
<code class="descname">%Doc</code><a class="headerlink" href="#directive-%Doc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 4.12: </span>Use the <a class="reference internal" href="#directive-%Extract"><code class="xref std std-directive docutils literal"><span class="pre">%Extract</span></code></a> directive instead.</p>
</div>
<pre class="literal-block">
%Doc
    <em>text</em>
%End
</pre>
<p>This directive is used to specify some arbitrary text that will be extracted
by SIP when the <code class="docutils literal"><span class="pre">-d</span></code> command line option is used.  The directive can be
specified any number of times and SIP will concatenate all the separate pieces
of text in the order that it sees them.</p>
<p>Documentation that is specified using this directive is local to the module in
which it appears.  It is ignored by modules that <a class="reference internal" href="#directive-%Import"><code class="xref std std-directive docutils literal"><span class="pre">%Import</span></code></a> it.  Use
the <a class="reference internal" href="#directive-%ExportedDoc"><code class="xref std std-directive docutils literal"><span class="pre">%ExportedDoc</span></code></a> directive for documentation that should be
included by all modules that <a class="reference internal" href="#directive-%Import"><code class="xref std std-directive docutils literal"><span class="pre">%Import</span></code></a> this one.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Doc
&lt;h1&gt;An Example&lt;/h1&gt;
&lt;p&gt;
This fragment of documentation is HTML and is local to the module in
which it is defined.
&lt;/p&gt;
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%Docstring">
<code class="descname">%Docstring</code><a class="headerlink" href="#directive-%Docstring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.10.</span></p>
</div>
<pre class="literal-block">
%Docstring(format = [&quot;raw&quot; | &quot;deindented&quot;])
    <em>text</em>
%End
</pre>
<p>This directive is used to specify explicit docstrings for modules, classes,
functions, methods and properties.</p>
<p>The docstring of a class is made up of the docstring specified for the class
itself, with the docstrings specified for each contructor appended.</p>
<p>The docstring of a function or method is made up of the concatenated docstrings
specified for each of the overloads.</p>
<p>Specifying an explicit docstring will prevent SIP from generating an automatic
docstring that describes the Python signature of a function or method overload.
This means that SIP will generate less informative exceptions (i.e. without a
full signature) when it fails to match a set of arguments to any function or
method overload.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.13.</span></p>
</div>
<p>The format may either be <code class="docutils literal"><span class="pre">&quot;raw&quot;</span></code> or <code class="docutils literal"><span class="pre">&quot;deindented&quot;</span></code>.  If it is not specified
then the value specified by any <a class="reference internal" href="#directive-%DefaultDocstringFormat"><code class="xref std std-directive docutils literal"><span class="pre">%DefaultDocstringFormat</span></code></a> directive
is used.</p>
<p>If the format is <code class="docutils literal"><span class="pre">&quot;raw&quot;</span></code> then the docstring is used as it appears in the
specification file.</p>
<p>If the format is <code class="docutils literal"><span class="pre">&quot;deindented&quot;</span></code> then any leading spaces common to all
non-blank lines of the docstring are removed.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>class Klass
{
%Docstring
This will be at the start of the class&#39;s docstring.
%End

public:
    Klass();
%Docstring deindented
    This will be appended to the class&#39;s docstring and will not be indented.

        This will be indented by four spaces.
%End
};
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%End">
<code class="descname">%End</code><a class="headerlink" href="#directive-%End" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This isn&#8217;t a directive in itself, but is used to terminate a number of
directives that allow a block of handwritten code or text to be specified.</p>
<dl class="directive">
<dt id="directive-%Exception">
<code class="descname">%Exception</code><a class="headerlink" href="#directive-%Exception" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%Exception <em>name</em> [(<em>base-exception</em>)]
{
    [<a class="reference internal" href="#directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%TypeHeaderCode</span></code></a>]
    <a class="reference internal" href="#directive-%RaiseCode"><code class="xref std std-directive docutils literal"><span class="pre">%RaiseCode</span></code></a>
};
</pre>
<p>This directive is used to define new Python exceptions, or to provide a stub
for existing Python exceptions.  It allows handwritten code to be provided
that implements the translation between C++ exceptions and Python exceptions.
The arguments to <code class="docutils literal"><span class="pre">throw</span> <span class="pre">()</span></code> specifiers must either be names of classes or the
names of Python exceptions defined by this directive.</p>
<p><em>name</em> is the name of the exception.</p>
<p><em>base-exception</em> is the optional base exception.  This may be either one of
the standard Python exceptions or one defined with a previous
<a class="reference internal" href="#directive-%Exception"><code class="xref std std-directive docutils literal"><span class="pre">%Exception</span></code></a> directive.</p>
<p>The optional <a class="reference internal" href="#directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%TypeHeaderCode</span></code></a> sub-directive is used to specify any
external interface to the exception being defined.</p>
<p>The <a class="reference internal" href="#directive-%RaiseCode"><code class="xref std std-directive docutils literal"><span class="pre">%RaiseCode</span></code></a> sub-directive is used to specify the handwritten
code that converts a reference to the C++ exception to the Python exception.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Exception std::exception(SIP_Exception) /PyName=StdException/
{
%TypeHeaderCode
#include &lt;exception&gt;
%End
%RaiseCode
    const char *detail = sipExceptionRef.what();

    SIP_BLOCK_THREADS
    PyErr_SetString(sipException_std_exception, detail);
    SIP_UNBLOCK_THREADS
%End
};
</pre></div>
</div>
<p>In this example we map the standard C++ exception to a new Python exception.
The new exception is called <code class="docutils literal"><span class="pre">StdException</span></code> and is derived from the standard
Python exception <code class="docutils literal"><span class="pre">Exception</span></code>.</p>
<p>An exception may be annotated with <a class="reference internal" href="annotations.html#exception-annotation-Default"><code class="xref std std-xanno docutils literal"><span class="pre">Default</span></code></a> to specify that it should
be caught by default if there is no <code class="docutils literal"><span class="pre">throw</span></code> clause.</p>
<dl class="directive">
<dt id="directive-%ExportedDoc">
<code class="descname">%ExportedDoc</code><a class="headerlink" href="#directive-%ExportedDoc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 4.12: </span>Use the <a class="reference internal" href="#directive-%Extract"><code class="xref std std-directive docutils literal"><span class="pre">%Extract</span></code></a> directive instead.</p>
</div>
<pre class="literal-block">
%ExportedDoc
    <em>text</em>
%End
</pre>
<p>This directive is used to specify some arbitrary text that will be extracted
by SIP when the <code class="docutils literal"><span class="pre">-d</span></code> command line option is used.  The directive can be
specified any number of times and SIP will concatenate all the separate pieces
of text in the order that it sees them.</p>
<p>Documentation that is specified using this directive will also be included by
modules that <a class="reference internal" href="#directive-%Import"><code class="xref std std-directive docutils literal"><span class="pre">%Import</span></code></a> it.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%ExportedDoc
==========
An Example
==========

This fragment of documentation is reStructuredText and will appear in the
module in which it is defined and all modules that %Import it.
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%ExportedHeaderCode">
<code class="descname">%ExportedHeaderCode</code><a class="headerlink" href="#directive-%ExportedHeaderCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%ExportedHeaderCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code, typically the declarations
of types, that is placed in a header file that is included by all generated
code for all modules.  It should not include function declarations because
Python modules should not explicitly call functions in another Python module.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#directive-%ModuleCode"><code class="xref std std-directive docutils literal"><span class="pre">%ModuleCode</span></code></a>, <a class="reference internal" href="#directive-%ModuleHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%ModuleHeaderCode</span></code></a></p>
</div>
<dl class="directive">
<dt id="directive-%Extract">
<code class="descname">%Extract</code><a class="headerlink" href="#directive-%Extract" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.12.</span></p>
</div>
<pre class="literal-block">
%Extract(id = <em>name</em> [, order = <em>integer</em>])
    <em>text</em>
%End
</pre>
<p>This directive is used to specify part of an extract.  An extract is a
collection of arbitrary text specified as one or more parts each having the
same <code class="docutils literal"><span class="pre">id</span></code>.  SIP places no interpretation on an identifier, or on the
contents of the extract.  Extracts may be used for any purpose, e.g.
documentation, tests etc.</p>
<p>The part&#8217;s optional <code class="docutils literal"><span class="pre">order</span></code> determines its position relative to the extract&#8217;s
other parts.  If the order is not specified then the part is appended to the
extract.</p>
<p>An extract is written to a file using the <a class="reference internal" href="command_line.html#cmdoption-sip-X"><code class="xref std std-option docutils literal"><span class="pre">-X</span></code></a> command line
option.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Extract example
This will be the last line because there is no explicit order.
%End

%Extract(id=example, order=20)
This will be the second line.
%End

%Extract(id=example, order=10)
This will be the first line.
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%Feature">
<code class="descname">%Feature</code><a class="headerlink" href="#directive-%Feature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%Feature(name = <em>name</em>)
</pre>
<p>This directive is used to declare a feature.  Features (along with
<a class="reference internal" href="#directive-%Platforms"><code class="xref std std-directive docutils literal"><span class="pre">%Platforms</span></code></a> and <a class="reference internal" href="#directive-%Timeline"><code class="xref std std-directive docutils literal"><span class="pre">%Timeline</span></code></a>) are used by the
<a class="reference internal" href="#directive-%If"><code class="xref std std-directive docutils literal"><span class="pre">%If</span></code></a> directive to control whether or not parts of a specification
are processed or ignored.</p>
<p>Features are mutually independent of each other - any combination of features
may be enabled or disable.  By default all features are enabled.  The
<a class="reference internal" href="command_line.html#cmdoption-sip-x"><code class="xref std std-option docutils literal"><span class="pre">-x</span></code></a> command line option is used to disable a feature.</p>
<p>If a feature is enabled then SIP will automatically generate a corresponding C
preprocessor symbol for use by handwritten code.  The symbol is the name of
the feature prefixed by <code class="docutils literal"><span class="pre">SIP_FEATURE_</span></code>.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Feature FOO_SUPPORT

%If (FOO_SUPPORT)
void foo();
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%FinalisationCode">
<code class="descname">%FinalisationCode</code><a class="headerlink" href="#directive-%FinalisationCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.15.</span></p>
</div>
<pre class="literal-block">
%FinalisationCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that is executed once the
instance of a wrapped class has been created.  The handwritten code is passed a
dictionary of any remaining keyword arguments.  It must explicitly return an
integer result which should be <code class="docutils literal"><span class="pre">0</span></code> if there was no error.  If an error
occurred then <code class="docutils literal"><span class="pre">-1</span></code> should be returned and a Python exception raised.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the structure or class instance, i.e.
<code class="docutils literal"><span class="pre">self</span></code>.</dd>
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>PyObject *sipKwds</dt>
<dd>This is an optional dictionary of unused keyword arguments.  It may be
<code class="docutils literal"><span class="pre">NULL</span></code> or refer to an empty dictionary.  If the handwritten code handles
any of the arguments then, if <code class="docutils literal"><span class="pre">sipUnused</span></code> is <code class="docutils literal"><span class="pre">NULL</span></code>, those arguments
must be removed from the dictionary.  If <code class="docutils literal"><span class="pre">sipUnused</span></code> is not <code class="docutils literal"><span class="pre">NULL</span></code> then
the <code class="docutils literal"><span class="pre">sipKwds</span></code> dictionary must not be updated.  Instead a new dictionary
must be created that contains any remaining unused keyword arguments and
the address of the new dictionary returned via <code class="docutils literal"><span class="pre">sipUnused</span></code>.  This rather
complicated API ensures that new dictionaries are created only when
necessary.</dd>
<dt>PyObject **sipUnused</dt>
<dd>This is an optional pointer to where the handwritten code should save the
address of any new dictionary of unused keyword arguments that it creates.
If it is <code class="docutils literal"><span class="pre">NULL</span></code> then the handwritten code is allowed to update the
<code class="docutils literal"><span class="pre">sipKwds</span></code> dictionary.</dd>
</dl>
<dl class="directive">
<dt id="directive-%GCClearCode">
<code class="descname">%GCClearCode</code><a class="headerlink" href="#directive-%GCClearCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%GCClearCode
    <em>code</em>
%End
</pre>
<p>Python has a cyclic garbage collector which can identify and release unneeded
objects even when their reference counts are not zero.  If a wrapped C
structure or C++ class keeps its own reference to a Python object then, if the
garbage collector is to do its job, it needs to provide some handwritten code
to traverse and potentially clear those embedded references.</p>
<p>See the section <a class="reference external" href="http://docs.python.org/3/c-api/gcsupport.html">Supporting Cyclic Garbage Collection</a> in the Python documentation
for the details.</p>
<p>This directive is used to specify the code that clears any embedded references.
(See <a class="reference internal" href="#directive-%GCTraverseCode"><code class="xref std std-directive docutils literal"><span class="pre">%GCTraverseCode</span></code></a> for specifying the code that traverses any
embedded references.)</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>int sipRes</dt>
<dd>The handwritten code should set this to the result to be returned.</dd>
</dl>
<p>The following simplified example is taken from PyQt.  The <code class="docutils literal"><span class="pre">QCustomEvent</span></code>
class allows arbitary data to be attached to the event.  In PyQt this data is
always a Python object and so should be handled by the garbage collector:</p>
<div class="highlight-python"><div class="highlight"><pre>%GCClearCode
    PyObject *obj;

    // Get the object.
    obj = reinterpret_cast&lt;PyObject *&gt;(sipCpp-&gt;data());

    // Clear the pointer.
    sipCpp-&gt;setData(0);

    // Clear the reference.
    Py_XDECREF(obj);

    // Report no error.
    sipRes = 0;
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%GCTraverseCode">
<code class="descname">%GCTraverseCode</code><a class="headerlink" href="#directive-%GCTraverseCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%GCTraverseCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify the code that traverses any embedded
references for Python&#8217;s cyclic garbage collector.  (See
<a class="reference internal" href="#directive-%GCClearCode"><code class="xref std std-directive docutils literal"><span class="pre">%GCClearCode</span></code></a> for a full explanation.)</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>visitproc sipVisit</dt>
<dd>This is the visit function provided by the garbage collector.</dd>
<dt>void *sipArg</dt>
<dd>This is the argument to the visit function provided by the garbage
collector.</dd>
<dt>int sipRes</dt>
<dd>The handwritten code should set this to the result to be returned.</dd>
</dl>
<p>The following simplified example is taken from PyQt&#8217;s <code class="docutils literal"><span class="pre">QCustomEvent</span></code> class:</p>
<div class="highlight-python"><div class="highlight"><pre>%GCTraverseCode
    PyObject *obj;

    // Get the object.
    obj = reinterpret_cast&lt;PyObject *&gt;(sipCpp-&gt;data());

    // Call the visit function if there was an object.
    if (obj)
        sipRes = sipVisit(obj, sipArg);
    else
        sipRes = 0;
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%GetCode">
<code class="descname">%GetCode</code><a class="headerlink" href="#directive-%GetCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%GetCode
    <em>code</em>
%End
</pre>
<p>This sub-directive is used in the declaration of a C++ class variable or C
structure member to specify handwritten code to convert it to a Python object.
It is usually used to handle types that SIP cannot deal with automatically.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.  It is not made available if the
variable being wrapped is a static class variable.</dd>
<dt>PyObject *sipPy</dt>
<dd>The handwritten code must set this to the Python representation of the
class variable or structure member.  If there is an error then the code
must raise an exception and set this to <code class="docutils literal"><span class="pre">NULL</span></code>.</dd>
<dt>PyObject *sipPyType</dt>
<dd>If the variable being wrapped is a static class variable then this is the
Python type object of the class from which the variable was referenced
(<em>not</em> the class in which it is defined).  It may be safely cast to a
PyTypeObject * or a sipWrapperType *.</dd>
</dl>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>struct Entity
{
    /*
     * In this contrived example the C library we are wrapping actually
     * defines this as char buffer[100] which SIP cannot handle
     * automatically.
     */
    char *buffer
    {
        %GetCode
            sipPy = PyString_FromStringAndSize(sipCpp-&gt;buffer, 100);
        %End

        %SetCode
            char *ptr;
            int length;

            if (PyString_AsStringAndSize(sipPy, &amp;ptr, &amp;length) == -1)
            {
                sipErr = 1;
            }
            else if (length != 100)
            {
                /*
                 * Raise an exception because the length isn&#39;t exactly
                 * right.
                 */

                PyErr_SetString(PyExc_ValueError,
                        &quot;an Entity.buffer must be exactly 100 bytes&quot;);
                sipErr = 1;
            }
            else
            {
                memcpy(sipCpp-&gt;buffer, ptr, 100);
            }
        %End
    };
}
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#directive-%AccessCode"><code class="xref std std-directive docutils literal"><span class="pre">%AccessCode</span></code></a>, <a class="reference internal" href="#directive-%SetCode"><code class="xref std std-directive docutils literal"><span class="pre">%SetCode</span></code></a></p>
</div>
<dl class="directive">
<dt id="directive-%If">
<code class="descname">%If</code><a class="headerlink" href="#directive-%If" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%If (<em>expression</em>)
    <em>specification</em>
%End
</pre>
<p>where</p>
<pre class="literal-block">
<em>expression</em> ::= [<em>ored-qualifiers</em> | <em>range</em>]

<em>ored-qualifiers</em> ::= [<em>qualifier</em> | <em>qualifier</em> <strong>||</strong> <em>ored-qualifiers</em>]

<em>qualifier</em> ::= [<strong>!</strong>] [<em>feature</em> | <em>platform</em>]

<em>range</em> ::= [<em>version</em>] <strong>-</strong> [<em>version</em>]
</pre>
<p>This directive is used in conjunction with features (see
<a class="reference internal" href="#directive-%Feature"><code class="xref std std-directive docutils literal"><span class="pre">%Feature</span></code></a>), platforms (see <a class="reference internal" href="#directive-%Platforms"><code class="xref std std-directive docutils literal"><span class="pre">%Platforms</span></code></a>) and versions
(see <a class="reference internal" href="#directive-%Timeline"><code class="xref std std-directive docutils literal"><span class="pre">%Timeline</span></code></a>) to control whether or not parts of a specification
are processed or not.</p>
<p>A <em>range</em> of versions means all versions starting with the lower bound up to
but excluding the upper bound.  If the lower bound is omitted then it is
interpreted as being before the earliest version.  If the upper bound is
omitted then it is interpreted as being after the latest version.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Feature SUPPORT_FOO
%Platforms {WIN32_PLATFORM POSIX_PLATFORM MACOS_PLATFORM}
%Timeline {V1_0 V1_1 V2_0 V3_0}

%If (!SUPPORT_FOO)
    // Process this if the SUPPORT_FOO feature is disabled.
%End

%If (POSIX_PLATFORM || MACOS_PLATFORM)
    // Process this if either the POSIX_PLATFORM or MACOS_PLATFORM
    // platforms are enabled.
%End

%If (V1_0 - V2_0)
    // Process this if either V1_0 or V1_1 is enabled.
%End

%If (V2_0 - )
    // Process this if either V2_0 or V3_0 is enabled.
%End

%If (SIP_4_13 - )
    // SIP v4.13 and later will process this.
%End

%If ( - )
    // Always process this.
%End
</pre></div>
</div>
<p>Also note that the only way to specify the logical and of qualifiers is to use
nested <a class="reference internal" href="#directive-%If"><code class="xref std std-directive docutils literal"><span class="pre">%If</span></code></a> directives.</p>
<dl class="directive">
<dt id="directive-%Import">
<code class="descname">%Import</code><a class="headerlink" href="#directive-%Import" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%Import(name = <em>filename</em>)
</pre>
<p>This directive is used to import the specification of another module.  This is
needed if the current module makes use of any types defined in the imported
module, e.g. as an argument to a function, or to sub-class.</p>
<p>If <code class="docutils literal"><span class="pre">name</span></code> cannot be opened then SIP prepends <code class="docutils literal"><span class="pre">name</span></code> with the name of the
directory containing the current specification file (i.e. the one containing
the <a class="reference internal" href="#directive-%Import"><code class="xref std std-directive docutils literal"><span class="pre">%Import</span></code></a> directive) and tries again.  If this also fails then
SIP prepends <code class="docutils literal"><span class="pre">name</span></code> with each of the directories, in turn, specified by the
<a class="reference internal" href="command_line.html#cmdoption-sip-I"><code class="xref std std-option docutils literal"><span class="pre">-I</span></code></a> command line option.</p>
<p>Directory separators must always be <code class="docutils literal"><span class="pre">/</span></code>.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Import qt/qtmod.sip
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%Include">
<code class="descname">%Include</code><a class="headerlink" href="#directive-%Include" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%Include(name = <em>filename</em> [, optional = [True | False]])
</pre>
<p>This directive is used to include contents of another file as part of the
specification of the current module.  It is the equivalent of the C
preprocessor&#8217;s <code class="docutils literal"><span class="pre">#include</span></code> directive and is used to structure a large module
specification into manageable pieces.</p>
<p><a class="reference internal" href="#directive-%Include"><code class="xref std std-directive docutils literal"><span class="pre">%Include</span></code></a> follows the same search process as the
<a class="reference internal" href="#directive-%Import"><code class="xref std std-directive docutils literal"><span class="pre">%Import</span></code></a> directive when trying to open <code class="docutils literal"><span class="pre">name</span></code>.</p>
<p>if <code class="docutils literal"><span class="pre">optional</span></code> is set then SIP will silently continue processing if the file
could not be opened.</p>
<p>Directory separators must always be <code class="docutils literal"><span class="pre">/</span></code>.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Include qwidget.sip
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%InitialisationCode">
<code class="descname">%InitialisationCode</code><a class="headerlink" href="#directive-%InitialisationCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%InitialisationCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that is embedded in-line
in the generated module initialisation code after the SIP module has been
imported but before the module itself has been initialised.</p>
<p>It is typically used to call <a class="reference internal" href="c_api.html#c.sipRegisterPyType" title="sipRegisterPyType"><code class="xref c c-func docutils literal"><span class="pre">sipRegisterPyType()</span></code></a>.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%InitialisationCode
    // The code will be executed when the module is first imported, after
    // the SIP module has been imported, but before other module-specific
    // initialisation has been completed.
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%InstanceCode">
<code class="descname">%InstanceCode</code><a class="headerlink" href="#directive-%InstanceCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.14.</span></p>
</div>
<pre class="literal-block">
%InstanceCode
    <em>code</em>
%End
</pre>
<p>There are a number of circumstances where SIP needs to create an instance of a
C++ class but may not be able to do so.  For example the C++ class may be
abstract or may not have an argumentless public constructor.  This directive is
used in the definition of a class or mapped type to specify handwritten code to
create an instance of the C++ class.  For example, if the C++ class is
abstract, then the handwritten code may return an instance of a concrete
sub-class.</p>
<p>The following variable is made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This must be set by the handwritten code to the address of an instance of
the C++ class.  It doesn&#8217;t matter if the instance is on the heap or not as
it will never be explicitly destroyed.</dd>
</dl>
<dl class="directive">
<dt id="directive-%License">
<code class="descname">%License</code><a class="headerlink" href="#directive-%License" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%License(type = <em>string</em>
        [, licensee = <em>string</em>]
        [, signature = <em>string</em>]
        [, timestamp = <em>string</em>])
</pre>
<p>This directive is used to specify the contents of an optional license
dictionary.  The license dictionary is called <code class="xref py py-data docutils literal"><span class="pre">__license__</span></code> and is stored
in the module dictionary.</p>
<p><code class="docutils literal"><span class="pre">type</span></code> is the type of the license and its value in the license dictionary is
accessed using the <code class="docutils literal"><span class="pre">&quot;Type&quot;</span></code> key.  No restrictions are placed on the value.</p>
<p><code class="docutils literal"><span class="pre">licensee</span></code> is the optional name of the licensee and its value in the license
dictionary is accessed using the <code class="docutils literal"><span class="pre">&quot;Licensee&quot;</span></code> key.  No restrictions are
placed on the value.</p>
<p><code class="docutils literal"><span class="pre">signature</span></code> is the license&#8217;s optional signature and its value in the license
dictionary is accessed using the <code class="docutils literal"><span class="pre">&quot;Signature&quot;</span></code> key.  No restrictions are
placed on the value.</p>
<p><code class="docutils literal"><span class="pre">timestamp</span></code> is the license&#8217;s optional timestamp and its value in the license
dictionary is accessed using the <code class="docutils literal"><span class="pre">&quot;Timestamp&quot;</span></code> key.  No restrictions are
placed on the value.</p>
<p>Note that this directive isn&#8217;t an attempt to impose any licensing restrictions
on a module.  It is simply a method for easily embedding licensing information
in a module so that it is accessible to Python scripts.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%License &quot;GPL&quot;
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%MappedType">
<code class="descname">%MappedType</code><a class="headerlink" href="#directive-%MappedType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
template&lt;<em>type-list</em>&gt;
%MappedType <em>type</em>
{
    [<a class="reference internal" href="#directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%TypeHeaderCode</span></code></a>]
    [<a class="reference internal" href="#directive-%ConvertToTypeCode"><code class="xref std std-directive docutils literal"><span class="pre">%ConvertToTypeCode</span></code></a>]
    [<a class="reference internal" href="#directive-%ConvertFromTypeCode"><code class="xref std std-directive docutils literal"><span class="pre">%ConvertFromTypeCode</span></code></a>]
};

%MappedType <em>type</em>
{
    [<a class="reference internal" href="#directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%TypeHeaderCode</span></code></a>]
    [<a class="reference internal" href="#directive-%ConvertToTypeCode"><code class="xref std std-directive docutils literal"><span class="pre">%ConvertToTypeCode</span></code></a>]
    [<a class="reference internal" href="#directive-%ConvertFromTypeCode"><code class="xref std std-directive docutils literal"><span class="pre">%ConvertFromTypeCode</span></code></a>]
};
</pre>
<p>This directive is used to define an automatic mapping between a C or C++ type
and a Python type.  It can be used as part of a template, or to map a specific
type.</p>
<p>When used as part of a template <em>type</em> cannot itself refer to a template.  Any
occurrences of any of the type names (but not any <code class="docutils literal"><span class="pre">*</span></code> or <code class="docutils literal"><span class="pre">&amp;</span></code>) in
<em>type-list</em> will be replaced by the actual type names used when the template is
instantiated.  Template mapped types are instantiated automatically as required
(unlike template classes which are only instantiated using <code class="docutils literal"><span class="pre">typedef</span></code>).</p>
<p>Any explicit mapped type will be used in preference to any template that maps
the same type, ie. a template will not be automatically instantiated if there
is an explicit mapped type.</p>
<p>The optional <a class="reference internal" href="#directive-%TypeHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%TypeHeaderCode</span></code></a> sub-directive is used to specify the
library interface to the type being mapped.</p>
<p>The optional <a class="reference internal" href="#directive-%ConvertToTypeCode"><code class="xref std std-directive docutils literal"><span class="pre">%ConvertToTypeCode</span></code></a> sub-directive is used to specify
the handwritten code that converts a Python object to an instance of the mapped
type.</p>
<p>The optional <a class="reference internal" href="#directive-%ConvertFromTypeCode"><code class="xref std std-directive docutils literal"><span class="pre">%ConvertFromTypeCode</span></code></a> sub-directive is used to specify
the handwritten code that converts an instance of the mapped type to a Python
object.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>template&lt;Type *&gt;
%MappedType QList
{
%TypeHeaderCode
// Include the library interface to the type being mapped.
#include &lt;qlist.h&gt;
%End

%ConvertToTypeCode
    // See if we are just being asked to check the type of the Python
    // object.
    if (sipIsErr == NULL)
    {
        // Check it is a list.
        if (!PyList_Check(sipPy))
            return 0;

        // Now check each element of the list is of the type we expect.
        // The template is for a pointer type so we don&#39;t disallow None.
        for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
            if (!sipCanConvertToType(PyList_GET_ITEM(sipPy, i),
                                     sipType_Type, 0))
                return 0;

        return 1;
    }

    // Create the instance on the heap.
    QList&lt;Type *&gt; *ql = new QList&lt;Type *&gt;;

    for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
    {
        // Use the SIP API to convert the Python object to the
        // corresponding C++ instance.  Note that we apply any ownership
        // transfer to the list itself, not the individual elements.
        Type *t = reinterpret_cast&lt;Type *&gt;(sipConvertToType(
                                            PyList_GET_ITEM(sipPy, i),
                                            sipType_Type, 0, 0, 0,
                                            sipIsErr));

        if (*sipIsErr)
        {
            // Tidy up.
            delete ql;

            // There is nothing on the heap.
            return 0;
        }

        // Add the pointer to the C++ instance.
        ql-&gt;append(t);
    }

    // Return the instance on the heap.
    *sipCppPtr = ql;

    // Apply the normal transfer.
    return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
    PyObject *l;

    // Create the Python list of the correct length.
    if ((l = PyList_New(sipCpp-&gt;size())) == NULL)
        return NULL;

    // Go through each element in the C++ instance and convert it to the
    // corresponding Python object.
    for (int i = 0; i &lt; sipCpp-&gt;size(); ++i)
    {
        Type *t = sipCpp-&gt;at(i);
        PyObject *tobj;

        if ((tobj = sipConvertFromType(t, sipType_Type, sipTransferObj)) == NULL)
        {
            // There was an error so garbage collect the Python list.
            Py_DECREF(l);
            return NULL;
        }

        PyList_SET_ITEM(l, i, tobj);
    }

    // Return the Python list.
    return l;
%End
};
</pre></div>
</div>
<p>Using this we can use, for example, <code class="docutils literal"><span class="pre">QList&lt;QObject</span> <span class="pre">*&gt;</span></code> throughout the
module&#8217;s specification files (and in any module that imports this one).  The
generated code will automatically map this to and from a Python list of QObject
instances when appropriate.</p>
<dl class="directive">
<dt id="directive-%MethodCode">
<code class="descname">%MethodCode</code><a class="headerlink" href="#directive-%MethodCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%MethodCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the specification of a global function, class
method, operator, constructor or destructor to specify handwritten code that
replaces the normally generated call to the function being wrapped.  It is
usually used to handle argument types and results that SIP cannot deal with
automatically.</p>
<p>Normally the specified code is embedded in-line after the function&#8217;s arguments
have been successfully converted from Python objects to their C or C++
equivalents.  In this case the specified code must not include any <code class="docutils literal"><span class="pre">return</span></code>
statements.</p>
<p>However if the <a class="reference internal" href="annotations.html#function-annotation-NoArgParser"><code class="xref std std-fanno docutils literal"><span class="pre">NoArgParser</span></code></a> annotation has been used then the specified
code is also responsible for parsing the arguments.  No other code is generated
by SIP and the specified code must include a <code class="docutils literal"><span class="pre">return</span></code> statement.</p>
<p>In the context of a destructor the specified code is embedded in-line in the
Python type&#8217;s deallocation function.  Unlike other contexts it supplements
rather than replaces the normally generated code, so it must not include code
to return the C structure or C++ class instance to the heap.  The code is only
called if ownership of the structure or class is with Python.</p>
<p>The specified code must also handle the Python Global Interpreter Lock (GIL).
If compatibility with SIP v3.x is required then the GIL must be released
immediately before the C++ call and reacquired immediately afterwards as shown
in this example fragment:</p>
<div class="highlight-python"><div class="highlight"><pre>Py_BEGIN_ALLOW_THREADS
sipCpp-&gt;foo();
Py_END_ALLOW_THREADS
</pre></div>
</div>
<p>If compatibility with SIP v3.x is not required then this is optional but
should be done if the C++ function might block the current thread or take a
significant amount of time to execute.  (See <a class="reference internal" href="using.html#ref-gil"><span>The Python Global Interpreter Lock</span></a> and the
<a class="reference internal" href="annotations.html#function-annotation-ReleaseGIL"><code class="xref std std-fanno docutils literal"><span class="pre">ReleaseGIL</span></code></a> and <a class="reference internal" href="annotations.html#function-annotation-HoldGIL"><code class="xref std std-fanno docutils literal"><span class="pre">HoldGIL</span></code></a> annotations.)</p>
<p>If the <a class="reference internal" href="annotations.html#function-annotation-NoArgParser"><code class="xref std std-fanno docutils literal"><span class="pre">NoArgParser</span></code></a> annotation has not been used then the following
variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> a0</dt>
<dd><p class="first">There is a variable for each argument of the Python signature (excluding
any <code class="docutils literal"><span class="pre">self</span></code> argument) named <code class="docutils literal"><span class="pre">a0</span></code>, <code class="docutils literal"><span class="pre">a1</span></code>, etc.  If
<code class="docutils literal"><span class="pre">use_argument_names</span></code> has been set in the <a class="reference internal" href="#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a> directive
then the name of the argument is the real name.  The <em>type</em> of the variable
is the same as the type defined in the specification with the following
exceptions:</p>
<ul class="simple">
<li>if the argument is only used to return a value (e.g. it is an <code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span></code>
without an <a class="reference internal" href="annotations.html#argument-annotation-In"><code class="xref std std-aanno docutils literal"><span class="pre">In</span></code></a> annotation) then the type has one less level of
indirection (e.g. it will be an <code class="docutils literal"><span class="pre">int</span></code>)</li>
<li>if the argument is a structure or class (or a reference or a pointer to a
structure or class) then <em>type</em> will always be a pointer to the structure
or class.</li>
</ul>
<p class="last">Note that handwritten code for destructors never has any arguments.</p>
</dd>
<dt>PyObject *a0Wrapper</dt>
<dd><p class="first">This variable is made available only if the <a class="reference internal" href="annotations.html#argument-annotation-GetWrapper"><code class="xref std std-aanno docutils literal"><span class="pre">GetWrapper</span></code></a> annotation
is specified for the corresponding argument.  The variable is a pointer to
the Python object that wraps the argument.</p>
<p class="last">If <code class="docutils literal"><span class="pre">use_argument_names</span></code> has been set in the <a class="reference internal" href="#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a>
directive then the name of the variable is the real name of the argument
with <code class="docutils literal"><span class="pre">Wrapper</span></code> appended.</p>
</dd>
<dt><em>type</em> *sipCpp</dt>
<dd><p class="first">If the directive is used in the context of a class constructor then this
must be set by the handwritten code to the constructed instance.  If it is
set to <code class="docutils literal"><span class="pre">0</span></code> and no Python exception is raised then SIP will continue to
try other Python signatures.</p>
<p>If the directive is used in the context of a method (but not the standard
binary operator methods, e.g. <code class="xref py py-meth docutils literal"><span class="pre">__add__()</span></code>) or a destructor then this is
a pointer to the C structure or C++ class instance.</p>
<p>Its <em>type</em> is a pointer to the structure or class.</p>
<p class="last">Standard binary operator methods follow the same convention as global
functions and instead define two arguments called <code class="docutils literal"><span class="pre">a0</span></code> and <code class="docutils literal"><span class="pre">a1</span></code>.</p>
</dd>
<dt>sipErrorState sipError</dt>
<dd><p class="first">The handwritten code should set this to either <code class="docutils literal"><span class="pre">sipErrorContinue</span></code> or
<code class="docutils literal"><span class="pre">sipErrorFail</span></code>, and raise an appropriate Python exception, if an error
is detected.  Its initial value will be <code class="docutils literal"><span class="pre">sipErrorNone</span></code>.</p>
<p>When <code class="docutils literal"><span class="pre">sipErrorContinue</span></code> is used, SIP will remember the exception as the
reason why the particular overloaded callable could not be invoked.  It
will then continue to try the next overloaded callable.  It is typically
used by code that needs to do additional type checking of the callable&#8217;s
arguments.</p>
<p>When <code class="docutils literal"><span class="pre">sipErrorFail</span></code> is used, SIP will report the exception immediately
and will not attempt to invoke other overloaded callables.</p>
<p class="last"><code class="docutils literal"><span class="pre">sipError</span></code> is not provided for destructors.</p>
</dd>
<dt>int sipIsErr</dt>
<dd><p class="first">The handwritten code should set this to a non-zero value, and raise an
appropriate Python exception, if an error is detected.  This is the
equivalent of setting <code class="docutils literal"><span class="pre">sipError</span></code> to <code class="docutils literal"><span class="pre">sipErrorFail</span></code>.  Its initial value
will be <code class="docutils literal"><span class="pre">0</span></code>.</p>
<p class="last"><code class="docutils literal"><span class="pre">sipIsErr</span></code> is not provided for destructors.</p>
</dd>
<dt><em>type</em> sipRes</dt>
<dd><p class="first">The handwritten code should set this to the result to be returned.  The
<em>type</em> of the variable is the same as the type defined in the Python
signature in the specification with the following exception:</p>
<ul class="simple">
<li>if the argument is a structure or class (or a reference or a pointer to a
structure or class) then <em>type</em> will always be a pointer to the structure
or class.</li>
</ul>
<p class="last"><code class="docutils literal"><span class="pre">sipRes</span></code> is not provided for inplace operators (e.g. <code class="docutils literal"><span class="pre">+=</span></code> or
<code class="xref py py-meth docutils literal"><span class="pre">__imul__()</span></code>) as their results are handled automatically, nor for class
constructors or destructors.</p>
</dd>
<dt>PyObject *sipSelf</dt>
<dd>If the directive is used in the context of a class constructor, destructor
or method then this is the Python object that wraps the structure or class
instance, i.e. <code class="docutils literal"><span class="pre">self</span></code>.</dd>
<dt>bool sipSelfWasArg</dt>
<dd><p class="first">This is only made available for non-abstract, virtual methods.  It is set
if <code class="docutils literal"><span class="pre">self</span></code> was explicitly passed as the first argument of the method
rather than being bound to the method.  In other words, the call was:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Klass</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>rather than:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p>If the <a class="reference internal" href="annotations.html#function-annotation-NoArgParser"><code class="xref std std-fanno docutils literal"><span class="pre">NoArgParser</span></code></a> annotation has been used then only the following
variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>PyObject *sipArgs</dt>
<dd>This is the tuple of arguments.</dd>
<dt>PyObject *sipKwds</dt>
<dd>This is the dictionary of keyword arguments.</dd>
</dl>
<p>The following is a complete example:</p>
<div class="highlight-python"><div class="highlight"><pre>class Klass
{
public:
    virtual int foo(SIP_PYTUPLE);
%MethodCode
        // The C++ API takes a 2 element array of integers but passing a
        // two element tuple is more Pythonic.

        int iarr[2];

        if (PyArg_ParseTuple(a0, &quot;ii&quot;, &amp;iarr[0], &amp;iarr[1]))
        {
            Py_BEGIN_ALLOW_THREADS
            sipRes = sipSelfWasArg ? sipCpp-&gt;Klass::foo(iarr)
                                   : sipCpp-&gt;foo(iarr);
            Py_END_ALLOW_THREADS
        }
        else
        {
            // PyArg_ParseTuple() will have raised the exception.
            sipIsErr = 1;
        }
%End
};
</pre></div>
</div>
<p>As the example is a virtual method <a class="footnote-reference" href="#id2" id="id1">[1]</a>, note the use of <code class="docutils literal"><span class="pre">sipSelfWasArg</span></code> to
determine exactly which implementation of <code class="docutils literal"><span class="pre">foo()</span></code> to call.</p>
<p>If a method is in the <code class="docutils literal"><span class="pre">protected</span></code> section of a C++ class then SIP generates
helpers that provide access to method.  However, these are not available if
the Python module is being built with <code class="docutils literal"><span class="pre">protected</span></code> redefined as <code class="docutils literal"><span class="pre">public</span></code>.</p>
<p>The following pattern should be used to cover all possibilities:</p>
<div class="highlight-python"><div class="highlight"><pre>#if defined(SIP_PROTECTED_IS_PUBLIC)
    sipRes = sipSelfWasArg ? sipCpp-&gt;Klass::foo(iarr)
                           : sipCpp-&gt;foo(iarr);
#else
    sipRes = sipCpp-&gt;sipProtectVirt_foo(sipSelfWasArg, iarr);
#endif
</pre></div>
</div>
<p>If a method is in the <code class="docutils literal"><span class="pre">protected</span></code> section of a C++ class but is not virtual
then the pattern should instead be:</p>
<div class="highlight-python"><div class="highlight"><pre>#if defined(SIP_PROTECTED_IS_PUBLIC)
    sipRes = sipCpp-&gt;foo(iarr);
#else
    sipRes = sipCpp-&gt;sipProtect_foo(iarr);
#endif
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>See <a class="reference internal" href="#directive-%VirtualCatcherCode"><code class="xref std std-directive docutils literal"><span class="pre">%VirtualCatcherCode</span></code></a> for a description of how SIP
generated code handles the reimplementation of C++ virtual methods in
Python.</td></tr>
</tbody>
</table>
<dl class="directive">
<dt id="directive-%Module">
<code class="descname">%Module</code><a class="headerlink" href="#directive-%Module" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%Module(name = <em>dotted-name</em>
        [, all_raise_py_exception = [True | False]]
        [, call_super_init = [True | False]]
        [, default_VirtualErrorHandler = <em>name</em>]
        [, keyword_arguments = [&quot;None&quot; | &quot;All&quot; | &quot;Optional&quot;]]
        [, language = <em>string</em>]
        [, use_argument_names = [True | False]]
        [, version = <em>integer</em>])
{
    [<a class="reference internal" href="#directive-%AutoPyName"><code class="xref std std-directive docutils literal"><span class="pre">%AutoPyName</span></code></a>]
    [<a class="reference internal" href="#directive-%Docstring"><code class="xref std std-directive docutils literal"><span class="pre">%Docstring</span></code></a>]
};
</pre>
<p>This directive is used to specify the name of a module and a number of other
attributes.  <code class="docutils literal"><span class="pre">name</span></code> may contain periods to specify that the module is part of
a Python package.</p>
<p><code class="docutils literal"><span class="pre">all_raise_py_exception</span></code> specifies that all constructors, functions and
methods defined in the module raise a Python exception to indicate that an
error occurred.  It is the equivalent of using the <a class="reference internal" href="annotations.html#function-annotation-RaisesPyException"><code class="xref std std-fanno docutils literal"><span class="pre">RaisesPyException</span></code></a>
function annotation on every constructor, function and method.</p>
<p><code class="docutils literal"><span class="pre">call_super_init</span></code> specifies that the <code class="docutils literal"><span class="pre">__init__()</span></code> method of a wrapped class
should automatically call it&#8217;s super-class&#8217;s <code class="docutils literal"><span class="pre">__init__()</span></code> method passing a
dictionary of any unused keyword arguments.  In other words, wrapped classes
support cooperative multi-inheritance.  This means that sub-classes, and any
mixin classes, should always use call <code class="docutils literal"><span class="pre">super().__init__()</span></code> and not call any
super-class&#8217;s <code class="docutils literal"><span class="pre">__init__()</span></code> method explicitly.</p>
<p><code class="docutils literal"><span class="pre">default_VirtualErrorHandler</span></code> specifies the handler (defined by the
<a class="reference internal" href="#directive-%VirtualErrorHandler"><code class="xref std std-directive docutils literal"><span class="pre">%VirtualErrorHandler</span></code></a> directive) that is called when a Python
re-implementation of any virtual C++ function raises a Python exception.  If no
handler is specified for a virtual C++ function then <code class="docutils literal"><span class="pre">PyErr_Print()</span></code> is
called.</p>
<p><code class="docutils literal"><span class="pre">keyword_arguments</span></code> specifies the default level of support for Python keyword
arguments.  See the <a class="reference internal" href="annotations.html#function-annotation-KeywordArgs"><code class="xref std std-fanno docutils literal"><span class="pre">KeywordArgs</span></code></a> annotation for an explaination of the
possible values and their effect.  If it is not specified then the value
implied by the (deprecated) <a class="reference internal" href="command_line.html#cmdoption-sip-k"><code class="xref std std-option docutils literal"><span class="pre">-k</span></code></a> command line option is used.</p>
<p><code class="docutils literal"><span class="pre">language</span></code> specifies the implementation language of the library being
wrapped.  Its value is either <code class="docutils literal"><span class="pre">&quot;C++&quot;</span></code> (the default) or <code class="docutils literal"><span class="pre">&quot;C&quot;</span></code>.</p>
<p>When providing handwritten code as part of either the <a class="reference internal" href="#directive-%MethodCode"><code class="xref std std-directive docutils literal"><span class="pre">%MethodCode</span></code></a>
or <a class="reference internal" href="#directive-%VirtualCatcherCode"><code class="xref std std-directive docutils literal"><span class="pre">%VirtualCatcherCode</span></code></a> directives the names of the arguments of
the function or method are based on the number of the argument, i.e. the first
argument is named <code class="docutils literal"><span class="pre">a0</span></code>, the second <code class="docutils literal"><span class="pre">a1</span></code> and so on.  <code class="docutils literal"><span class="pre">use_argument_names</span></code>
is set to specify that the real name of the argument, if any, should be used
instead.  It also affects the name of the variable created when the
<a class="reference internal" href="annotations.html#argument-annotation-GetWrapper"><code class="xref std std-aanno docutils literal"><span class="pre">GetWrapper</span></code></a> argument annotation is used.</p>
<p><code class="docutils literal"><span class="pre">version</span></code> is an optional version number that is useful if you (or others)
might create other modules that build on this module, i.e. if another module
might <a class="reference internal" href="#directive-%Import"><code class="xref std std-directive docutils literal"><span class="pre">%Import</span></code></a> this module.  Under the covers, a module exports an
API that is used by modules that <a class="reference internal" href="#directive-%Import"><code class="xref std std-directive docutils literal"><span class="pre">%Import</span></code></a> it and the API is given a
version number.  A module built on that module knows the version number of the
API that it is expecting.  If, when the modules are imported at run-time, the
version numbers do not match then a Python exception is raised.  The dependent
module must then be re-built using the correct specification files for the base
module.</p>
<p>The optional <a class="reference internal" href="#directive-%AutoPyName"><code class="xref std std-directive docutils literal"><span class="pre">%AutoPyName</span></code></a> sub-directive is used to specify a rule
for automatically providing Python names.</p>
<p>The optional <a class="reference internal" href="#directive-%Docstring"><code class="xref std std-directive docutils literal"><span class="pre">%Docstring</span></code></a> sub-directive is used to specify the
module&#8217;s docstring.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Module(name=PyQt4.QtCore, version=5)
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%ModuleCode">
<code class="descname">%ModuleCode</code><a class="headerlink" href="#directive-%ModuleCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%ModuleCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code, typically the
implementations of utility functions, that can be called by other handwritten
code in the module.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%ModuleCode
// Print an object on stderr for debugging purposes.
void dump_object(PyObject *o)
{
    PyObject_Print(o, stderr, 0);
    fprintf(stderr, &quot;\n&quot;);
}
%End
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#directive-%ExportedHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%ExportedHeaderCode</span></code></a>, <a class="reference internal" href="#directive-%ModuleHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%ModuleHeaderCode</span></code></a></p>
</div>
<dl class="directive">
<dt id="directive-%ModuleHeaderCode">
<code class="descname">%ModuleHeaderCode</code><a class="headerlink" href="#directive-%ModuleHeaderCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%ModuleHeaderCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code, typically the declarations
of utility functions, that is placed in a header file that is included by all
generated code for the same module.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%ModuleHeaderCode
void dump_object(PyObject *o);
%End
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#directive-%ExportedHeaderCode"><code class="xref std std-directive docutils literal"><span class="pre">%ExportedHeaderCode</span></code></a>, <a class="reference internal" href="#directive-%ModuleCode"><code class="xref std std-directive docutils literal"><span class="pre">%ModuleCode</span></code></a></p>
</div>
<dl class="directive">
<dt id="directive-%OptionalInclude">
<code class="descname">%OptionalInclude</code><a class="headerlink" href="#directive-%OptionalInclude" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%OptionalInclude <em>filename</em>
</pre>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 4.12: </span>Use the <a class="reference internal" href="#directive-%Include"><code class="xref std std-directive docutils literal"><span class="pre">%Include</span></code></a> directive with the <code class="docutils literal"><span class="pre">optional</span></code> argument set
to <code class="docutils literal"><span class="pre">True</span></code> instead.</p>
</div>
<p>This directive is identical to the <a class="reference internal" href="#directive-%Include"><code class="xref std std-directive docutils literal"><span class="pre">%Include</span></code></a> directive except that
SIP silently continues processing if <em>filename</em> could not be opened.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%OptionalInclude license.sip
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%PickleCode">
<code class="descname">%PickleCode</code><a class="headerlink" href="#directive-%PickleCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%PickleCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code to pickle a C structure or
C++ class instance.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>PyObject *sipRes</dt>
<dd>The handwritten code must set this to a tuple of the arguments that will
be passed to the type&#8217;s <code class="docutils literal"><span class="pre">__init__()</span></code> method when the structure or class
instance is unpickled.  If there is an error then the code must raise an
exception and set this to <code class="docutils literal"><span class="pre">NULL</span></code>.</dd>
</dl>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>class Point
{
    Point(int x, y);

    int x() const;
    int y() const;

%PickleCode
    sipRes = Py_BuildValue(&quot;ii&quot;, sipCpp-&gt;x(), sipCpp-&gt;y());
%End
}
</pre></div>
</div>
<p>Note that SIP works around the Python limitation that prevents nested types
being pickled.</p>
<p>Both named and unnamed enums can be pickled automatically without providing any
handwritten code.</p>
<dl class="directive">
<dt id="directive-%Platforms">
<code class="descname">%Platforms</code><a class="headerlink" href="#directive-%Platforms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%Platforms {<em>name</em> <em>name</em> ...}
</pre>
<p>This directive is used to declare a set of platforms.  Platforms (along with
<a class="reference internal" href="#directive-%Feature"><code class="xref std std-directive docutils literal"><span class="pre">%Feature</span></code></a> and <a class="reference internal" href="#directive-%Timeline"><code class="xref std std-directive docutils literal"><span class="pre">%Timeline</span></code></a>) are used by the
<a class="reference internal" href="#directive-%If"><code class="xref std std-directive docutils literal"><span class="pre">%If</span></code></a> directive to control whether or not parts of a specification
are processed or ignored.</p>
<p>Platforms are mutually exclusive - only one platform can be enabled at a time.
By default all platforms are disabled.  The SIP <a class="reference internal" href="command_line.html#cmdoption-sip-t"><code class="xref std std-option docutils literal"><span class="pre">-t</span></code></a> command
line option is used to enable a platform.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.14.</span></p>
</div>
<p>If a platform is enabled then SIP will automatically generate a corresponding C
preprocessor symbol for use by handwritten code.  The symbol is the name of
the platform prefixed by <code class="docutils literal"><span class="pre">SIP_PLATFORM_</span></code>.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Platforms {WIN32_PLATFORM POSIX_PLATFORM MACOS_PLATFORM}

%If (WIN32_PLATFORM)
void undocumented();
%End

%If (POSIX_PLATFORM)
void documented();
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%PostInitialisationCode">
<code class="descname">%PostInitialisationCode</code><a class="headerlink" href="#directive-%PostInitialisationCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%PostInitialisationCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that is embedded in-line
at the very end of the generated module initialisation code.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>PyObject *sipModule</dt>
<dd>This is the module object returned by <code class="docutils literal"><span class="pre">Py_InitModule()</span></code>.</dd>
<dt>PyObject *sipModuleDict</dt>
<dd>This is the module&#8217;s dictionary object returned by <code class="docutils literal"><span class="pre">Py_ModuleGetDict()</span></code>.</dd>
</dl>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%PostInitialisationCode
    // The code will be executed when the module is first imported and
    // after all other initialisation has been completed.
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%PreInitialisationCode">
<code class="descname">%PreInitialisationCode</code><a class="headerlink" href="#directive-%PreInitialisationCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%PreInitialisationCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that is embedded in-line
at the very start of the generated module initialisation code.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%PreInitialisationCode
    // The code will be executed when the module is first imported and
    // before other initialisation has been completed.
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%Property">
<code class="descname">%Property</code><a class="headerlink" href="#directive-%Property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.12.</span></p>
</div>
<pre class="literal-block">
%Property(name = <em>name</em>, get = <em>name</em> [, set = <em>name</em>])
{
    [<a class="reference internal" href="#directive-%Docstring"><code class="xref std std-directive docutils literal"><span class="pre">%Docstring</span></code></a>]
};
</pre>
<p>This directive is used to define a Python property.  <code class="docutils literal"><span class="pre">name</span></code> is the name of
the property.</p>
<p><code class="docutils literal"><span class="pre">get</span></code> is the Python name of the getter method and must refer to a method in
the same class.</p>
<p><code class="docutils literal"><span class="pre">set</span></code> is the Python name of the optional setter method and must refer to a
method in the same class.</p>
<p>The optional <a class="reference internal" href="#directive-%Docstring"><code class="xref std std-directive docutils literal"><span class="pre">%Docstring</span></code></a> sub-directive is used to specify the
property&#8217;s docstring.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>class Klass
{
public:
    int get_count() const;
    void set_count();

    %Property(name=count, get=get_count, set=set_count)
};
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%RaiseCode">
<code class="descname">%RaiseCode</code><a class="headerlink" href="#directive-%RaiseCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%RaiseCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the definition of an exception using the
<a class="reference internal" href="#directive-%Exception"><code class="xref std std-directive docutils literal"><span class="pre">%Exception</span></code></a> directive to specify handwritten code that raises a
Python exception when a C++ exception has been caught.  The code is embedded
in-line as the body of a C++ <code class="docutils literal"><span class="pre">catch</span> <span class="pre">()</span></code> clause.</p>
<p>The specified code must handle the Python Global Interpreter Lock (GIL) if
necessary.  The GIL must be acquired before any calls to the Python API and
released after the last call as shown in this example fragment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SIP_BLOCK_THREADS</span>
<span class="n">PyErr_SetNone</span><span class="p">(</span><span class="n">PyErr_Exception</span><span class="p">);</span>
<span class="n">SIP_UNBLOCK_THREADS</span>
</pre></div>
</div>
<p>Finally, the specified code must not include any <code class="docutils literal"><span class="pre">return</span></code> statements.</p>
<p>The following variable is made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> &amp;sipExceptionRef</dt>
<dd>This is a reference to the caught C++ exception.  The <em>type</em> of the
reference is the same as the type defined in the <code class="docutils literal"><span class="pre">throw</span> <span class="pre">()</span></code> specifier.</dd>
</dl>
<p>See the <a class="reference internal" href="#directive-%Exception"><code class="xref std std-directive docutils literal"><span class="pre">%Exception</span></code></a> directive for an example.</p>
<dl class="directive">
<dt id="directive-%SetCode">
<code class="descname">%SetCode</code><a class="headerlink" href="#directive-%SetCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%SetCode
    <em>code</em>
%End
</pre>
<p>This sub-directive is used in the declaration of a C++ class variable or C
structure member to specify handwritten code to convert it from a Python
object.  It is usually used to handle types that SIP cannot deal with
automatically.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.  It is not made available if the
variable being wrapped is a static class variable.</dd>
<dt>int sipErr</dt>
<dd>If the conversion failed then the handwritten code should raise a Python
exception and set this to a non-zero value.  Its initial value will be
automatically set to zero.</dd>
<dt>PyObject *sipPy</dt>
<dd>This is the Python object that the handwritten code should convert.</dd>
<dt>PyObject *sipPyType</dt>
<dd>If the variable being wrapped is a static class variable then this is the
Python type object of the class from which the variable was referenced
(<em>not</em> the class in which it is defined).  It may be safely cast to a
PyTypeObject * or a sipWrapperType *.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#directive-%AccessCode"><code class="xref std std-directive docutils literal"><span class="pre">%AccessCode</span></code></a>, <a class="reference internal" href="#directive-%GetCode"><code class="xref std std-directive docutils literal"><span class="pre">%GetCode</span></code></a></p>
</div>
<dl class="directive">
<dt id="directive-%Timeline">
<code class="descname">%Timeline</code><a class="headerlink" href="#directive-%Timeline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%Timeline {<em>name</em> <em>name</em> ...}
</pre>
<p>This directive is used to declare a set of versions released over a period of
time.  Versions (along with <a class="reference internal" href="#directive-%Feature"><code class="xref std std-directive docutils literal"><span class="pre">%Feature</span></code></a> and <a class="reference internal" href="#directive-%Platforms"><code class="xref std std-directive docutils literal"><span class="pre">%Platforms</span></code></a>)
are used by the <a class="reference internal" href="#directive-%If"><code class="xref std std-directive docutils literal"><span class="pre">%If</span></code></a> directive to control whether or not parts of a
specification are processed or ignored.</p>
<p>Versions are mutually exclusive - only one version can be enabled at a time.
The SIP <a class="reference internal" href="command_line.html#cmdoption-sip-t"><code class="xref std std-option docutils literal"><span class="pre">-t</span></code></a> command line option is used to enable a version.
If a timeline does not have a version explicitly enabled then the latest
version will be enabled automatically.</p>
<p>The <a class="reference internal" href="command_line.html#cmdoption-sip-B"><code class="xref std std-option docutils literal"><span class="pre">-B</span></code></a> command line option may be used to define a
<em>backstop</em> for a timeline.  Instead of automatically enabling the latest
version, the version immediately preceeding the backstop is enabled instead.</p>
<p>The <a class="reference internal" href="#directive-%Timeline"><code class="xref std std-directive docutils literal"><span class="pre">%Timeline</span></code></a> directive can be used any number of times in a
module to allow multiple libraries to be wrapped in the same module.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.12.</span></p>
</div>
<p>SIP automatically defines a timeline containing all versions of SIP since
v4.12.  The name of the version is <code class="docutils literal"><span class="pre">SIP_</span></code> followed by the individual parts of
the version number separated by an underscore.  SIP v4.12 is therefore
<code class="docutils literal"><span class="pre">SIP_4_12</span></code> and SIP v4.13.2 is <code class="docutils literal"><span class="pre">SIP_4_13_2</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.14.</span></p>
</div>
<p>If a particular version is enabled then SIP will automatically generate a
corresponding C preprocessor symbol for use by handwritten code.  The symbol is
the name of the version prefixed by <code class="docutils literal"><span class="pre">SIP_TIMELINE_</span></code>.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%Timeline {V1_0 V1_1 V2_0 V3_0}

%If (V1_0 - V2_0)
void foo();
%End

%If (V2_0 -)
void foo(int = 0);
%End

%If (- SIP_4_13)
void bar();
%End
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%TypeCode">
<code class="descname">%TypeCode</code><a class="headerlink" href="#directive-%TypeCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%TypeCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the specification of a C structure, a C++
class or a <a class="reference internal" href="#directive-%MappedType"><code class="xref std std-directive docutils literal"><span class="pre">%MappedType</span></code></a> directive to specify handwritten code,
typically the implementations of utility functions, that can be called by other
handwritten code in the structure or class.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>class Klass
{
%TypeCode
// Print an instance on stderr for debugging purposes.
static void dump_klass(const Klass *k)
{
    fprintf(stderr,&quot;Klass %s at %p\n&quot;, k-&gt;name(), k);
}
%End

    // The rest of the class specification.

};
</pre></div>
</div>
<p>Because the scope of the code is normally within the generated file that
implements the type, any utility functions would normally be declared
<code class="docutils literal"><span class="pre">static</span></code>.  However a naming convention should still be adopted to prevent
clashes of function names within a module in case the SIP <code class="docutils literal"><span class="pre">-j</span></code> command line
option is used.</p>
<dl class="directive">
<dt id="directive-%TypeHeaderCode">
<code class="descname">%TypeHeaderCode</code><a class="headerlink" href="#directive-%TypeHeaderCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%TypeHeaderCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that defines the interface
to a C or C++ type being wrapped, either a structure, a class, or a template.
It is used within a class definition or a <a class="reference internal" href="#directive-%MappedType"><code class="xref std std-directive docutils literal"><span class="pre">%MappedType</span></code></a> directive.</p>
<p>Normally <em>code</em> will be a pre-processor <code class="docutils literal"><span class="pre">#include</span></code> statement.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>// Wrap the Klass class.
class Klass
{
%TypeHeaderCode
#include &lt;klass.h&gt;
%End

    // The rest of the class specification.
};
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%UnitCode">
<code class="descname">%UnitCode</code><a class="headerlink" href="#directive-%UnitCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%UnitCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that is included at the very
start of a generated compilation unit (ie. C or C++ source file).  It is
typically used to <code class="docutils literal"><span class="pre">#include</span></code> a C++ precompiled header file.</p>
<dl class="directive">
<dt id="directive-%UnitPostIncludeCode">
<code class="descname">%UnitPostIncludeCode</code><a class="headerlink" href="#directive-%UnitPostIncludeCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.11.</span></p>
</div>
<pre class="literal-block">
%UnitPostIncludeCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that is included following
the <code class="docutils literal"><span class="pre">#include</span></code> of all header files in a generated compilation unit (ie. C or
C++ source file).</p>
<dl class="directive">
<dt id="directive-%VirtualCallCode">
<code class="descname">%VirtualCallCode</code><a class="headerlink" href="#directive-%VirtualCallCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.16.7.</span></p>
</div>
<pre class="literal-block">
%VirtualCallCode
    <em>code</em>
%End
</pre>
<p>For most classes there are corresponding <a class="reference internal" href="c_api.html#ref-derived-classes"><span>generated derived classes</span></a> that contain reimplementations of the class&#8217;s virtual
methods.  These methods (which SIP calls catchers) determine if there is a
corresponding Python reimplementation and call it if so.  If there is no Python
reimplementation then the method in the original class is called instead.</p>
<p>This directive is used to specify handwritten code that replaces the normally
generated call to the original class method if there is no Python
reimplementation.</p>
<p>The following variables are made available to the handwritten code in the
context of a method:</p>
<dl class="docutils">
<dt><em>type</em> a0</dt>
<dd>There is a variable for each argument of the C++ signature named <code class="docutils literal"><span class="pre">a0</span></code>,
<code class="docutils literal"><span class="pre">a1</span></code>, etc.  If <code class="docutils literal"><span class="pre">use_argument_names</span></code> has been set in the
<a class="reference internal" href="#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a> directive then the name of the argument is the real
name.  The <em>type</em> of the variable is the same as the type defined in the
specification.</dd>
<dt><em>type</em> sipRes</dt>
<dd>The handwritten code should set this to any result to be returned.  The
<em>type</em> of the variable is the same as the type defined in the C++ signature
in the specification.</dd>
</dl>
<dl class="directive">
<dt id="directive-%VirtualCatcherCode">
<code class="descname">%VirtualCatcherCode</code><a class="headerlink" href="#directive-%VirtualCatcherCode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<pre class="literal-block">
%VirtualCatcherCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that replaces the normally
generated call to the Python reimplementation of a virtual method and the
handling of any returned results.  It is usually used to handle argument types
and results that SIP cannot deal with automatically.</p>
<p>This directive can also be used in the context of a class destructor to
specify handwritten code that is embedded in-line in the internal derived
class&#8217;s destructor.</p>
<p>In the context of a method the Python Global Interpreter Lock (GIL) is
automatically acquired before the specified code is executed and automatically
released afterwards.</p>
<p>In the context of a destructor the specified code must handle the GIL.  The
GIL must be acquired before any calls to the Python API and released after the
last call as shown in this example fragment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SIP_BLOCK_THREADS</span>
<span class="n">Py_DECREF</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="n">SIP_UNBLOCK_THREADS</span>
</pre></div>
</div>
<p>The following variables are made available to the handwritten code in the
context of a method:</p>
<dl class="docutils">
<dt><em>type</em> a0</dt>
<dd>There is a variable for each argument of the C++ signature named <code class="docutils literal"><span class="pre">a0</span></code>,
<code class="docutils literal"><span class="pre">a1</span></code>, etc.  If <code class="docutils literal"><span class="pre">use_argument_names</span></code> has been set in the
<a class="reference internal" href="#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a> directive then the name of the argument is the real
name.  The <em>type</em> of the variable is the same as the type defined in the
specification.</dd>
<dt>int a0Key</dt>
<dd><p class="first">There is a variable for each argument of the C++ signature that has a type
where it is important to ensure that the corresponding Python object is not
garbage collected too soon.  This only applies to output arguments that
return <code class="docutils literal"><span class="pre">'\0'</span></code> terminated strings.  The variable would normally be passed
to <a class="reference internal" href="c_api.html#c.sipParseResult" title="sipParseResult"><code class="xref c c-func docutils literal"><span class="pre">sipParseResult()</span></code></a> using either the <code class="docutils literal"><span class="pre">A</span></code> or <code class="docutils literal"><span class="pre">B</span></code> format
characters.</p>
<p class="last">If <code class="docutils literal"><span class="pre">use_argument_names</span></code> has been set in the <a class="reference internal" href="#directive-%Module"><code class="xref std std-directive docutils literal"><span class="pre">%Module</span></code></a>
directive then the name of the variable is the real name of the argument
with <code class="docutils literal"><span class="pre">Key</span></code> appended.</p>
</dd>
<dt>int sipIsErr</dt>
<dd>The handwritten code should set this to a non-zero value, and raise an
appropriate Python exception, if an error is detected.</dd>
<dt>PyObject *sipMethod</dt>
<dd>This object is the Python reimplementation of the virtual C++ method.  It
is normally passed to <a class="reference internal" href="c_api.html#c.sipCallMethod" title="sipCallMethod"><code class="xref c c-func docutils literal"><span class="pre">sipCallMethod()</span></code></a>.</dd>
<dt><em>type</em> sipRes</dt>
<dd>The handwritten code should set this to any result to be returned.  The
<em>type</em> of the variable is the same as the type defined in the C++ signature
in the specification.</dd>
<dt>int sipResKey</dt>
<dd>This variable is only made available if the result has a type where it is
important to ensure that the corresponding Python object is not garbage
collected too soon.  This only applies to <code class="docutils literal"><span class="pre">'\0'</span></code> terminated strings.  The
variable would normally be passed to <a class="reference internal" href="c_api.html#c.sipParseResult" title="sipParseResult"><code class="xref c c-func docutils literal"><span class="pre">sipParseResult()</span></code></a> using
either the <code class="docutils literal"><span class="pre">A</span></code> or <code class="docutils literal"><span class="pre">B</span></code> format characters.</dd>
<dt>sipSimpleWrapper *sipPySelf</dt>
<dd>This variable is only made available if either the <code class="docutils literal"><span class="pre">a0Key</span></code> or
<code class="docutils literal"><span class="pre">sipResKey</span></code> are made available.  It defines the context within which keys
are unique.  The variable would normally be passed to
<a class="reference internal" href="c_api.html#c.sipParseResult" title="sipParseResult"><code class="xref c c-func docutils literal"><span class="pre">sipParseResult()</span></code></a> using the <code class="docutils literal"><span class="pre">S</span></code> format character.</dd>
</dl>
<p>No variables are made available in the context of a destructor.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>class Klass
{
public:
    virtual int foo(SIP_PYTUPLE) [int (int *)];
%MethodCode
        // The C++ API takes a 2 element array of integers but passing a
        // two element tuple is more Pythonic.

        int iarr[2];

        if (PyArg_ParseTuple(a0, &quot;ii&quot;, &amp;iarr[0], &amp;iarr[1]))
        {
            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp-&gt;Klass::foo(iarr);
            Py_END_ALLOW_THREADS
        }
        else
        {
            // PyArg_ParseTuple() will have raised the exception.
            sipIsErr = 1;
        }
%End
%VirtualCatcherCode
        // Convert the 2 element array of integers to the two element
        // tuple.

        PyObject *result;

        result = sipCallMethod(&amp;sipIsErr, sipMethod, &quot;ii&quot;, a0[0], a0[1]);

        if (result != NULL)
        {
            // Convert the result to the C++ type.
            sipParseResult(&amp;sipIsErr, sipMethod, result, &quot;i&quot;, &amp;sipRes);

            Py_DECREF(result);
        }
%End
};
</pre></div>
</div>
<dl class="directive">
<dt id="directive-%VirtualErrorHandler">
<code class="descname">%VirtualErrorHandler</code><a class="headerlink" href="#directive-%VirtualErrorHandler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 4.14.</span></p>
</div>
<pre class="literal-block">
%VirtualErrorHandler(name = <em>name</em>)
    <em>code</em>
%End
</pre>
<p>This directive is used to define the handwritten code that implements a handler
that is called when a Python re-implementation of a virtual C++ function raises
a Python exception.  If a virtual C++ function does not have a handler the
<code class="docutils literal"><span class="pre">PyErr_Print()</span></code> function is called.</p>
<p>The handler is called after all tidying up has been completed, with the Python
Global Interpreter Lock (GIL) held and from the thread that raised the
exception.  If the handler wants to change the execution path by, for example,
throwing a C++ exception, it must first release the GIL by calling
<a class="reference internal" href="c_api.html#c.SIP_RELEASE_GIL" title="SIP_RELEASE_GIL"><code class="xref c c-func docutils literal"><span class="pre">SIP_RELEASE_GIL()</span></code></a>.  It must not call <a class="reference internal" href="c_api.html#c.SIP_RELEASE_GIL" title="SIP_RELEASE_GIL"><code class="xref c c-func docutils literal"><span class="pre">SIP_RELEASE_GIL()</span></code></a> if the
execution path is not changed.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>sipSimpleWrapper *sipPySelf</dt>
<dd>This is the class instance containing the Python reimplementation.</dd>
<dt>sip_gilstate_t sipGILState</dt>
<dd>This is an opaque value that must be passed to <a class="reference internal" href="c_api.html#c.SIP_RELEASE_GIL" title="SIP_RELEASE_GIL"><code class="xref c c-func docutils literal"><span class="pre">SIP_RELEASE_GIL()</span></code></a> in
order to release the GIL prior to changing the execution path.</dd>
</dl>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>%VirtualErrorHandler my_handler
    PyObject *exception, *value, *traceback;

    PyErr_Fetch(&amp;exception, &amp;value, &amp;traceback);

    SIP_RELEASE_GIL(sipGILState);

    throw my_exception(sipPySelf, exception, value, traceback);
%End
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="annotations.html#function-annotation-NoVirtualErrorHandler"><code class="xref std std-fanno docutils literal"><span class="pre">NoVirtualErrorHandler</span></code></a>, <a class="reference internal" href="annotations.html#function-annotation-VirtualErrorHandler"><code class="xref std std-fanno docutils literal"><span class="pre">VirtualErrorHandler</span></code></a>, <a class="reference internal" href="annotations.html#class-annotation-VirtualErrorHandler"><code class="xref std std-canno docutils literal"><span class="pre">VirtualErrorHandler</span></code></a></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Directives</a><ul>
<li><a class="reference internal" href="#revised-directive-syntax">Revised Directive Syntax</a></li>
<li><a class="reference internal" href="#list-of-directives">List of Directives</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="specification_files.html"
                        title="previous chapter">SIP Specification Files</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="annotations.html"
                        title="next chapter">Annotations</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="annotations.html" title="Annotations"
             >next</a> |</li>
        <li class="right" >
          <a href="specification_files.html" title="SIP Specification Files"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SIP 4.16.7 Reference Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015 Riverbank Computing Limited.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>