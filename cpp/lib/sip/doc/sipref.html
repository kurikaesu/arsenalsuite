<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>SIP - A Tool for Generating Python Bindings for C and C++ Libraries</title>
<meta name="copyright" content="Copyright (c) 2009 Riverbank Computing Limited" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="sip-a-tool-for-generating-python-bindings-for-c-and-c-libraries">
<h1 class="title">SIP - A Tool for Generating Python Bindings for C and C++ Libraries</h1>
<h2 class="subtitle" id="reference-guide">Reference Guide</h2>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:info&#64;riverbankcomputing.com">info&#64;riverbankcomputing.com</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>4.8-snapshot-20090409</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>Copyright (c) 2009 Riverbank Computing Limited</td></tr>
</tbody>
</table>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id25" name="id25">1&nbsp;&nbsp;&nbsp;Introduction</a><ul class="auto-toc">
<li><a class="reference" href="#license" id="id26" name="id26">1.1&nbsp;&nbsp;&nbsp;License</a></li>
<li><a class="reference" href="#features" id="id27" name="id27">1.2&nbsp;&nbsp;&nbsp;Features</a></li>
<li><a class="reference" href="#sip-components" id="id28" name="id28">1.3&nbsp;&nbsp;&nbsp;SIP Components</a></li>
<li><a class="reference" href="#qt-support" id="id29" name="id29">1.4&nbsp;&nbsp;&nbsp;Qt Support</a></li>
</ul>
</li>
<li><a class="reference" href="#potential-incompatibilities-with-earlier-versions" id="id30" name="id30">2&nbsp;&nbsp;&nbsp;Potential Incompatibilities with Earlier Versions</a><ul class="auto-toc">
<li><a class="reference" href="#sip-v4-8" id="id31" name="id31">2.1&nbsp;&nbsp;&nbsp;SIP v4.8</a></li>
<li><a class="reference" href="#sip-v4-7-8" id="id32" name="id32">2.2&nbsp;&nbsp;&nbsp;SIP v4.7.8</a></li>
<li><a class="reference" href="#sip-v4-7-3" id="id33" name="id33">2.3&nbsp;&nbsp;&nbsp;SIP v4.7.3</a></li>
<li><a class="reference" href="#sip-v4-4" id="id34" name="id34">2.4&nbsp;&nbsp;&nbsp;SIP v4.4</a></li>
</ul>
</li>
<li><a class="reference" href="#installing-sip" id="id35" name="id35">3&nbsp;&nbsp;&nbsp;Installing SIP</a><ul class="auto-toc">
<li><a class="reference" href="#downloading-sip" id="id36" name="id36">3.1&nbsp;&nbsp;&nbsp;Downloading SIP</a></li>
<li><a class="reference" href="#configuring-sip" id="id37" name="id37">3.2&nbsp;&nbsp;&nbsp;Configuring SIP</a><ul class="auto-toc">
<li><a class="reference" href="#configuring-sip-using-mingw" id="id38" name="id38">3.2.1&nbsp;&nbsp;&nbsp;Configuring SIP Using MinGW</a></li>
<li><a class="reference" href="#configuring-sip-using-the-borland-c-compiler" id="id39" name="id39">3.2.2&nbsp;&nbsp;&nbsp;Configuring SIP Using the Borland C++ Compiler</a></li>
</ul>
</li>
<li><a class="reference" href="#building-sip" id="id40" name="id40">3.3&nbsp;&nbsp;&nbsp;Building SIP</a></li>
</ul>
</li>
<li><a class="reference" href="#using-sip" id="id41" name="id41">4&nbsp;&nbsp;&nbsp;Using SIP</a><ul class="auto-toc">
<li><a class="reference" href="#a-simple-c-example" id="id42" name="id42">4.1&nbsp;&nbsp;&nbsp;A Simple C++ Example</a></li>
<li><a class="reference" href="#id7" id="id43" name="id43">4.2&nbsp;&nbsp;&nbsp;A Simple C Example</a></li>
<li><a class="reference" href="#a-more-complex-c-example" id="id44" name="id44">4.3&nbsp;&nbsp;&nbsp;A More Complex C++ Example</a></li>
<li><a class="reference" href="#ownership-of-objects" id="id45" name="id45">4.4&nbsp;&nbsp;&nbsp;Ownership of Objects</a></li>
<li><a class="reference" href="#types-and-meta-types" id="id46" name="id46">4.5&nbsp;&nbsp;&nbsp;Types and Meta-types</a></li>
<li><a class="reference" href="#lazy-type-attributes" id="id47" name="id47">4.6&nbsp;&nbsp;&nbsp;Lazy Type Attributes</a></li>
<li><a class="reference" href="#support-for-python-s-buffer-interface" id="id48" name="id48">4.7&nbsp;&nbsp;&nbsp;Support for Python's Buffer Interface</a></li>
<li><a class="reference" href="#support-for-wide-characters" id="id49" name="id49">4.8&nbsp;&nbsp;&nbsp;Support for Wide Characters</a></li>
<li><a class="reference" href="#the-python-global-interpreter-lock" id="id50" name="id50">4.9&nbsp;&nbsp;&nbsp;The Python Global Interpreter Lock</a></li>
</ul>
</li>
<li><a class="reference" href="#the-sip-command-line" id="id51" name="id51">5&nbsp;&nbsp;&nbsp;The SIP Command Line</a></li>
<li><a class="reference" href="#sip-specification-files" id="id52" name="id52">6&nbsp;&nbsp;&nbsp;SIP Specification Files</a><ul class="auto-toc">
<li><a class="reference" href="#syntax-definition" id="id53" name="id53">6.1&nbsp;&nbsp;&nbsp;Syntax Definition</a></li>
<li><a class="reference" href="#variable-numbers-of-arguments" id="id54" name="id54">6.2&nbsp;&nbsp;&nbsp;Variable Numbers of Arguments</a></li>
<li><a class="reference" href="#additional-sip-types" id="id55" name="id55">6.3&nbsp;&nbsp;&nbsp;Additional SIP Types</a><ul class="auto-toc">
<li><a class="reference" href="#sip-anyslot" id="id56" name="id56">6.3.1&nbsp;&nbsp;&nbsp;SIP_ANYSLOT</a></li>
<li><a class="reference" href="#sip-pycallable" id="id57" name="id57">6.3.2&nbsp;&nbsp;&nbsp;SIP_PYCALLABLE</a></li>
<li><a class="reference" href="#sip-pydict" id="id58" name="id58">6.3.3&nbsp;&nbsp;&nbsp;SIP_PYDICT</a></li>
<li><a class="reference" href="#sip-pylist" id="id59" name="id59">6.3.4&nbsp;&nbsp;&nbsp;SIP_PYLIST</a></li>
<li><a class="reference" href="#sip-pyobject" id="id60" name="id60">6.3.5&nbsp;&nbsp;&nbsp;SIP_PYOBJECT</a></li>
<li><a class="reference" href="#sip-pyslice" id="id61" name="id61">6.3.6&nbsp;&nbsp;&nbsp;SIP_PYSLICE</a></li>
<li><a class="reference" href="#sip-pytuple" id="id62" name="id62">6.3.7&nbsp;&nbsp;&nbsp;SIP_PYTUPLE</a></li>
<li><a class="reference" href="#sip-pytype" id="id63" name="id63">6.3.8&nbsp;&nbsp;&nbsp;SIP_PYTYPE</a></li>
<li><a class="reference" href="#sip-qobject" id="id64" name="id64">6.3.9&nbsp;&nbsp;&nbsp;SIP_QOBJECT</a></li>
<li><a class="reference" href="#sip-rxobj-con" id="id65" name="id65">6.3.10&nbsp;&nbsp;&nbsp;SIP_RXOBJ_CON</a></li>
<li><a class="reference" href="#sip-rxobj-dis" id="id66" name="id66">6.3.11&nbsp;&nbsp;&nbsp;SIP_RXOBJ_DIS</a></li>
<li><a class="reference" href="#sip-signal" id="id67" name="id67">6.3.12&nbsp;&nbsp;&nbsp;SIP_SIGNAL</a></li>
<li><a class="reference" href="#sip-slot" id="id68" name="id68">6.3.13&nbsp;&nbsp;&nbsp;SIP_SLOT</a></li>
<li><a class="reference" href="#sip-slot-con" id="id69" name="id69">6.3.14&nbsp;&nbsp;&nbsp;SIP_SLOT_CON</a></li>
<li><a class="reference" href="#sip-slot-dis" id="id70" name="id70">6.3.15&nbsp;&nbsp;&nbsp;SIP_SLOT_DIS</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#sip-directives" id="id71" name="id71">7&nbsp;&nbsp;&nbsp;SIP Directives</a><ul class="auto-toc">
<li><a class="reference" href="#accesscode" id="id72" name="id72">7.1&nbsp;&nbsp;&nbsp;%AccessCode</a></li>
<li><a class="reference" href="#bigetbuffercode" id="id73" name="id73">7.2&nbsp;&nbsp;&nbsp;%BIGetBufferCode</a></li>
<li><a class="reference" href="#bigetcharbuffercode" id="id74" name="id74">7.3&nbsp;&nbsp;&nbsp;%BIGetCharBufferCode</a></li>
<li><a class="reference" href="#bigetreadbuffercode" id="id75" name="id75">7.4&nbsp;&nbsp;&nbsp;%BIGetReadBufferCode</a></li>
<li><a class="reference" href="#bigetsegcountcode" id="id76" name="id76">7.5&nbsp;&nbsp;&nbsp;%BIGetSegCountCode</a></li>
<li><a class="reference" href="#bigetwritebuffercode" id="id77" name="id77">7.6&nbsp;&nbsp;&nbsp;%BIGetWriteBufferCode</a></li>
<li><a class="reference" href="#bireleasebuffercode" id="id78" name="id78">7.7&nbsp;&nbsp;&nbsp;%BIReleaseBufferCode</a></li>
<li><a class="reference" href="#cmodule" id="id79" name="id79">7.8&nbsp;&nbsp;&nbsp;%CModule</a></li>
<li><a class="reference" href="#compositemodule" id="id80" name="id80">7.9&nbsp;&nbsp;&nbsp;%CompositeModule</a></li>
<li><a class="reference" href="#consolidatedmodule" id="id81" name="id81">7.10&nbsp;&nbsp;&nbsp;%ConsolidatedModule</a></li>
<li><a class="reference" href="#convertfromtypecode" id="id82" name="id82">7.11&nbsp;&nbsp;&nbsp;%ConvertFromTypeCode</a></li>
<li><a class="reference" href="#converttosubclasscode" id="id83" name="id83">7.12&nbsp;&nbsp;&nbsp;%ConvertToSubClassCode</a></li>
<li><a class="reference" href="#converttotypecode" id="id84" name="id84">7.13&nbsp;&nbsp;&nbsp;%ConvertToTypeCode</a></li>
<li><a class="reference" href="#copying" id="id85" name="id85">7.14&nbsp;&nbsp;&nbsp;%Copying</a></li>
<li><a class="reference" href="#defaultencoding" id="id86" name="id86">7.15&nbsp;&nbsp;&nbsp;%DefaultEncoding</a></li>
<li><a class="reference" href="#defaultmetatype" id="id87" name="id87">7.16&nbsp;&nbsp;&nbsp;%DefaultMetatype</a></li>
<li><a class="reference" href="#defaultsupertype" id="id88" name="id88">7.17&nbsp;&nbsp;&nbsp;%DefaultSupertype</a></li>
<li><a class="reference" href="#doc" id="id89" name="id89">7.18&nbsp;&nbsp;&nbsp;%Doc</a></li>
<li><a class="reference" href="#end" id="id90" name="id90">7.19&nbsp;&nbsp;&nbsp;%End</a></li>
<li><a class="reference" href="#exception" id="id91" name="id91">7.20&nbsp;&nbsp;&nbsp;%Exception</a></li>
<li><a class="reference" href="#exporteddoc" id="id92" name="id92">7.21&nbsp;&nbsp;&nbsp;%ExportedDoc</a></li>
<li><a class="reference" href="#exportedheadercode" id="id93" name="id93">7.22&nbsp;&nbsp;&nbsp;%ExportedHeaderCode</a></li>
<li><a class="reference" href="#feature" id="id94" name="id94">7.23&nbsp;&nbsp;&nbsp;%Feature</a></li>
<li><a class="reference" href="#gcclearcode" id="id95" name="id95">7.24&nbsp;&nbsp;&nbsp;%GCClearCode</a></li>
<li><a class="reference" href="#gctraversecode" id="id96" name="id96">7.25&nbsp;&nbsp;&nbsp;%GCTraverseCode</a></li>
<li><a class="reference" href="#getcode" id="id97" name="id97">7.26&nbsp;&nbsp;&nbsp;%GetCode</a></li>
<li><a class="reference" href="#if" id="id98" name="id98">7.27&nbsp;&nbsp;&nbsp;%If</a></li>
<li><a class="reference" href="#import" id="id99" name="id99">7.28&nbsp;&nbsp;&nbsp;%Import</a></li>
<li><a class="reference" href="#include" id="id100" name="id100">7.29&nbsp;&nbsp;&nbsp;%Include</a></li>
<li><a class="reference" href="#initialisationcode" id="id101" name="id101">7.30&nbsp;&nbsp;&nbsp;%InitialisationCode</a></li>
<li><a class="reference" href="#id14" id="id102" name="id102">7.31&nbsp;&nbsp;&nbsp;%License</a></li>
<li><a class="reference" href="#mappedtype" id="id103" name="id103">7.32&nbsp;&nbsp;&nbsp;%MappedType</a></li>
<li><a class="reference" href="#methodcode" id="id104" name="id104">7.33&nbsp;&nbsp;&nbsp;%MethodCode</a></li>
<li><a class="reference" href="#module" id="id105" name="id105">7.34&nbsp;&nbsp;&nbsp;%Module</a></li>
<li><a class="reference" href="#modulecode" id="id106" name="id106">7.35&nbsp;&nbsp;&nbsp;%ModuleCode</a></li>
<li><a class="reference" href="#moduleheadercode" id="id107" name="id107">7.36&nbsp;&nbsp;&nbsp;%ModuleHeaderCode</a></li>
<li><a class="reference" href="#optionalinclude" id="id108" name="id108">7.37&nbsp;&nbsp;&nbsp;%OptionalInclude</a></li>
<li><a class="reference" href="#picklecode" id="id109" name="id109">7.38&nbsp;&nbsp;&nbsp;%PickleCode</a></li>
<li><a class="reference" href="#platforms" id="id110" name="id110">7.39&nbsp;&nbsp;&nbsp;%Platforms</a></li>
<li><a class="reference" href="#postinitialisationcode" id="id111" name="id111">7.40&nbsp;&nbsp;&nbsp;%PostInitialisationCode</a></li>
<li><a class="reference" href="#preinitialisationcode" id="id112" name="id112">7.41&nbsp;&nbsp;&nbsp;%PreInitialisationCode</a></li>
<li><a class="reference" href="#raisecode" id="id113" name="id113">7.42&nbsp;&nbsp;&nbsp;%RaiseCode</a></li>
<li><a class="reference" href="#setcode" id="id114" name="id114">7.43&nbsp;&nbsp;&nbsp;%SetCode</a></li>
<li><a class="reference" href="#timeline" id="id115" name="id115">7.44&nbsp;&nbsp;&nbsp;%Timeline</a></li>
<li><a class="reference" href="#typecode" id="id116" name="id116">7.45&nbsp;&nbsp;&nbsp;%TypeCode</a></li>
<li><a class="reference" href="#typeheadercode" id="id117" name="id117">7.46&nbsp;&nbsp;&nbsp;%TypeHeaderCode</a></li>
<li><a class="reference" href="#unitcode" id="id118" name="id118">7.47&nbsp;&nbsp;&nbsp;%UnitCode</a></li>
<li><a class="reference" href="#virtualcatchercode" id="id119" name="id119">7.48&nbsp;&nbsp;&nbsp;%VirtualCatcherCode</a></li>
</ul>
</li>
<li><a class="reference" href="#sip-annotations" id="id120" name="id120">8&nbsp;&nbsp;&nbsp;SIP Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#argument-annotations" id="id121" name="id121">8.1&nbsp;&nbsp;&nbsp;Argument Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#allownone" id="id122" name="id122">8.1.1&nbsp;&nbsp;&nbsp;AllowNone</a></li>
<li><a class="reference" href="#array" id="id123" name="id123">8.1.2&nbsp;&nbsp;&nbsp;Array</a></li>
<li><a class="reference" href="#arraysize" id="id124" name="id124">8.1.3&nbsp;&nbsp;&nbsp;ArraySize</a></li>
<li><a class="reference" href="#constrained" id="id125" name="id125">8.1.4&nbsp;&nbsp;&nbsp;Constrained</a></li>
<li><a class="reference" href="#encoding" id="id126" name="id126">8.1.5&nbsp;&nbsp;&nbsp;Encoding</a></li>
<li><a class="reference" href="#getwrapper" id="id127" name="id127">8.1.6&nbsp;&nbsp;&nbsp;GetWrapper</a></li>
<li><a class="reference" href="#in" id="id128" name="id128">8.1.7&nbsp;&nbsp;&nbsp;In</a></li>
<li><a class="reference" href="#keepreference" id="id129" name="id129">8.1.8&nbsp;&nbsp;&nbsp;KeepReference</a></li>
<li><a class="reference" href="#out" id="id130" name="id130">8.1.9&nbsp;&nbsp;&nbsp;Out</a></li>
<li><a class="reference" href="#resultsize" id="id131" name="id131">8.1.10&nbsp;&nbsp;&nbsp;ResultSize</a></li>
<li><a class="reference" href="#singleshot" id="id132" name="id132">8.1.11&nbsp;&nbsp;&nbsp;SingleShot</a></li>
<li><a class="reference" href="#transfer" id="id133" name="id133">8.1.12&nbsp;&nbsp;&nbsp;Transfer</a></li>
<li><a class="reference" href="#transferback" id="id134" name="id134">8.1.13&nbsp;&nbsp;&nbsp;TransferBack</a></li>
<li><a class="reference" href="#transferthis" id="id135" name="id135">8.1.14&nbsp;&nbsp;&nbsp;TransferThis</a></li>
</ul>
</li>
<li><a class="reference" href="#class-annotations" id="id136" name="id136">8.2&nbsp;&nbsp;&nbsp;Class Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#abstract" id="id137" name="id137">8.2.1&nbsp;&nbsp;&nbsp;Abstract</a></li>
<li><a class="reference" href="#delaydtor" id="id138" name="id138">8.2.2&nbsp;&nbsp;&nbsp;DelayDtor</a></li>
<li><a class="reference" href="#deprecated" id="id139" name="id139">8.2.3&nbsp;&nbsp;&nbsp;Deprecated</a></li>
<li><a class="reference" href="#external" id="id140" name="id140">8.2.4&nbsp;&nbsp;&nbsp;External</a></li>
<li><a class="reference" href="#metatype" id="id141" name="id141">8.2.5&nbsp;&nbsp;&nbsp;Metatype</a></li>
<li><a class="reference" href="#nodefaultctors" id="id142" name="id142">8.2.6&nbsp;&nbsp;&nbsp;NoDefaultCtors</a></li>
<li><a class="reference" href="#pyname" id="id143" name="id143">8.2.7&nbsp;&nbsp;&nbsp;PyName</a></li>
<li><a class="reference" href="#supertype" id="id144" name="id144">8.2.8&nbsp;&nbsp;&nbsp;Supertype</a></li>
</ul>
</li>
<li><a class="reference" href="#mapped-type-annotations" id="id145" name="id145">8.3&nbsp;&nbsp;&nbsp;Mapped Type Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#norelease" id="id146" name="id146">8.3.1&nbsp;&nbsp;&nbsp;NoRelease</a></li>
</ul>
</li>
<li><a class="reference" href="#enum-annotations" id="id147" name="id147">8.4&nbsp;&nbsp;&nbsp;Enum Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#id17" id="id148" name="id148">8.4.1&nbsp;&nbsp;&nbsp;PyName</a></li>
</ul>
</li>
<li><a class="reference" href="#exception-annotations" id="id149" name="id149">8.5&nbsp;&nbsp;&nbsp;Exception Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#id18" id="id150" name="id150">8.5.1&nbsp;&nbsp;&nbsp;PyName</a></li>
</ul>
</li>
<li><a class="reference" href="#function-annotations" id="id151" name="id151">8.6&nbsp;&nbsp;&nbsp;Function Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#autogen" id="id152" name="id152">8.6.1&nbsp;&nbsp;&nbsp;AutoGen</a></li>
<li><a class="reference" href="#default" id="id153" name="id153">8.6.2&nbsp;&nbsp;&nbsp;Default</a></li>
<li><a class="reference" href="#id19" id="id154" name="id154">8.6.3&nbsp;&nbsp;&nbsp;Deprecated</a></li>
<li><a class="reference" href="#factory" id="id155" name="id155">8.6.4&nbsp;&nbsp;&nbsp;Factory</a></li>
<li><a class="reference" href="#holdgil" id="id156" name="id156">8.6.5&nbsp;&nbsp;&nbsp;HoldGIL</a></li>
<li><a class="reference" href="#newthread" id="id157" name="id157">8.6.6&nbsp;&nbsp;&nbsp;NewThread</a></li>
<li><a class="reference" href="#noargparser" id="id158" name="id158">8.6.7&nbsp;&nbsp;&nbsp;NoArgParser</a></li>
<li><a class="reference" href="#noderived" id="id159" name="id159">8.6.8&nbsp;&nbsp;&nbsp;NoDerived</a></li>
<li><a class="reference" href="#numeric" id="id160" name="id160">8.6.9&nbsp;&nbsp;&nbsp;Numeric</a></li>
<li><a class="reference" href="#posthook" id="id161" name="id161">8.6.10&nbsp;&nbsp;&nbsp;PostHook</a></li>
<li><a class="reference" href="#prehook" id="id162" name="id162">8.6.11&nbsp;&nbsp;&nbsp;PreHook</a></li>
<li><a class="reference" href="#id20" id="id163" name="id163">8.6.12&nbsp;&nbsp;&nbsp;PyName</a></li>
<li><a class="reference" href="#releasegil" id="id164" name="id164">8.6.13&nbsp;&nbsp;&nbsp;ReleaseGIL</a></li>
<li><a class="reference" href="#id21" id="id165" name="id165">8.6.14&nbsp;&nbsp;&nbsp;Transfer</a></li>
<li><a class="reference" href="#id22" id="id166" name="id166">8.6.15&nbsp;&nbsp;&nbsp;TransferBack</a></li>
<li><a class="reference" href="#id23" id="id167" name="id167">8.6.16&nbsp;&nbsp;&nbsp;TransferThis</a></li>
</ul>
</li>
<li><a class="reference" href="#license-annotations" id="id168" name="id168">8.7&nbsp;&nbsp;&nbsp;License Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#licensee" id="id169" name="id169">8.7.1&nbsp;&nbsp;&nbsp;Licensee</a></li>
<li><a class="reference" href="#signature" id="id170" name="id170">8.7.2&nbsp;&nbsp;&nbsp;Signature</a></li>
<li><a class="reference" href="#timestamp" id="id171" name="id171">8.7.3&nbsp;&nbsp;&nbsp;Timestamp</a></li>
<li><a class="reference" href="#type" id="id172" name="id172">8.7.4&nbsp;&nbsp;&nbsp;Type</a></li>
</ul>
</li>
<li><a class="reference" href="#typedef-annotations" id="id173" name="id173">8.8&nbsp;&nbsp;&nbsp;Typedef Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#notypename" id="id174" name="id174">8.8.1&nbsp;&nbsp;&nbsp;NoTypeName</a></li>
</ul>
</li>
<li><a class="reference" href="#variable-annotations" id="id175" name="id175">8.9&nbsp;&nbsp;&nbsp;Variable Annotations</a><ul class="auto-toc">
<li><a class="reference" href="#id24" id="id176" name="id176">8.9.1&nbsp;&nbsp;&nbsp;PyName</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#sip-api-for-handwritten-code" id="id177" name="id177">9&nbsp;&nbsp;&nbsp;SIP API for Handwritten Code</a><ul class="auto-toc">
<li><a class="reference" href="#sip-api-major-nr" id="id178" name="id178">9.1&nbsp;&nbsp;&nbsp;SIP_API_MAJOR_NR</a></li>
<li><a class="reference" href="#sip-api-minor-nr" id="id179" name="id179">9.2&nbsp;&nbsp;&nbsp;SIP_API_MINOR_NR</a></li>
<li><a class="reference" href="#sip-block-threads" id="id180" name="id180">9.3&nbsp;&nbsp;&nbsp;SIP_BLOCK_THREADS</a></li>
<li><a class="reference" href="#sip-ssize-t" id="id181" name="id181">9.4&nbsp;&nbsp;&nbsp;SIP_SSIZE_T</a></li>
<li><a class="reference" href="#sip-unblock-threads" id="id182" name="id182">9.5&nbsp;&nbsp;&nbsp;SIP_UNBLOCK_THREADS</a></li>
<li><a class="reference" href="#sip-version" id="id183" name="id183">9.6&nbsp;&nbsp;&nbsp;SIP_VERSION</a></li>
<li><a class="reference" href="#sip-version-str" id="id184" name="id184">9.7&nbsp;&nbsp;&nbsp;SIP_VERSION_STR</a></li>
<li><a class="reference" href="#sipbadcatcherresult" id="id185" name="id185">9.8&nbsp;&nbsp;&nbsp;sipBadCatcherResult()</a></li>
<li><a class="reference" href="#sipbadlengthforslice" id="id186" name="id186">9.9&nbsp;&nbsp;&nbsp;sipBadLengthForSlice()</a></li>
<li><a class="reference" href="#sipbuildresult" id="id187" name="id187">9.10&nbsp;&nbsp;&nbsp;sipBuildResult()</a></li>
<li><a class="reference" href="#sipcallmethod" id="id188" name="id188">9.11&nbsp;&nbsp;&nbsp;sipCallMethod()</a></li>
<li><a class="reference" href="#sipcanconverttoenum" id="id189" name="id189">9.12&nbsp;&nbsp;&nbsp;sipCanConvertToEnum()</a></li>
<li><a class="reference" href="#sipcanconverttoinstance" id="id190" name="id190">9.13&nbsp;&nbsp;&nbsp;sipCanConvertToInstance()</a></li>
<li><a class="reference" href="#sipcanconverttomappedtype" id="id191" name="id191">9.14&nbsp;&nbsp;&nbsp;sipCanConvertToMappedType()</a></li>
<li><a class="reference" href="#sipcanconverttotype" id="id192" name="id192">9.15&nbsp;&nbsp;&nbsp;sipCanConvertToType()</a></li>
<li><a class="reference" href="#sipclassname" id="id193" name="id193">9.16&nbsp;&nbsp;&nbsp;sipClassName()</a></li>
<li><a class="reference" href="#sipconvertfromconstvoidptr" id="id194" name="id194">9.17&nbsp;&nbsp;&nbsp;sipConvertFromConstVoidPtr()</a></li>
<li><a class="reference" href="#sipconvertfromconstvoidptrandsize" id="id195" name="id195">9.18&nbsp;&nbsp;&nbsp;sipConvertFromConstVoidPtrAndSize()</a></li>
<li><a class="reference" href="#sipconvertfromenum" id="id196" name="id196">9.19&nbsp;&nbsp;&nbsp;sipConvertFromEnum()</a></li>
<li><a class="reference" href="#sipconvertfrominstance" id="id197" name="id197">9.20&nbsp;&nbsp;&nbsp;sipConvertFromInstance()</a></li>
<li><a class="reference" href="#sipconvertfrommappedtype" id="id198" name="id198">9.21&nbsp;&nbsp;&nbsp;sipConvertFromMappedType()</a></li>
<li><a class="reference" href="#sipconvertfromnamedenum" id="id199" name="id199">9.22&nbsp;&nbsp;&nbsp;sipConvertFromNamedEnum()</a></li>
<li><a class="reference" href="#sipconvertfromnewinstance" id="id200" name="id200">9.23&nbsp;&nbsp;&nbsp;sipConvertFromNewInstance()</a></li>
<li><a class="reference" href="#sipconvertfromnewtype" id="id201" name="id201">9.24&nbsp;&nbsp;&nbsp;sipConvertFromNewType()</a></li>
<li><a class="reference" href="#sipconvertfromsequenceindex" id="id202" name="id202">9.25&nbsp;&nbsp;&nbsp;sipConvertFromSequenceIndex()</a></li>
<li><a class="reference" href="#sipconvertfromsliceobject" id="id203" name="id203">9.26&nbsp;&nbsp;&nbsp;sipConvertFromSliceObject()</a></li>
<li><a class="reference" href="#sipconvertfromtype" id="id204" name="id204">9.27&nbsp;&nbsp;&nbsp;sipConvertFromType()</a></li>
<li><a class="reference" href="#sipconvertfromvoidptr" id="id205" name="id205">9.28&nbsp;&nbsp;&nbsp;sipConvertFromVoidPtr()</a></li>
<li><a class="reference" href="#sipconvertfromvoidptrandsize" id="id206" name="id206">9.29&nbsp;&nbsp;&nbsp;sipConvertFromVoidPtrAndSize()</a></li>
<li><a class="reference" href="#sipconverttoinstance" id="id207" name="id207">9.30&nbsp;&nbsp;&nbsp;sipConvertToInstance()</a></li>
<li><a class="reference" href="#sipconverttomappedtype" id="id208" name="id208">9.31&nbsp;&nbsp;&nbsp;sipConvertToMappedType()</a></li>
<li><a class="reference" href="#sipconverttotype" id="id209" name="id209">9.32&nbsp;&nbsp;&nbsp;sipConvertToType()</a></li>
<li><a class="reference" href="#sipconverttovoidptr" id="id210" name="id210">9.33&nbsp;&nbsp;&nbsp;sipConvertToVoidPtr()</a></li>
<li><a class="reference" href="#sipexportsymbol" id="id211" name="id211">9.34&nbsp;&nbsp;&nbsp;sipExportSymbol()</a></li>
<li><a class="reference" href="#sipfindclass" id="id212" name="id212">9.35&nbsp;&nbsp;&nbsp;sipFindClass()</a></li>
<li><a class="reference" href="#sipfindmappedtype" id="id213" name="id213">9.36&nbsp;&nbsp;&nbsp;sipFindMappedType()</a></li>
<li><a class="reference" href="#sipfindnamedenum" id="id214" name="id214">9.37&nbsp;&nbsp;&nbsp;sipFindNamedEnum()</a></li>
<li><a class="reference" href="#sipfindtype" id="id215" name="id215">9.38&nbsp;&nbsp;&nbsp;sipFindType()</a></li>
<li><a class="reference" href="#sipforceconverttoinstance" id="id216" name="id216">9.39&nbsp;&nbsp;&nbsp;sipForceConvertToInstance()</a></li>
<li><a class="reference" href="#sipforceconverttomappedtype" id="id217" name="id217">9.40&nbsp;&nbsp;&nbsp;sipForceConvertToMappedType()</a></li>
<li><a class="reference" href="#sipforceconverttotype" id="id218" name="id218">9.41&nbsp;&nbsp;&nbsp;sipForceConvertToType()</a></li>
<li><a class="reference" href="#sipfree" id="id219" name="id219">9.42&nbsp;&nbsp;&nbsp;sipFree()</a></li>
<li><a class="reference" href="#sipgetpyobject" id="id220" name="id220">9.43&nbsp;&nbsp;&nbsp;sipGetPyObject()</a></li>
<li><a class="reference" href="#sipgetwrapper" id="id221" name="id221">9.44&nbsp;&nbsp;&nbsp;sipGetWrapper()</a></li>
<li><a class="reference" href="#sipimportsymbol" id="id222" name="id222">9.45&nbsp;&nbsp;&nbsp;sipImportSymbol()</a></li>
<li><a class="reference" href="#sipinttypeclassmap" id="id223" name="id223">9.46&nbsp;&nbsp;&nbsp;sipIntTypeClassMap</a></li>
<li><a class="reference" href="#siplong-asunsignedlong" id="id224" name="id224">9.47&nbsp;&nbsp;&nbsp;sipLong_AsUnsignedLong()</a></li>
<li><a class="reference" href="#sipmalloc" id="id225" name="id225">9.48&nbsp;&nbsp;&nbsp;sipMalloc()</a></li>
<li><a class="reference" href="#sipmapinttoclass" id="id226" name="id226">9.49&nbsp;&nbsp;&nbsp;sipMapIntToClass()</a></li>
<li><a class="reference" href="#sipmapstringtoclass" id="id227" name="id227">9.50&nbsp;&nbsp;&nbsp;sipMapStringToClass()</a></li>
<li><a class="reference" href="#sipparseresult" id="id228" name="id228">9.51&nbsp;&nbsp;&nbsp;sipParseResult()</a></li>
<li><a class="reference" href="#sipregisterattributegetter" id="id229" name="id229">9.52&nbsp;&nbsp;&nbsp;sipRegisterAttributeGetter()</a></li>
<li><a class="reference" href="#sipregisterpytype" id="id230" name="id230">9.53&nbsp;&nbsp;&nbsp;sipRegisterPyType()</a></li>
<li><a class="reference" href="#sipreleaseinstance" id="id231" name="id231">9.54&nbsp;&nbsp;&nbsp;sipReleaseInstance()</a></li>
<li><a class="reference" href="#sipreleasemappedtype" id="id232" name="id232">9.55&nbsp;&nbsp;&nbsp;sipReleaseMappedType()</a></li>
<li><a class="reference" href="#sipreleasetype" id="id233" name="id233">9.56&nbsp;&nbsp;&nbsp;sipReleaseType()</a></li>
<li><a class="reference" href="#sipresolvetypedef" id="id234" name="id234">9.57&nbsp;&nbsp;&nbsp;sipResolveTypedef()</a></li>
<li><a class="reference" href="#sipsimplewrapper" id="id235" name="id235">9.58&nbsp;&nbsp;&nbsp;sipSimpleWrapper</a></li>
<li><a class="reference" href="#sipsimplewrapper-type" id="id236" name="id236">9.59&nbsp;&nbsp;&nbsp;sipSimpleWrapper_Type</a></li>
<li><a class="reference" href="#sipstringtypeclassmap" id="id237" name="id237">9.60&nbsp;&nbsp;&nbsp;sipStringTypeClassMap</a></li>
<li><a class="reference" href="#siptransferback" id="id238" name="id238">9.61&nbsp;&nbsp;&nbsp;sipTransferBack()</a></li>
<li><a class="reference" href="#siptransferbreak" id="id239" name="id239">9.62&nbsp;&nbsp;&nbsp;sipTransferBreak()</a></li>
<li><a class="reference" href="#siptransferto" id="id240" name="id240">9.63&nbsp;&nbsp;&nbsp;sipTransferTo()</a></li>
<li><a class="reference" href="#siptypeaspytypeobject" id="id241" name="id241">9.64&nbsp;&nbsp;&nbsp;sipTypeAsPyTypeObject()</a></li>
<li><a class="reference" href="#siptypefrompytypeobject" id="id242" name="id242">9.65&nbsp;&nbsp;&nbsp;sipTypeFromPyTypeObject()</a></li>
<li><a class="reference" href="#siptypeisclass" id="id243" name="id243">9.66&nbsp;&nbsp;&nbsp;sipTypeIsClass()</a></li>
<li><a class="reference" href="#siptypeisenum" id="id244" name="id244">9.67&nbsp;&nbsp;&nbsp;sipTypeIsEnum()</a></li>
<li><a class="reference" href="#siptypeismapped" id="id245" name="id245">9.68&nbsp;&nbsp;&nbsp;sipTypeIsMapped()</a></li>
<li><a class="reference" href="#siptypeisnamespace" id="id246" name="id246">9.69&nbsp;&nbsp;&nbsp;sipTypeIsNamespace()</a></li>
<li><a class="reference" href="#siptypename" id="id247" name="id247">9.70&nbsp;&nbsp;&nbsp;sipTypeName()</a></li>
<li><a class="reference" href="#siptypescope" id="id248" name="id248">9.71&nbsp;&nbsp;&nbsp;sipTypeScope()</a></li>
<li><a class="reference" href="#sipvoidptr-type" id="id249" name="id249">9.72&nbsp;&nbsp;&nbsp;sipVoidPtr_Type</a></li>
<li><a class="reference" href="#sipwrapper" id="id250" name="id250">9.73&nbsp;&nbsp;&nbsp;sipWrapper</a></li>
<li><a class="reference" href="#sipwrapper-check" id="id251" name="id251">9.74&nbsp;&nbsp;&nbsp;sipWrapper_Check()</a></li>
<li><a class="reference" href="#sipwrapper-type" id="id252" name="id252">9.75&nbsp;&nbsp;&nbsp;sipWrapper_Type</a></li>
<li><a class="reference" href="#sipwrappertype" id="id253" name="id253">9.76&nbsp;&nbsp;&nbsp;sipWrapperType</a></li>
<li><a class="reference" href="#sipwrappertype-type" id="id254" name="id254">9.77&nbsp;&nbsp;&nbsp;sipWrapperType_Type</a></li>
<li><a class="reference" href="#generated-type-structures" id="id255" name="id255">9.78&nbsp;&nbsp;&nbsp;Generated Type Structures</a></li>
<li><a class="reference" href="#generated-type-objects" id="id256" name="id256">9.79&nbsp;&nbsp;&nbsp;Generated Type Objects</a></li>
<li><a class="reference" href="#generated-named-enum-type-objects" id="id257" name="id257">9.80&nbsp;&nbsp;&nbsp;Generated Named Enum Type Objects</a></li>
<li><a class="reference" href="#generated-derived-classes" id="id258" name="id258">9.81&nbsp;&nbsp;&nbsp;Generated Derived Classes</a></li>
<li><a class="reference" href="#generated-exception-objects" id="id259" name="id259">9.82&nbsp;&nbsp;&nbsp;Generated Exception Objects</a></li>
</ul>
</li>
<li><a class="reference" href="#using-the-sip-api-when-embedding" id="id260" name="id260">10&nbsp;&nbsp;&nbsp;Using the SIP API when Embedding</a></li>
<li><a class="reference" href="#using-the-sip-module-in-applications" id="id261" name="id261">11&nbsp;&nbsp;&nbsp;Using the SIP Module in Applications</a></li>
<li><a class="reference" href="#the-sip-build-system" id="id262" name="id262">12&nbsp;&nbsp;&nbsp;The SIP Build System</a><ul class="auto-toc">
<li><a class="reference" href="#sipconfig-functions" id="id263" name="id263">12.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">sipconfig</span></tt> Functions</a></li>
<li><a class="reference" href="#sipconfig-classes" id="id264" name="id264">12.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">sipconfig</span></tt> Classes</a></li>
</ul>
</li>
<li><a class="reference" href="#building-your-extension-with-distutils" id="id265" name="id265">13&nbsp;&nbsp;&nbsp;Building Your Extension with distutils</a></li>
<li><a class="reference" href="#builtin-modules-and-custom-interpreters" id="id266" name="id266">14&nbsp;&nbsp;&nbsp;Builtin Modules and Custom Interpreters</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id25" id="introduction" name="introduction">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>This is the reference guide for SIP 4.8-snapshot-20090409.  SIP is a tool for
automatically generating <a class="reference" href="http://www.python.org">Python</a> bindings for C and
C++ libraries.  SIP was originally developed in 1998 for
<a class="reference" href="http://www.riverbankcomputing.com/software/pyqt/">PyQt</a> - the Python
bindings for the Qt GUI toolkit - but is suitable for generating bindings for
any C or C++ library.</p>
<p>This version of SIP generates bindings for Python v2.3 or later.</p>
<p>There are many other similar tools available.  One of the original such tools
is <a class="reference" href="http://www.swig.org">SWIG</a> and, in fact, SIP is so called because it
started out as a small SWIG.  Unlike SWIG, SIP is specifically designed for
bringing together Python and C/C++ and goes to great lengths to make the
integration as tight as possible.</p>
<p>The homepage for SIP is <a class="reference" href="http://www.riverbankcomputing.com/software/sip/">http://www.riverbankcomputing.com/software/sip/</a>.  Here
you will always find the latest stable version, current development snapshots,
and the latest version of this documentation.</p>
<div class="section">
<h2><a class="toc-backref" href="#id26" id="license" name="license">1.1&nbsp;&nbsp;&nbsp;License</a></h2>
<p>SIP is licensed under similar terms as Python itself.  SIP places no
restrictions on the license you may apply to the bindings you create.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id27" id="features" name="features">1.2&nbsp;&nbsp;&nbsp;Features</a></h2>
<p>SIP, and the bindings it produces, have the following features.</p>
<blockquote>
<ul class="simple">
<li>bindings are fast to load and minimise memory consumption especially when
only a small sub-set of a large library is being used</li>
<li>automatic conversion between standard Python and C/C++ data types</li>
<li>overloading of functions and methods with different argument signatures</li>
<li>access to a C++ class's protected methods</li>
<li>the ability to define a Python class that is a sub-class of a C++ class,
including abstract C++ classes</li>
<li>Python sub-classes can implement the <tt class="docutils literal"><span class="pre">__dtor__(self)</span></tt> method which
will be called from the C++ class's virtual destructor</li>
<li>support for ordinary C++ functions, class methods, static class methods,
virtual class methods and abstract class methods</li>
<li>the ability to re-implement C++ virtual and abstract methods in Python</li>
<li>support for global and class variables</li>
<li>support for global and class operators</li>
<li>support for C++ namespaces</li>
<li>support for C++ templates</li>
<li>support for C++ exceptions and wrapping them as Python exceptions</li>
<li>the automatic generation of complementary rich comparison slots</li>
<li>support for deprecation warnings</li>
<li>the ability to define mappings between C++ classes and similar Python
data types that are automatically invoked</li>
<li>the ability to automatically exploit any available run time type
information to ensure that the class of a Python instance object matches
the class of the corresponding C++ instance</li>
<li>the ability to change the type and meta-type of the Python object used to
wrap a C/C++ data type</li>
<li>full support of the Python global interpreter lock, including the ability
to specify that a C++ function of method may block, therefore allowing
the lock to be released and other Python threads to run</li>
<li>support for consolidated modules where the generated wrapper code for a
number of related modules may be included in a single, possibly private,
module</li>
<li>support for the concept of ownership of a C++ instance (i.e. what part of
the code is responsible for calling the instance's destructor) and how
the ownership may change during the execution of an application</li>
<li>the ability to generate bindings for a C++ class library that itself is
built on another C++ class library which also has had bindings generated
so that the different bindings integrate and share code properly</li>
<li>a sophisticated versioning system that allows the full lifetime of a C++
class library, including any platform specific or optional features, to
be described in a single set of specification files</li>
<li>the ability to include documentation in the specification files which can
be extracted and subsequently processed by external tools</li>
<li>the ability to include copyright notices and licensing information in the
specification files that is automatically included in all generated
source code</li>
<li>a build system, written in Python, that you can extend to configure,
compile and install your own bindings without worrying about platform
specific issues</li>
<li>support for building your extensions using distutils</li>
<li>SIP, and the bindings it produces, runs under UNIX, Linux, Windows and
MacOS/X</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id28" id="sip-components" name="sip-components">1.3&nbsp;&nbsp;&nbsp;SIP Components</a></h2>
<p>SIP comprises a number of different components.</p>
<blockquote>
<ul class="simple">
<li>The SIP code generator (<tt class="docutils literal"><span class="pre">sip</span></tt> or <tt class="docutils literal"><span class="pre">sip.exe</span></tt>).  This processes <tt class="docutils literal"><span class="pre">.sip</span></tt>
specification files and generates C or C++ bindings.  It is covered in
detail in <a class="reference" href="#using-sip">Using SIP</a>.</li>
<li>The SIP header file (<tt class="docutils literal"><span class="pre">sip.h</span></tt>).  This contains definitions and data
structures needed by the generated C and C++ code.</li>
<li>The SIP module (<tt class="docutils literal"><span class="pre">sip.so</span></tt> or <tt class="docutils literal"><span class="pre">sip.pyd</span></tt>).  This is a Python extension
module that is imported automatically by SIP generated bindings and
provides them with some common utility functions.  See also <a class="reference" href="#using-the-sip-module-in-applications">Using the
SIP Module in Applications</a>.</li>
<li>The SIP build system (<tt class="docutils literal"><span class="pre">sipconfig.py</span></tt>).  This is a pure Python module
that is created when SIP is configured and encapsulates all the necessary
information about your system including relevant directory names,
compiler and linker flags, and version numbers.  It also includes several
Python classes and functions which help you write configuration scripts
for your own bindings.  It is covered in detail in <a class="reference" href="#the-sip-build-system">The SIP Build
System</a>.</li>
<li>The SIP distutils extension (<tt class="docutils literal"><span class="pre">sipdistutils.py</span></tt>).  This is a distutils
extension that can be used to build your extension modules using
distutils and is an alternative to writing configuration scripts with the
SIP build system.  This can be as simple as adding your .sip files to the
list of files needed to build the extension module.  It is covered in
detail in <a class="reference" href="#building-your-extension-with-distutils">Building Your Extension with distutils</a>.</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id29" id="qt-support" name="qt-support">1.4&nbsp;&nbsp;&nbsp;Qt Support</a></h2>
<p>SIP has specific support for the creation of bindings based on Trolltech's Qt
toolkit.</p>
<p>The SIP code generator understands the signal/slot type safe callback mechanism
that Qt uses to connect objects together.  This allows applications to define
new Python signals, and allows any Python callable object to be used as a slot.</p>
<p>SIP itself does not require Qt to be installed.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id30" id="potential-incompatibilities-with-earlier-versions" name="potential-incompatibilities-with-earlier-versions">2&nbsp;&nbsp;&nbsp;Potential Incompatibilities with Earlier Versions</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id31" id="sip-v4-8" name="sip-v4-8">2.1&nbsp;&nbsp;&nbsp;SIP v4.8</a></h2>
<p>Prior to this version the <a class="reference" href="#sipwrapper">sipWrapper</a> structure had a member called <tt class="docutils literal"><span class="pre">user</span></tt>
which is available for handwritten code to use.  From this version <tt class="docutils literal"><span class="pre">user</span></tt> is
a member of the <a class="reference" href="#sipsimplewrapper">sipSimpleWrapper</a> structure.  <a class="reference" href="#sipwrapper">sipWrapper</a> pointers can be
safely cast to <a class="reference" href="#sipsimplewrapper">sipSimpleWrapper</a> pointers, so if your code does something
like:</p>
<pre class="literal-block">
((sipWrapper *)obj)-&gt;user = an_object_reference;
</pre>
<p>then you just need to change it to:</p>
<pre class="literal-block">
((sipSimpleWrapper *)obj)-&gt;user = an_object_reference;
</pre>
<p>The generated class names are now <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> rather than <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt>.</p>
<p>The following deprecated parts of the API have been removed.</p>
<blockquote>
<ul class="simple">
<li>The <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">M</span></tt>, <tt class="docutils literal"><span class="pre">N</span></tt>, <tt class="docutils literal"><span class="pre">O</span></tt>, <tt class="docutils literal"><span class="pre">P</span></tt> and <tt class="docutils literal"><span class="pre">T</span></tt> format characters
from <a class="reference" href="#sipbuildresult">sipBuildResult()</a> and <a class="reference" href="#sipcallmethod">sipCallMethod()</a>.</li>
<li>The <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">L</span></tt> and <tt class="docutils literal"><span class="pre">M</span></tt> format characters from
<a class="reference" href="#sipparseresult">sipParseResult()</a>.</li>
<li><tt class="docutils literal"><span class="pre">sipConvertToCpp()</span></tt>, <tt class="docutils literal"><span class="pre">sipIsSubClassInstance()</span></tt> and <tt class="docutils literal"><span class="pre">sipTransfer()</span></tt>.</li>
<li>The old-style generated type convertors.</li>
<li>The <tt class="docutils literal"><span class="pre">transfer()</span></tt> function of the <tt class="docutils literal"><span class="pre">sip</span></tt> module.</li>
</ul>
</blockquote>
<p>In addition the deprecated <tt class="docutils literal"><span class="pre">-a</span></tt> command line option to <tt class="docutils literal"><span class="pre">configure.py</span></tt> has
been removed.</p>
<p>The following parts of the API are now deprecated (but still supported).</p>
<blockquote>
<ul class="simple">
<li>The <a class="reference" href="#generated-type-objects">Generated Type Objects</a>.</li>
<li>The <a class="reference" href="#generated-named-enum-type-objects">Generated Named Enum Type Objects</a>.</li>
<li><a class="reference" href="#sipconvertfrominstance">sipConvertFromInstance()</a></li>
<li><a class="reference" href="#sipconvertfrommappedtype">sipConvertFromMappedType()</a></li>
<li><a class="reference" href="#sipconvertfromnamedenum">sipConvertFromNamedEnum()</a></li>
<li><a class="reference" href="#sipconvertfromnewinstance">sipConvertFromNewInstance()</a></li>
<li><a class="reference" href="#sipcanconverttoinstance">sipCanConvertToInstance()</a></li>
<li><a class="reference" href="#sipcanconverttomappedtype">sipCanConvertToMappedType()</a></li>
<li><a class="reference" href="#sipconverttoinstance">sipConvertToInstance()</a></li>
<li><a class="reference" href="#sipconverttomappedtype">sipConvertToMappedType()</a></li>
<li><a class="reference" href="#sipforceconverttoinstance">sipForceConvertToInstance()</a></li>
<li><a class="reference" href="#sipforceconverttomappedtype">sipForceConvertToMappedType()</a></li>
<li><a class="reference" href="#sipclassname">sipClassName()</a></li>
<li><a class="reference" href="#sipfindclass">sipFindClass()</a></li>
<li><a class="reference" href="#sipfindnamedenum">sipFindNamedEnum()</a></li>
<li><a class="reference" href="#sipfindmappedtype">sipFindMappedType()</a></li>
<li><a class="reference" href="#sipgetwrapper">sipGetWrapper()</a></li>
<li><a class="reference" href="#sipreleaseinstance">sipReleaseInstance()</a></li>
<li><a class="reference" href="#sipreleasemappedtype">sipReleaseMappedType()</a></li>
<li><a class="reference" href="#sipwrapper-check">sipWrapper_Check()</a></li>
<li>The <tt class="docutils literal"><span class="pre">B</span></tt>, <tt class="docutils literal"><span class="pre">C</span></tt> and <tt class="docutils literal"><span class="pre">E</span></tt> format characters of <a class="reference" href="#sipbuildresult">sipBuildResult()</a> and
<a class="reference" href="#sipcallmethod">sipCallMethod()</a>.</li>
<li>The <tt class="docutils literal"><span class="pre">s</span></tt>, <tt class="docutils literal"><span class="pre">C</span></tt> and <tt class="docutils literal"><span class="pre">E</span></tt> format character of <a class="reference" href="#sipparseresult">sipParseResult()</a>.</li>
</ul>
</blockquote>
<p>The following PyQt-specific support functions have been removed.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">sipConnectRx()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">sipDisconnectRx()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">sipEmitSlot()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">sipGetSender()</span></tt></li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id32" id="sip-v4-7-8" name="sip-v4-7-8">2.2&nbsp;&nbsp;&nbsp;SIP v4.7.8</a></h2>
<p>This version allows a Python int object to be passed whenever an enum is
expected.  This can mean that two signatures that were different with prior
versions are now the same as far as Python is concerned.  The <a class="reference" href="#constrained">Constrained</a>
annotation can now be applied to an enum argument to revert to the earlier
behaviour.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id33" id="sip-v4-7-3" name="sip-v4-7-3">2.3&nbsp;&nbsp;&nbsp;SIP v4.7.3</a></h2>
<p>Prior to this version SIP did not automatically generate missing complementary
comparison operators.  Typically this was worked around by adding them
explicitly to the .sip files, even though they weren't implemented in C++ and
relied on the C++ compiler calling the complementary operator that was
implemented.</p>
<p>A necessary change to the code generator meant that this not longer worked and
so SIP was changed to automatically generate any missing complementary
operators.  If you have added such operators explicitly then you should remove
them or make them dependent on the particular version of SIP.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id34" id="sip-v4-4" name="sip-v4-4">2.4&nbsp;&nbsp;&nbsp;SIP v4.4</a></h2>
<blockquote>
<ul class="simple">
<li>The <tt class="docutils literal"><span class="pre">SIP_BUILD</span></tt> C preprocessor symbol has been removed.</li>
<li><tt class="docutils literal"><span class="pre">sipConvertToCpp()</span></tt>, <tt class="docutils literal"><span class="pre">sipIsSubClassInstance()</span></tt> and the old-style
generated type convertors have been deprecated.  The functions
<a class="reference" href="#sipcanconverttotype">sipCanConvertToType()</a>, <a class="reference" href="#sipconverttotype">sipConvertToType()</a>,
<a class="reference" href="#sipforceconverttotype">sipForceConvertToType()</a>, <a class="reference" href="#sipconvertfromtype">sipConvertFromType()</a> and
<a class="reference" href="#sipconvertfromnewtype">sipConvertFromNewType()</a> should be used instead.  Handwritten
<a class="reference" href="#convertfromtypecode">%ConvertFromTypeCode</a> and <a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> now has the
responsibility for using these to implement the <tt class="docutils literal"><span class="pre">Transfer</span></tt> and
<tt class="docutils literal"><span class="pre">TransferBack</span></tt> annotations.</li>
</ul>
</blockquote>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id35" id="installing-sip" name="installing-sip">3&nbsp;&nbsp;&nbsp;Installing SIP</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id36" id="downloading-sip" name="downloading-sip">3.1&nbsp;&nbsp;&nbsp;Downloading SIP</a></h2>
<p>You can get the latest release of the SIP source code from
<a class="reference" href="http://www.riverbankcomputing.com/software/sip/download">http://www.riverbankcomputing.com/software/sip/download</a>.</p>
<p>SIP is also included with all of the major Linux distributions.  However, it
may be a version or two out of date.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id37" id="configuring-sip" name="configuring-sip">3.2&nbsp;&nbsp;&nbsp;Configuring SIP</a></h2>
<p>After unpacking the source package (either a <tt class="docutils literal"><span class="pre">.tar.gz</span></tt> or a <tt class="docutils literal"><span class="pre">.zip</span></tt> file
depending on your platform) you should then check for any <tt class="docutils literal"><span class="pre">README</span></tt> files
that relate to your platform.</p>
<p>Next you need to configure SIP by executing the <tt class="docutils literal"><span class="pre">configure.py</span></tt> script.  For
example:</p>
<pre class="literal-block">
python configure.py
</pre>
<p>This assumes that the Python interpreter is on your path.  Something like the
following may be appropriate on Windows:</p>
<pre class="literal-block">
c:\python26\python configure.py
</pre>
<p>If you have multiple versions of Python installed then make sure you use the
interpreter for which you wish SIP to generate bindings for.</p>
<p>The full set of command line options is:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">--version</span></kbd></td>
<td>Display the SIP version number.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-h</span>, <span class="option">--help</span></kbd></td>
<td>Display a help message.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-b <var>DIR</var></span>, <span class="option">--bindir=<var>DIR</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>The SIP code generator will be installed in the directory <tt class="docutils literal"><span class="pre">DIR</span></tt>.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-d <var>DIR</var></span>, <span class="option">--destdir=<var>DIR</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>The SIP module will be installed in the directory <tt class="docutils literal"><span class="pre">DIR</span></tt>.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-e <var>DIR</var></span>, <span class="option">--incdir=<var>DIR</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>The SIP header file will be installed in the directory <tt class="docutils literal"><span class="pre">DIR</span></tt>.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-k</span>, <span class="option">--static</span></kbd></td>
<td>The SIP module will be built as a static library.  This is useful when
building the SIP module as a Python builtin (see <a class="reference" href="#builtin-modules-and-custom-interpreters">Builtin Modules and
Custom Interpreters</a>).</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-n</span>, <span class="option">--universal</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>The SIP code generator and module will be built as universal binaries under
MacOS/X.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-p <var>PLATFORM</var></span>, <span class="option">--platform=<var>PLATFORM</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Explicitly specify the platform/compiler to be used by the build system,
otherwise a platform specific default will be used.  The
<tt class="docutils literal"><span class="pre">--show-platforms</span></tt> option will display all the supported
platform/compilers.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-s <var>SDK</var></span>, <span class="option">--sdk=<var>SDK</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>If the <tt class="docutils literal"><span class="pre">-n</span></tt> option was given then this specifies the name of the SDK
directory.  If a path is not given then it is assumed to be a sub-directory
of <tt class="docutils literal"><span class="pre">/Developer/SDKs</span></tt>.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-u</span>, <span class="option">--debug</span></kbd></td>
<td>The SIP module will be built with debugging symbols.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">-v <var>DIR</var></span>, <span class="option">--sipdir=<var>DIR</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>By default <tt class="docutils literal"><span class="pre">.sip</span></tt> files will be installed in the directory <tt class="docutils literal"><span class="pre">DIR</span></tt>.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--show-platforms</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>The list of all supported platform/compilers will be displayed.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--show-build-macros</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>The list of all available build macros will be displayed.</td></tr>
</tbody>
</table>
<p>The configure.py script takes many other options that allows the build system
to be finely tuned.  These are of the form <tt class="docutils literal"><span class="pre">name=value</span></tt> or <tt class="docutils literal"><span class="pre">name+=value</span></tt>.
The <tt class="docutils literal"><span class="pre">--show-build-macros</span></tt> option will display each supported <tt class="docutils literal"><span class="pre">name</span></tt>,
although not all are applicable to all platforms.</p>
<p>The <tt class="docutils literal"><span class="pre">name=value</span></tt> form means that <tt class="docutils literal"><span class="pre">value</span></tt> will replace the existing value of
<tt class="docutils literal"><span class="pre">name</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">name+=value</span></tt> form means that <tt class="docutils literal"><span class="pre">value</span></tt> will be appended to the existing
value of <tt class="docutils literal"><span class="pre">name</span></tt>.</p>
<p>For example, the following will disable support for C++ exceptions (and so
reduce the size of module binaries) when used with GCC:</p>
<pre class="literal-block">
python configure.py CXXFLAGS+=-fno-exceptions
</pre>
<p>A pure Python module called <tt class="docutils literal"><span class="pre">sipconfig.py</span></tt> is generated by <tt class="docutils literal"><span class="pre">configure.py</span></tt>.
This defines each <tt class="docutils literal"><span class="pre">name</span></tt> and its corresponding <tt class="docutils literal"><span class="pre">value</span></tt>.  Looking at it will
give you a good idea of how the build system uses the different options.  It is
covered in detail in <a class="reference" href="#the-sip-build-system">The SIP Build System</a>.</p>
<div class="section">
<h3><a class="toc-backref" href="#id38" id="configuring-sip-using-mingw" name="configuring-sip-using-mingw">3.2.1&nbsp;&nbsp;&nbsp;Configuring SIP Using MinGW</a></h3>
<p>SIP, and the modules it generates, can be built with MinGW, the Windows port of
GCC.  You must use the <tt class="docutils literal"><span class="pre">-p</span></tt> command line option to specify the correct
platform.  For example:</p>
<pre class="literal-block">
c:\python26\python configure.py -p win32-g++
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id39" id="configuring-sip-using-the-borland-c-compiler" name="configuring-sip-using-the-borland-c-compiler">3.2.2&nbsp;&nbsp;&nbsp;Configuring SIP Using the Borland C++ Compiler</a></h3>
<p>SIP, and the modules it generates, can be built with the free Borland C++
compiler.  You must use the <tt class="docutils literal"><span class="pre">-p</span></tt> command line option to specify the correct
platform.  For example:</p>
<pre class="literal-block">
c:\python26\python configure.py -p win32-borland
</pre>
<p>You must also make sure you have a Borland-compatible version of the Python
library.  If you are using the standard Python distribution (built using the
Microsoft compiler) then you must convert the format of the Python library.
For example:</p>
<pre class="literal-block">
coff2omf python26.lib python26_bcpp.lib
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id40" id="building-sip" name="building-sip">3.3&nbsp;&nbsp;&nbsp;Building SIP</a></h2>
<p>The next step is to build SIP by running your platform's <tt class="docutils literal"><span class="pre">make</span></tt> command.  For
example:</p>
<pre class="literal-block">
make
</pre>
<p>The final step is to install SIP by running the following command:</p>
<pre class="literal-block">
make install
</pre>
<p>(Depending on your system you may require root or administrator privileges.)</p>
<p>This will install the various SIP components.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id41" id="using-sip" name="using-sip">4&nbsp;&nbsp;&nbsp;Using SIP</a></h1>
<p>Bindings are generated by the SIP code generator from a number of specification
files, typically with a <tt class="docutils literal"><span class="pre">.sip</span></tt> extension.  Specification files look very
similar to C and C++ header files, but often with additional information (in
the form of a <em>directive</em> or an <em>annotation</em>) and code so that the bindings
generated can be finely tuned.</p>
<div class="section">
<h2><a class="toc-backref" href="#id42" id="a-simple-c-example" name="a-simple-c-example">4.1&nbsp;&nbsp;&nbsp;A Simple C++ Example</a></h2>
<p>We start with a simple example.  Let's say you have a (fictional) C++ library
that implements a single class called <tt class="docutils literal"><span class="pre">Word</span></tt>.  The class has one constructor
that takes a <tt class="docutils literal"><span class="pre">\0</span></tt> terminated character string as its single argument.  The
class has one method called <tt class="docutils literal"><span class="pre">reverse()</span></tt> which takes no arguments and returns
a <tt class="docutils literal"><span class="pre">\0</span></tt> terminated character string.  The interface to the class is defined in
a header file called <tt class="docutils literal"><span class="pre">word.h</span></tt> which might look something like this:</p>
<pre class="literal-block">
// Define the interface to the word library.

class Word {
    const char *the_word;

public:
    Word(const char *w);

    char *reverse() const;
};
</pre>
<p>The corresponding SIP specification file would then look something like this:</p>
<pre class="literal-block">
// Define the SIP wrapper to the word library.

%Module word 0

class Word {

%TypeHeaderCode
#include &lt;word.h&gt;
%End

public:
    Word(const char *w);

    char *reverse() const;
};
</pre>
<p>Obviously a SIP specification file looks very much like a C++ (or C) header
file, but SIP does not include a full C++ parser.  Let's look at the
differences between the two files.</p>
<blockquote>
<ul class="simple">
<li>The <a class="reference" href="#module">%Module</a> directive has been added <a class="footnote-reference" href="#id4" id="id1" name="id1">[1]</a>.  This is used to name the
Python module that is being created and to give it a <em>generation</em> number.
In this example these are <tt class="docutils literal"><span class="pre">word</span></tt> and <tt class="docutils literal"><span class="pre">0</span></tt> respectively.  The
generation number is effectively the version number of the module.</li>
<li>The <a class="reference" href="#typeheadercode">%TypeHeaderCode</a> directive has been added.  The text between this
and the following <a class="reference" href="#end">%End</a> directive is included literally in the code
that SIP generates.  Normally it is used, as in this case, to
<tt class="docutils literal"><span class="pre">#include</span></tt> the corresponding C++ (or C) header file <a class="footnote-reference" href="#id5" id="id2" name="id2">[2]</a>.</li>
<li>The declaration of the private variable <tt class="docutils literal"><span class="pre">this_word</span></tt> has been removed.
SIP does not support access to either private or protected instance
variables.</li>
</ul>
</blockquote>
<p>If we want to we can now generate the C++ code in the current directory by
running the following command:</p>
<pre class="literal-block">
sip -c . word.sip
</pre>
<p>However, that still leaves us with the task of compiling the generated code and
linking it against all the necessary libraries.  It's much easier to use the
SIP build system to do the whole thing.</p>
<p>Using the SIP build system is simply a matter of writing a small Python script.
In this simple example we will assume that the <tt class="docutils literal"><span class="pre">word</span></tt> library we are wrapping
and it's header file are installed in standard system locations and will be
found by the compiler and linker without having to specify any additional
flags.  In a more realistic example your Python script may take command line
options, or search a set of directories to deal with different configurations
and installations.</p>
<p>This is the simplest script (conventionally called <tt class="docutils literal"><span class="pre">configure.py</span></tt>):</p>
<pre class="literal-block">
import os
import sipconfig

# The name of the SIP build file generated by SIP and used by the build
# system.
build_file = &quot;word.sbf&quot;

# Get the SIP configuration information.
config = sipconfig.Configuration()

# Run SIP to generate the code.
os.system(&quot; &quot;.join([config.sip_bin, &quot;-c&quot;, &quot;.&quot;, &quot;-b&quot;, build_file, &quot;word.sip&quot;]))

# Create the Makefile.
makefile = sipconfig.SIPModuleMakefile(config, build_file)

# Add the library we are wrapping.  The name doesn't include any platform
# specific prefixes or extensions (e.g. the &quot;lib&quot; prefix on UNIX, or the
# &quot;.dll&quot; extension on Windows).
makefile.extra_libs = [&quot;word&quot;]

# Generate the Makefile itself.
makefile.generate()
</pre>
<p>Hopefully this script is self-documenting.  The key parts are the
<tt class="docutils literal"><span class="pre">Configuration</span></tt> and <tt class="docutils literal"><span class="pre">SIPModuleMakefile</span></tt> classes.  The build system contains
other Makefile classes, for example to build programs or to call other
Makefiles in sub-directories.</p>
<p>After running the script (using the Python interpreter the extension module is
being created for) the generated C++ code and <tt class="docutils literal"><span class="pre">Makefile</span></tt> will be in the
current directory.</p>
<p>To compile and install the extension module, just run the following
commands <a class="footnote-reference" href="#id6" id="id3" name="id3">[3]</a>:</p>
<pre class="literal-block">
make
make install
</pre>
<p>That's all there is to it.</p>
<p>See <a class="reference" href="#building-your-extension-with-distutils">Building Your Extension with distutils</a> for an example of how to build
this example using distutils.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id4">[1]</a></td><td>All SIP directives start with a <tt class="docutils literal"><span class="pre">%</span></tt> as the first non-whitespace
character of a line.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="id5">[2]</a></td><td>SIP includes many code directives like this.  They differ in where the
supplied code is placed by SIP in the generated code.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id6">[3]</a></td><td>On Windows you might run <tt class="docutils literal"><span class="pre">nmake</span></tt> or <tt class="docutils literal"><span class="pre">mingw32-make</span></tt> instead.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id43" id="id7" name="id7">4.2&nbsp;&nbsp;&nbsp;A Simple C Example</a></h2>
<p>Let's now look at a very similar example of wrapping a fictional C library:</p>
<pre class="literal-block">
/* Define the interface to the word library. */

struct Word {
    const char *the_word;
};

struct Word *create_word(const char *w);
char *reverse(struct Word *word);
</pre>
<p>The corresponding SIP specification file would then look something like this:</p>
<pre class="literal-block">
/* Define the SIP wrapper to the word library. */

%CModule word 0

struct Word {

%TypeHeaderCode
#include &lt;word.h&gt;
%End

    const char *the_word;
};

struct Word *create_word(const char *w) /Factory/;
char *reverse(struct Word *word);
</pre>
<p>Again, let's look at the differences between the two files.</p>
<blockquote>
<ul class="simple">
<li>The <a class="reference" href="#cmodule">%CModule</a> directive has been added.  This has the same syntax as
the <a class="reference" href="#module">%Module</a> directive used in the previous example but tells SIP that
the library being wrapped is implemented in C rather than C++.</li>
<li>The <a class="reference" href="#typeheadercode">%TypeHeaderCode</a> directive has been added.</li>
<li>The <a class="reference" href="#factory">Factory</a> annotation has been added to the <tt class="docutils literal"><span class="pre">create_word()</span></tt> function.
This tells SIP that a newly created structure is being returned and it is
owned by Python.</li>
</ul>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">configure.py</span></tt> build system script described in the previous example can
be used for this example without change.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id44" id="a-more-complex-c-example" name="a-more-complex-c-example">4.3&nbsp;&nbsp;&nbsp;A More Complex C++ Example</a></h2>
<p>In this last example we will wrap a fictional C++ library that contains a class
that is derived from a Qt class.  This will demonstrate how SIP allows a class
hierarchy to be split across multiple Python extension modules, and will
introduce SIP's versioning system.</p>
<p>The library contains a single C++ class called <tt class="docutils literal"><span class="pre">Hello</span></tt> which is derived from
Qt's <tt class="docutils literal"><span class="pre">QLabel</span></tt> class.  It behaves just like <tt class="docutils literal"><span class="pre">QLabel</span></tt> except that the text
in the label is hard coded to be <tt class="docutils literal"><span class="pre">Hello</span> <span class="pre">World</span></tt>.  To make the example more
interesting we'll also say that the library only supports Qt v4.2 and later,
and also includes a function called <tt class="docutils literal"><span class="pre">setDefault()</span></tt> that is not implemented
in the Windows version of the library.</p>
<p>The <tt class="docutils literal"><span class="pre">hello.h</span></tt> header file looks something like this:</p>
<pre class="literal-block">
// Define the interface to the hello library.

#include &lt;qlabel.h&gt;
#include &lt;qwidget.h&gt;
#include &lt;qstring.h&gt;

class Hello : public QLabel {
    // This is needed by the Qt Meta-Object Compiler.
    Q_OBJECT

public:
    Hello(QWidget *parent, const char *name = 0, WFlags f = 0);

private:
    // Prevent instances from being copied.
    Hello(const Hello &amp;);
    Hello &amp;operator=(const Hello &amp;);
};

#if !defined(Q_OS_WIN)
void setDefault(const QString &amp;def);
#endif
</pre>
<p>The corresponding SIP specification file would then look something like this:</p>
<pre class="literal-block">
// Define the SIP wrapper to the hello library.

%Module hello 0

%Import QtCore/QtCoremod.sip

%If (Qt_4_2_0 -)

class Hello : QLabel {

%TypeHeaderCode
#include &lt;hello.h&gt;
%End

public:
    Hello(QWidget *parent /TransferThis/, const char *name = 0, WFlags f = 0);

private:
    Hello(const Hello &amp;);
};

%If (!WS_WIN)
void setDefault(const QString &amp;def);
%End

%End
</pre>
<p>Again we look at the differences, but we'll skip those that we've looked at in
previous examples.</p>
<blockquote>
<ul class="simple">
<li>The <a class="reference" href="#import">%Import</a> directive has been added to specify that we are extending
the class hierarchy defined in the file <tt class="docutils literal"><span class="pre">QtCore/QtCoremod.sip</span></tt>.  This
file is part of PyQt.  The build system will take care of finding the
file's exact location.</li>
<li>The <a class="reference" href="#if">%If</a> directive has been added to specify that everything <a class="footnote-reference" href="#id11" id="id8" name="id8">[4]</a> up to
the matching <a class="reference" href="#end">%End</a> directive only applies to Qt v4.2 and later.
<tt class="docutils literal"><span class="pre">Qt_4_2_0</span></tt> is a <em>tag</em> defined in <tt class="docutils literal"><span class="pre">QtCoremod.sip</span></tt> <a class="footnote-reference" href="#id12" id="id9" name="id9">[5]</a> using the
<a class="reference" href="#timeline">%Timeline</a> directive.  <a class="reference" href="#timeline">%Timeline</a> is used to define a tag for each
version of a library's API you are wrapping allowing you to maintain all
the different versions in a single SIP specification.  The build system
provides support to <tt class="docutils literal"><span class="pre">configure.py</span></tt> scripts for working out the correct
tags to use according to which version of the library is actually
installed.</li>
<li>The <tt class="docutils literal"><span class="pre">public</span></tt> keyword used in defining the super-classes has been
removed.  This is not supported by SIP.</li>
<li>The TransferThis annotation has been added to the first argument
of the constructor.  It specifies that if the argument is not 0 (i.e. the
<tt class="docutils literal"><span class="pre">Hello</span></tt> instance being constructed has a parent) then ownership of the
instance is transferred from Python to C++.  It is needed because Qt
maintains objects (i.e. instances derived from the <tt class="docutils literal"><span class="pre">QObject</span></tt> class) in
a hierachy.  When an object is destroyed all of its children are also
automatically destroyed.  It is important, therefore, that the Python
garbage collector doesn't also try and destroy them.  This is covered in
more detail in <a class="reference" href="#ownership-of-objects">Ownership of Objects</a>.  SIP provides many other
annotations that can be applied to arguments, functions and classes.
Multiple annotations are separated by commas.  Annotations may have
values.</li>
<li>The <tt class="docutils literal"><span class="pre">=</span></tt> operator has been removed.  This operator is not supported by
SIP.</li>
<li>The <a class="reference" href="#if">%If</a> directive has been added to specify that everything up to the
matching <a class="reference" href="#end">%End</a> directive does not apply to Windows.  <tt class="docutils literal"><span class="pre">WS_WIN</span></tt> is
another tag defined by PyQt, this time using the <a class="reference" href="#platforms">%Platforms</a> directive.
Tags defined by the <a class="reference" href="#platforms">%Platforms</a> directive are mutually exclusive, i.e.
only one may be valid at a time <a class="footnote-reference" href="#id13" id="id10" name="id10">[6]</a>.</li>
</ul>
</blockquote>
<p>One question you might have at this point is why bother to define the private
copy constructor when it can never be called from Python?  The answer is to
prevent the automatic generation of a public copy constructor.</p>
<p>We now look at the <tt class="docutils literal"><span class="pre">configure.py</span></tt> script.  This is a little different to the
script in the previous examples for two related reasons.</p>
<p>Firstly, PyQt includes a pure Python module called <tt class="docutils literal"><span class="pre">pyqtconfig</span></tt> that extends
the SIP build system for modules, like our example, that build on top of PyQt.
It deals with the details of which version of Qt is being used (i.e. it
determines what the correct tags are) and where it is installed.  This is
called a module's configuration module.</p>
<p>Secondly, we generate a configuration module (called <tt class="docutils literal"><span class="pre">helloconfig</span></tt>) for our
own <tt class="docutils literal"><span class="pre">hello</span></tt> module.  There is no need to do this, but if there is a chance
that somebody else might want to extend your C++ library then it would make
life easier for them.</p>
<p>Now we have two scripts.  First the <tt class="docutils literal"><span class="pre">configure.py</span></tt> script:</p>
<pre class="literal-block">
import os
import sipconfig
import pyqtconfig

# The name of the SIP build file generated by SIP and used by the build
# system.
build_file = &quot;hello.sbf&quot;

# Get the PyQt configuration information.
config = pyqtconfig.Configuration()

# Get the extra SIP flags needed by the imported qt module.  Note that
# this normally only includes those flags (-x and -t) that relate to SIP's
# versioning system.
qt_sip_flags = config.pyqt_qt_sip_flags

# Run SIP to generate the code.  Note that we tell SIP where to find the qt
# module's specification files using the -I flag.
os.system(&quot; &quot;.join([config.sip_bin, &quot;-c&quot;, &quot;.&quot;, &quot;-b&quot;, build_file, &quot;-I&quot;, config.pyqt_sip_dir, qt_sip_flags, &quot;hello.sip&quot;]))

# We are going to install the SIP specification file for this module and
# its configuration module.
installs = []

installs.append([&quot;hello.sip&quot;, os.path.join(config.default_sip_dir, &quot;hello&quot;)])

installs.append([&quot;helloconfig.py&quot;, config.default_mod_dir])

# Create the Makefile.  The QtModuleMakefile class provided by the
# pyqtconfig module takes care of all the extra preprocessor, compiler and
# linker flags needed by the Qt library.
makefile = pyqtconfig.QtModuleMakefile(
    configuration=config,
    build_file=build_file,
    installs=installs
)

# Add the library we are wrapping.  The name doesn't include any platform
# specific prefixes or extensions (e.g. the &quot;lib&quot; prefix on UNIX, or the
# &quot;.dll&quot; extension on Windows).
makefile.extra_libs = [&quot;hello&quot;]

# Generate the Makefile itself.
makefile.generate()

# Now we create the configuration module.  This is done by merging a Python
# dictionary (whose values are normally determined dynamically) with a
# (static) template.
content = {
    # Publish where the SIP specifications for this module will be
    # installed.
    &quot;hello_sip_dir&quot;:    config.default_sip_dir,

    # Publish the set of SIP flags needed by this module.  As these are the
    # same flags needed by the qt module we could leave it out, but this
    # allows us to change the flags at a later date without breaking
    # scripts that import the configuration module.
    &quot;hello_sip_flags&quot;:  qt_sip_flags
}

# This creates the helloconfig.py module from the helloconfig.py.in
# template and the dictionary.
sipconfig.create_config_module(&quot;helloconfig.py&quot;, &quot;helloconfig.py.in&quot;, content)
</pre>
<p>Next we have the <tt class="docutils literal"><span class="pre">helloconfig.py.in</span></tt> template script:</p>
<pre class="literal-block">
import pyqtconfig

# These are installation specific values created when Hello was configured.
# The following line will be replaced when this template is used to create
# the final configuration module.
# &#64;SIP_CONFIGURATION&#64;

class Configuration(pyqtconfig.Configuration):
    &quot;&quot;&quot;The class that represents Hello configuration values.
    &quot;&quot;&quot;
    def __init__(self, sub_cfg=None):
        &quot;&quot;&quot;Initialise an instance of the class.

        sub_cfg is the list of sub-class configurations.  It should be None
        when called normally.
        &quot;&quot;&quot;
        # This is all standard code to be copied verbatim except for the
        # name of the module containing the super-class.
        if sub_cfg:
            cfg = sub_cfg
        else:
            cfg = []

        cfg.append(_pkg_config)

        pyqtconfig.Configuration.__init__(self, cfg)

class HelloModuleMakefile(pyqtconfig.QtModuleMakefile):
    &quot;&quot;&quot;The Makefile class for modules that %Import hello.
    &quot;&quot;&quot;
    def finalise(self):
        &quot;&quot;&quot;Finalise the macros.
        &quot;&quot;&quot;
        # Make sure our C++ library is linked.
        self.extra_libs.append(&quot;hello&quot;)

        # Let the super-class do what it needs to.
        pyqtconfig.QtModuleMakefile.finalise(self)
</pre>
<p>Again, we hope that the scripts are self documenting.</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8" name="id11">[4]</a></td><td>Some parts of a SIP specification aren't subject to version control.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9" name="id12">[5]</a></td><td>Actually in <tt class="docutils literal"><span class="pre">versions.sip</span></tt>.  PyQt uses the <a class="reference" href="#include">%Include</a> directive to
split the SIP specification for Qt across a large number of separate
<tt class="docutils literal"><span class="pre">.sip</span></tt> files.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10" name="id13">[6]</a></td><td>Tags can also be defined by the <a class="reference" href="#feature">%Feature</a> directive.  These tags are
not mutually exclusive, i.e. any number may be valid at a time.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id45" id="ownership-of-objects" name="ownership-of-objects">4.4&nbsp;&nbsp;&nbsp;Ownership of Objects</a></h2>
<p>When a C++ instance is wrapped a corresponding Python object is created.  The
Python object behaves as you would expect in regard to garbage collection - it
is garbage collected when its reference count reaches zero.  What then happens
to the corresponding C++ instance?  The obvious answer might be that the
instance's destructor is called.  However the library API may say that when the
instance is passed to a particular function, the library takes ownership of the
instance, i.e. responsibility for calling the instance's destructor is
transferred from the SIP generated module to the library.</p>
<p>Ownership of an instance may also be associated with another instance.  The
implication being that the owned instance will automatically be destroyed if
the owning instance is destroyed.  SIP keeps track of these relationships to
ensure that Python's cyclic garbage collector can detect and break any
reference cycles between the owning and owned instances.  The association is
implemented as the owning instance taking a reference to the owned instance.</p>
<p>The TransferThis, Transfer and TransferBack annotations are used to specify
where, and it what direction, transfers of ownership happen.  It is very
important that these are specified correctly to avoid crashes (where both
Python and C++ call the destructor) and memory leaks (where neither Python and
C++ call the destructor).</p>
<p>This applies equally to C structures where the structure is returned to the
heap using the <tt class="docutils literal"><span class="pre">free()</span></tt> function.</p>
<p>See also <a class="reference" href="#siptransferto">sipTransferTo()</a>, <a class="reference" href="#siptransferback">sipTransferBack()</a> and <a class="reference" href="#siptransferbreak">sipTransferBreak()</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id46" id="types-and-meta-types" name="types-and-meta-types">4.5&nbsp;&nbsp;&nbsp;Types and Meta-types</a></h2>
<p>Every Python object (with the exception of the <tt class="docutils literal"><span class="pre">object</span></tt> object itself) has a
meta-type and at least one super-type.  By default an object's meta-type is the
meta-type of its first super-type.</p>
<p>SIP implements two super-types, <tt class="docutils literal"><span class="pre">sip.simplewrapper</span></tt> and <tt class="docutils literal"><span class="pre">sip.wrapper</span></tt>, and
a meta-type, <tt class="docutils literal"><span class="pre">sip.wrappertype</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">sip.simplewrapper</span></tt> is the super-type of <tt class="docutils literal"><span class="pre">sip.wrapper</span></tt>.  The super-type of
<tt class="docutils literal"><span class="pre">sip.simplewrapper</span></tt> is <tt class="docutils literal"><span class="pre">object</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">sip.wrappertype</span></tt> is the meta-type of both <tt class="docutils literal"><span class="pre">sip.simplewrapper</span></tt> and
<tt class="docutils literal"><span class="pre">sip.wrapper</span></tt>.  The super-type of <tt class="docutils literal"><span class="pre">sip.wrappertype</span></tt> is <tt class="docutils literal"><span class="pre">type</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">sip.wrapper</span></tt> supports the concept of object ownership described in
<a class="reference" href="#ownership-of-objects">Ownership of Objects</a> and, by default, is the super-type of all the types
that SIP generates.</p>
<p><tt class="docutils literal"><span class="pre">sip.simplewrapper</span></tt> does not support the concept of object ownership but SIP
generated types that are sub-classed from it have Python objects that take less
memory.</p>
<p>SIP allows a class's meta-type and super-type to be explicitly specified using
the <a class="reference" href="#metatype">Metatype</a> and <a class="reference" href="#supertype">Supertype</a> class annotations.</p>
<p>SIP also allows the default meta-type and super-type to be changed for a module
using the <a class="reference" href="#defaultmetatype">%DefaultMetatype</a> and <a class="reference" href="#defaultsupertype">%DefaultSupertype</a> directives.</p>
<p>If you want to use your own meta-type or super-type then they must be
sub-classed from one of the SIP provided types.  Your types must be registered
using <a class="reference" href="#sipregisterpytype">sipRegisterPyType()</a>.  This is normally done in code specified using
the <a class="reference" href="#initialisationcode">%InitialisationCode</a> directive.</p>
<p>As an example, PyQt4 uses <a class="reference" href="#defaultmetatype">%DefaultMetatype</a> to specify a new meta-type that
handles the interaction with Qt's own meta-type system.  It also uses
<a class="reference" href="#defaultsupertype">%DefaultSupertype</a> to specify that the smaller <tt class="docutils literal"><span class="pre">sip.simplewrapper</span></tt>
super-type is normally used.  Finally it uses <a class="reference" href="#supertype">Supertype</a> as an annotation of
the <tt class="docutils literal"><span class="pre">QObject</span></tt> class to override the default and use <tt class="docutils literal"><span class="pre">sip.wrapper</span></tt> as the
super-type so that the parent/child relationships of <tt class="docutils literal"><span class="pre">QObject</span></tt> instances are
properly maintained.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id47" id="lazy-type-attributes" name="lazy-type-attributes">4.6&nbsp;&nbsp;&nbsp;Lazy Type Attributes</a></h2>
<p>Instead of populating a wrapped type's dictionary with its attributes (or
descriptors for those attributes) SIP only creates objects for those attributes
when they are actually needed.  This is done to reduce the memory footprint and
start up time when used to wrap large libraries with hundreds of classes and
tens of thousands of attributes.</p>
<p>SIP allows you to extend the handling of lazy attributes to your own attribute
types by allowing you to register an attribute getter handler (using
<a class="reference" href="#sipregisterattributegetter">sipRegisterAttributeGetter()</a>).  This will be called just before a type's
dictionary is accessed for the first time.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id48" id="support-for-python-s-buffer-interface" name="support-for-python-s-buffer-interface">4.7&nbsp;&nbsp;&nbsp;Support for Python's Buffer Interface</a></h2>
<p>SIP supports Python's buffer interface in that whenever C/C++ requires a
<tt class="docutils literal"><span class="pre">char</span></tt> or <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> type then any Python type that supports the buffer
interface (including ordinary Python strings) can be used.</p>
<p>If a buffer is made up of a number of segments then all but the first will be
ignored.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id49" id="support-for-wide-characters" name="support-for-wide-characters">4.8&nbsp;&nbsp;&nbsp;Support for Wide Characters</a></h2>
<p>SIP v4.6 introduced support for wide characters (i.e. the <tt class="docutils literal"><span class="pre">wchar_t</span></tt> type).
Python's C API includes support for converting between unicode objects and wide
character strings and arrays.  When converting from a unicode object to wide
characters SIP creates the string or array on the heap (using memory allocated
using <a class="reference" href="#sipmalloc">sipMalloc()</a>).  This then raises the problem of how this memory is
subsequently freed.</p>
<p>The following describes how SIP handles this memory in the different situations
where this is an issue.</p>
<blockquote>
<ul class="simple">
<li>When a wide string or array is passed to a function or method then the
memory is freed (using <a class="reference" href="#sipfree">sipFree()</a>) after than function or method
returns.</li>
<li>When a wide string or array is returned from a virtual method then SIP
does not free the memory until the next time the method is called.</li>
<li>When an assignment is made to a wide string or array instance variable
then SIP does not first free the instance's current string or array.</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id50" id="the-python-global-interpreter-lock" name="the-python-global-interpreter-lock">4.9&nbsp;&nbsp;&nbsp;The Python Global Interpreter Lock</a></h2>
<p>Python's Global Interpretor Lock (GIL) must be acquired before calls can be
made to the Python API.  It should also be released when a potentially
blocking call to C/C++ library is made in order to allow other Python threads
to be executed.  In addition, some C/C++ libraries may implement their own
locking strategies that conflict with the GIL causing application deadlocks.
SIP provides ways of specifying when the GIL is released and acquired to
ensure that locking problems can be avoided.</p>
<p>SIP always ensures that the GIL is acquired before making calls to the Python
API.  By default SIP does not release the GIL when making calls to the C/C++
library being wrapped.  The <a class="reference" href="#releasegil">ReleaseGIL</a> annotation can be used to override
this behaviour when required.</p>
<p>If SIP is given the <tt class="docutils literal"><span class="pre">-g</span></tt> command line option then the default behaviour is
changed and SIP releases the GIL every time is makes calls to the C/C++
library being wrapped.  The <a class="reference" href="#holdgil">HoldGIL</a> annotation can be used to override this
behaviour when required.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id51" id="the-sip-command-line" name="the-sip-command-line">5&nbsp;&nbsp;&nbsp;The SIP Command Line</a></h1>
<p>The syntax of the SIP command line is:</p>
<pre class="literal-block">
sip [options] [specification]
</pre>
<p><tt class="docutils literal"><span class="pre">specification</span></tt> is the name of the specification file for the module.  If it
is omitted then <tt class="docutils literal"><span class="pre">stdin</span></tt> is used.</p>
<p>The full set of command line options is:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-h</span></kbd></td>
<td>Display a help message.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-V</span></kbd></td>
<td>Display the SIP version number.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-a <var>file</var></span></kbd></td>
<td>The name of the QScintilla API file to generate.  This file contains a
description of the module API in a form that the QScintilla editor
component can use for auto-completion and call tips.  (The file may
also be used by the SciTE editor but must be sorted first.)  By default
the file is not generated.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-b <var>file</var></span></kbd></td>
<td>The name of the build file to generate.  This file contains the
information about the module needed by the SIP build system to generate
a platform and compiler specific Makefile for the module.  By default
the file is not generated.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-c <var>dir</var></span></kbd></td>
<td>The name of the directory (which must exist) into which all of the
generated C or C++ code is placed.  By default no code is generated.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-d <var>file</var></span></kbd></td>
<td>The name of the documentation file to generate.  Documentation is
included in specification files using the <a class="reference" href="#doc">%Doc</a> and <a class="reference" href="#exporteddoc">%ExportedDoc</a>
directives.  By default the file is not generated.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-e</span></kbd></td>
<td>Support for C++ exceptions is enabled.  This causes all calls to C++
code to be enclosed in <tt class="docutils literal"><span class="pre">try</span></tt>/<tt class="docutils literal"><span class="pre">catch</span></tt> blocks and C++ exceptions to
be converted to Python exceptions.  By default exception support is
disabled.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-g</span></kbd></td>
<td>The Python GIL is released before making any calls to the C/C++ library
being wrapped and reacquired afterwards.  See <a class="reference" href="#the-python-global-interpreter-lock">The Python Global
Interpreter Lock</a> and the <a class="reference" href="#releasegil">ReleaseGIL</a> and <a class="reference" href="#holdgil">HoldGIL</a> annotations.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-I <var>dir</var></span></kbd></td>
<td>The directory is added to the list of directories searched when looking
for a specification file given in an <a class="reference" href="#include">%Include</a> or <a class="reference" href="#import">%Import</a>
directive.  This option may be given any number of times.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-j <var>number</var></span></kbd></td>
<td>The generated code is split into the given number of files.  This make
it easier to use the parallel build facility of most modern
implementations of <tt class="docutils literal"><span class="pre">make</span></tt>.  By default 1 file is generated for each C
structure or C++ class.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-p <var>module</var></span></kbd></td>
<td>The name of the <a class="reference" href="#consolidatedmodule">%ConsolidatedModule</a> which will contain the wrapper
code for this component module.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-r</span></kbd></td>
<td>Debugging statements that trace the execution of the bindings are
automatically generated.  By default the statements are not generated.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-s <var>suffix</var></span></kbd></td>
<td>The suffix to use for generated C or C++ source files.  By default
<tt class="docutils literal"><span class="pre">.c</span></tt> is used for C and <tt class="docutils literal"><span class="pre">.cpp</span></tt> for C++.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-t <var>tag</var></span></kbd></td>
<td>The SIP version tag (declared using a <a class="reference" href="#timeline">%Timeline</a> directive) or the
SIP platform tag (declared using the <a class="reference" href="#platforms">%Platforms</a> directive) to
generate code for.  This option may be given any number of times so
long as the tags do not conflict.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-w</span></kbd></td>
<td>The display of warning messages is enabled.  By default warning
messages are disabled.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-x <var>feature</var></span></kbd></td>
<td>The feature (declared using the <a class="reference" href="#feature">%Feature</a> directive) is disabled.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-z <var>file</var></span></kbd></td>
<td>The name of a file containing more command line options.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id52" id="sip-specification-files" name="sip-specification-files">6&nbsp;&nbsp;&nbsp;SIP Specification Files</a></h1>
<p>A SIP specification consists of some C/C++ type and function declarations and
some directives.  The declarations may contain annotations which provide SIP
with additional information that cannot be expressed in C/C++.  SIP does not
include a full C/C++ parser.</p>
<p>It is important to understand that a SIP specification describes the Python
API, i.e. the API available to the Python programmer when they <tt class="docutils literal"><span class="pre">import</span></tt> the
generated module.  It does not have to accurately represent the underlying
C/C++ library.  There is nothing wrong with omitting functions that make
little sense in a Python context, or adding functions implemented with
handwritten code that have no C/C++ equivalent.  It is even possible (and
sometimes necessary) to specify a different super-class hierarchy for a C++
class.  All that matters is that the generated code compiles properly.</p>
<p>In most cases the Python API matches the C/C++ API.  In some cases handwritten
code (see <a class="reference" href="#methodcode">%MethodCode</a>) is used to map from one to the other without SIP
having to know the details itself.  However, there are a few cases where SIP
generates a thin wrapper around a C++ method or constructor (see <a class="reference" href="#generated-derived-classes">Generated
Derived Classes</a>) and needs to know the exact C++ signature.  To deal with
these cases SIP allows two signatures to be specified.  For example:</p>
<pre class="literal-block">
class Klass
{
public:
    // The Python signature is a tuple, but the underlying C++ signature
    // is a 2 element array.
    Klass(SIP_PYTUPLE) [(int *)];
%MethodCode
        int iarr[2];

        if (PyArg_ParseTuple(a0, &quot;ii&quot;, &amp;iarr[0], &amp;iarr[1]))
        {
            // Note that we use the SIP generated derived class
            // constructor.
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipKlass(iarr);
            Py_END_ALLOW_THREADS
        }
%End
};
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id53" id="syntax-definition" name="syntax-definition">6.1&nbsp;&nbsp;&nbsp;Syntax Definition</a></h2>
<p>The following is a semi-formal description of the syntax of a specification
file.</p>
<pre class="literal-block">
<em>specification</em> ::= {<em>module-statement</em>}

<em>module-statement</em> ::= [<em>module-directive</em> | <em>statement</em>]

<em>module-directive</em> ::= [<a class="reference" href="#cmodule">%CModule</a> | <a class="reference" href="#compositemodule">%CompositeModule</a> |
        <a class="reference" href="#consolidatedmodule">%ConsolidatedModule</a> | <a class="reference" href="#copying">%Copying</a> | <a class="reference" href="#defaultencoding">%DefaultEncoding</a> |
        <a class="reference" href="#defaultmetatype">%DefaultMetatype</a> | <a class="reference" href="#defaultsupertype">%DefaultSupertype</a> | <a class="reference" href="#doc">%Doc</a> |
        <a class="reference" href="#exporteddoc">%ExportedDoc</a> | <a class="reference" href="#exportedheadercode">%ExportedHeaderCode</a> | <a class="reference" href="#feature">%Feature</a> |
        <a class="reference" href="#import">%Import</a> | <a class="reference" href="#include">%Include</a> | <a class="reference" href="#initialisationcode">%InitialisationCode</a> | <a class="reference" href="#id14">%License</a> |
        <a class="reference" href="#mappedtype">%MappedType</a> | <em>mapped-type-template</em> | <a class="reference" href="#module">%Module</a> |
        <a class="reference" href="#modulecode">%ModuleCode</a> | <a class="reference" href="#moduleheadercode">%ModuleHeaderCode</a> | <a class="reference" href="#optionalinclude">%OptionalInclude</a> |
        <a class="reference" href="#platforms">%Platforms</a> | <a class="reference" href="#preinitialisationcode">%PreInitialisationCode</a> |
        <a class="reference" href="#postinitialisationcode">%PostInitialisationCode</a> | <a class="reference" href="#timeline">%Timeline</a> | <a class="reference" href="#unitcode">%UnitCode</a>]

<em>statement</em> :: [<em>class-statement</em> | <em>function</em> | <em>variable</em>]

<em>class-statement</em> :: [<a class="reference" href="#if">%If</a> | <em>class</em> | <em>class-template</em> | <em>enum</em> |
        <em>namespace</em> | <em>opaque-class</em> | <em>operator</em> | <em>struct</em> | <em>typedef</em> |
        <em>exception</em>]

<em>class</em> ::= <tt class="docutils literal"><span class="pre">class</span></tt> <em>name</em> [<tt class="docutils literal"><span class="pre">:</span></tt> <em>super-classes</em>] [<em>class-annotations</em>]
        <tt class="docutils literal"><span class="pre">{</span></tt> {<em>class-line</em>} <tt class="docutils literal"><span class="pre">};</span></tt>

<em>super-classes</em> ::= <em>name</em> [<tt class="docutils literal"><span class="pre">,</span></tt> <em>super-classes</em>]

<em>class-line</em> ::= [<em>class-statement</em> | <a class="reference" href="#bigetbuffercode">%BIGetBufferCode</a> |
        <a class="reference" href="#bigetreadbuffercode">%BIGetReadBufferCode</a> | <a class="reference" href="#bigetwritebuffercode">%BIGetWriteBufferCode</a> |
        <a class="reference" href="#bigetsegcountcode">%BIGetSegCountCode</a> | <a class="reference" href="#bigetcharbuffercode">%BIGetCharBufferCode</a> |
        <cite>%BIReleaseBufferCode</cite> | <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> |
        <a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> | <a class="reference" href="#gcclearcode">%GCClearCode</a> | <a class="reference" href="#gctraversecode">%GCTraverseCode</a> |
        <a class="reference" href="#picklecode">%PickleCode</a> | <a class="reference" href="#typecode">%TypeCode</a> | <a class="reference" href="#typeheadercode">%TypeHeaderCode</a> |
        <em>constructor</em> | <em>destructor</em> | <em>method</em> | <em>static-method</em> |
        <em>virtual-method</em> | <em>special-method</em> | <em>operator</em> |
        <em>virtual-operator</em> | <em>class-variable</em> | <tt class="docutils literal"><span class="pre">public:</span></tt> |
        <tt class="docutils literal"><span class="pre">public</span> <span class="pre">slots:</span></tt> | <tt class="docutils literal"><span class="pre">protected:</span></tt> | <tt class="docutils literal"><span class="pre">protected</span> <span class="pre">slots:</span></tt> |
        <tt class="docutils literal"><span class="pre">private:</span></tt> | <tt class="docutils literal"><span class="pre">private</span> <span class="pre">slots:</span></tt> | <tt class="docutils literal"><span class="pre">signals:</span></tt>]

<em>constructor</em> ::= [<tt class="docutils literal"><span class="pre">explicit</span></tt>] <em>name</em> <tt class="docutils literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="docutils literal"><span class="pre">)</span></tt>
        [<em>exceptions</em>] [<em>function-annotations</em>]
        [<em>c++-constructor-signature</em>] <tt class="docutils literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>]

<em>c++-constructor-signature</em> ::= <tt class="docutils literal"><span class="pre">[(</span></tt> [<em>argument-list</em>] <tt class="docutils literal"><span class="pre">)]</span></tt>

<em>destructor</em> ::= [<tt class="docutils literal"><span class="pre">virtual</span></tt>] <tt class="docutils literal"><span class="pre">~</span></tt> <em>name</em> <tt class="docutils literal"><span class="pre">()</span></tt> [<em>exceptions</em>] [<tt class="docutils literal"><span class="pre">=</span> <span class="pre">0</span></tt>]
        [<em>function-annotations</em>] <tt class="docutils literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>]
        [<a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a>]

<em>method</em> ::= <em>type</em> <em>name</em> <tt class="docutils literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="docutils literal"><span class="pre">)</span></tt> [<tt class="docutils literal"><span class="pre">const</span></tt>]
        [<em>exceptions</em>] [<tt class="docutils literal"><span class="pre">=</span> <span class="pre">0</span></tt>] [<em>function-annotations</em>] [<em>c++-signature</em>]
        <tt class="docutils literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>]

<em>c++-signature</em> ::= <tt class="docutils literal"><span class="pre">[</span></tt> <em>type</em> <tt class="docutils literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="docutils literal"><span class="pre">)]</span></tt>

<em>static-method</em> ::= <tt class="docutils literal"><span class="pre">static</span></tt> <em>function</em>

<em>virtual-method</em> ::= <tt class="docutils literal"><span class="pre">virtual</span></tt> <em>type</em> <em>name</em> <tt class="docutils literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="docutils literal"><span class="pre">)</span></tt>
        [<tt class="docutils literal"><span class="pre">const</span></tt>] [<em>exceptions</em>] [<tt class="docutils literal"><span class="pre">=</span> <span class="pre">0</span></tt>] [<em>function-annotations</em>]
        [<em>c++-signature</em>] <tt class="docutils literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>] [<a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a>]

<em>special-method</em> ::= <em>type</em> <em>special-method-name</em>
        <tt class="docutils literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="docutils literal"><span class="pre">)</span></tt> [<em>function-annotations</em>] <tt class="docutils literal"><span class="pre">;</span></tt>
        [<a class="reference" href="#methodcode">%MethodCode</a>]

<em>special-method-name</em> ::= [ <tt class="docutils literal"><span class="pre">__abs__</span></tt> | <tt class="docutils literal"><span class="pre">__add__</span></tt> | <tt class="docutils literal"><span class="pre">__and__</span></tt> |
        <tt class="docutils literal"><span class="pre">__call__</span></tt> | <tt class="docutils literal"><span class="pre">__cmp__</span></tt> | <tt class="docutils literal"><span class="pre">__contains__</span></tt> | <tt class="docutils literal"><span class="pre">__delitem__</span></tt> |
        <tt class="docutils literal"><span class="pre">__div__</span></tt> | <tt class="docutils literal"><span class="pre">__eq__</span></tt> | <tt class="docutils literal"><span class="pre">__float__</span></tt> | <tt class="docutils literal"><span class="pre">__ge__</span></tt> |
        <tt class="docutils literal"><span class="pre">__getitem__</span></tt> | <tt class="docutils literal"><span class="pre">__gt__</span></tt> | <tt class="docutils literal"><span class="pre">__hash__</span></tt> | <tt class="docutils literal"><span class="pre">__iadd__</span></tt> |
        <tt class="docutils literal"><span class="pre">__iand__</span></tt> | <tt class="docutils literal"><span class="pre">__idiv__</span></tt> | <tt class="docutils literal"><span class="pre">__ilshift__</span></tt> | <tt class="docutils literal"><span class="pre">__imod__</span></tt> |
        <tt class="docutils literal"><span class="pre">__imul__</span></tt> | <tt class="docutils literal"><span class="pre">__int__</span></tt> | <tt class="docutils literal"><span class="pre">__invert__</span></tt> | <tt class="docutils literal"><span class="pre">__ior__</span></tt> |
        <tt class="docutils literal"><span class="pre">__irshift__</span></tt> | <tt class="docutils literal"><span class="pre">__isub__</span></tt> | <tt class="docutils literal"><span class="pre">__ixor__</span></tt> | <tt class="docutils literal"><span class="pre">__le__</span></tt> |
        <tt class="docutils literal"><span class="pre">__len__</span></tt> | <tt class="docutils literal"><span class="pre">__long__</span></tt> | <tt class="docutils literal"><span class="pre">__lshift__</span></tt> | <tt class="docutils literal"><span class="pre">__lt__</span></tt> |
        <tt class="docutils literal"><span class="pre">__mod__</span></tt> | <tt class="docutils literal"><span class="pre">__mul__</span></tt> | <tt class="docutils literal"><span class="pre">__ne__</span></tt> | <tt class="docutils literal"><span class="pre">__neg__</span></tt> |
        <tt class="docutils literal"><span class="pre">__nonzero__</span></tt> | <tt class="docutils literal"><span class="pre">__or__</span></tt> | <tt class="docutils literal"><span class="pre">__pos__</span></tt> | <tt class="docutils literal"><span class="pre">__repr__</span></tt> |
        <tt class="docutils literal"><span class="pre">__rshift__</span></tt> | <tt class="docutils literal"><span class="pre">__setitem__</span></tt> | <tt class="docutils literal"><span class="pre">__str__</span></tt> | <tt class="docutils literal"><span class="pre">__sub__</span></tt> |
        <tt class="docutils literal"><span class="pre">__xor__</span></tt>]

<em>operator</em> ::= <em>operator-type</em>
        <tt class="docutils literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="docutils literal"><span class="pre">)</span></tt> [<tt class="docutils literal"><span class="pre">const</span></tt>] [<em>exceptions</em>]
        [<em>function-annotations</em>] <tt class="docutils literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>]

<em>virtual-operator</em> ::= <tt class="docutils literal"><span class="pre">virtual</span></tt> <em>operator-type</em>
        <tt class="docutils literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="docutils literal"><span class="pre">)</span></tt> [<tt class="docutils literal"><span class="pre">const</span></tt>] [<em>exceptions</em>] [<tt class="docutils literal"><span class="pre">=</span> <span class="pre">0</span></tt>]
        [<em>function-annotations</em>] <tt class="docutils literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>]
        [<a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a>]

<em>operatator-type</em> ::= [ <em>operator-function</em> | <em>operator-cast</em> ]

<em>operator-function</em> ::= <em>type</em> <tt class="docutils literal"><span class="pre">operator</span></tt> <em>operator-name</em>

<em>operator-cast</em> ::= <tt class="docutils literal"><span class="pre">operator</span></tt> <em>type</em>

<em>operator-name</em> ::= [<tt class="docutils literal"><span class="pre">+</span></tt> | <tt class="docutils literal"><span class="pre">-</span></tt> | <tt class="docutils literal"><span class="pre">*</span></tt> | <tt class="docutils literal"><span class="pre">/</span></tt> | <tt class="docutils literal"><span class="pre">%</span></tt> | <tt class="docutils literal"><span class="pre">&amp;</span></tt> |
        <tt class="docutils literal"><span class="pre">|</span></tt> | <tt class="docutils literal"><span class="pre">^</span></tt> | <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> | <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> | <tt class="docutils literal"><span class="pre">+=</span></tt> | <tt class="docutils literal"><span class="pre">-=</span></tt> | <tt class="docutils literal"><span class="pre">*=</span></tt> |
        <tt class="docutils literal"><span class="pre">/=</span></tt> | <tt class="docutils literal"><span class="pre">%=</span></tt> | <tt class="docutils literal"><span class="pre">&amp;=</span></tt> | <tt class="docutils literal"><span class="pre">|=</span></tt> | <tt class="docutils literal"><span class="pre">^=</span></tt> | <tt class="docutils literal"><span class="pre">&lt;&lt;=</span></tt> | <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> |
        <tt class="docutils literal"><span class="pre">~</span></tt> | <tt class="docutils literal"><span class="pre">()</span></tt> | <tt class="docutils literal"><span class="pre">[]</span></tt> | <tt class="docutils literal"><span class="pre">&lt;</span></tt> | <tt class="docutils literal"><span class="pre">&lt;=</span></tt> | <tt class="docutils literal"><span class="pre">==</span></tt> | <tt class="docutils literal"><span class="pre">!=</span></tt> |
        <tt class="docutils literal"><span class="pre">&gt;</span></tt> | <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>]

<em>class-variable</em> ::= [<tt class="docutils literal"><span class="pre">static</span></tt>] <em>variable</em>

<em>class-template</em> :: = <tt class="docutils literal"><span class="pre">template</span></tt> <tt class="docutils literal"><span class="pre">&lt;</span></tt> <em>type-list</em> <tt class="docutils literal"><span class="pre">&gt;</span></tt> <em>class</em>

<em>mapped-type-template</em> :: = <tt class="docutils literal"><span class="pre">template</span></tt> <tt class="docutils literal"><span class="pre">&lt;</span></tt> <em>type-list</em> <tt class="docutils literal"><span class="pre">&gt;</span></tt>
        <a class="reference" href="#mappedtype">%MappedType</a>

<em>enum</em> ::= <tt class="docutils literal"><span class="pre">enum</span></tt> [<em>name</em>] [<em>enum-annotations</em>] <tt class="docutils literal"><span class="pre">{</span></tt> {<em>enum-line</em>} <tt class="docutils literal"><span class="pre">};</span></tt>

<em>enum-line</em> ::= [<a class="reference" href="#if">%If</a> | <em>name</em> [<em>enum-annotations</em>] <tt class="docutils literal"><span class="pre">,</span></tt>

<em>function</em> ::= <em>type</em> <em>name</em> <tt class="docutils literal"><span class="pre">(</span></tt> [<em>argument-list</em>] <tt class="docutils literal"><span class="pre">)</span></tt> [<em>exceptions</em>]
        [<em>function-annotations</em>] <tt class="docutils literal"><span class="pre">;</span></tt> [<a class="reference" href="#methodcode">%MethodCode</a>]

<em>namespace</em> ::= <tt class="docutils literal"><span class="pre">namespace</span></tt> <em>name</em> <tt class="docutils literal"><span class="pre">{</span></tt> {<em>namespace-line</em>} <tt class="docutils literal"><span class="pre">};</span></tt>

<em>namespace-line</em> ::= [<a class="reference" href="#typeheadercode">%TypeHeaderCode</a> | <em>statement</em>]

<em>opaque-class</em> ::= <tt class="docutils literal"><span class="pre">class</span></tt> <em>scoped-name</em> <tt class="docutils literal"><span class="pre">;</span></tt>

<em>struct</em> ::= <tt class="docutils literal"><span class="pre">struct</span></tt> <em>name</em> <tt class="docutils literal"><span class="pre">{</span></tt> {<em>class-line</em>} <tt class="docutils literal"><span class="pre">};</span></tt>

<em>typedef</em> ::= <tt class="docutils literal"><span class="pre">typedef</span></tt> [<em>typed-name</em> | <em>function-pointer</em>]
        <em>typedef-annotations</em> <tt class="docutils literal"><span class="pre">;</span></tt>

<em>variable</em>::= <em>typed-name</em> [<em>variable-annotations</em>] <tt class="docutils literal"><span class="pre">;</span></tt> [<a class="reference" href="#accesscode">%AccessCode</a>]
        [<a class="reference" href="#getcode">%GetCode</a>] [<a class="reference" href="#setcode">%SetCode</a>]

<em>exception</em> ::= <a class="reference" href="#exception">%Exception</a> <em>exception-name</em> [<em>exception-base</em>] <tt class="docutils literal"><span class="pre">{</span></tt>
        [<a class="reference" href="#typeheadercode">%TypeHeaderCode</a>] <a class="reference" href="#raisecode">%RaiseCode</a> <cite>};`</cite>

<em>exception-name</em> ::= <em>scoped-name</em>

<em>exception-base</em> ::= <tt class="docutils literal"><span class="pre">(</span></tt> [<em>exception-name</em> | <em>python-exception</em>] <tt class="docutils literal"><span class="pre">)</span></tt>

<em>python-exception</em> ::= [<tt class="docutils literal"><span class="pre">SIP_Exception</span></tt> | <tt class="docutils literal"><span class="pre">SIP_StopIteration</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_StandardError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_ArithmeticError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_LookupError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_AssertionError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_AttributeError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_EOFError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_FloatingPointError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_EnvironmentError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_IOError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_OSError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_ImportError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_IndexError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_KeyError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_KeyboardInterrupt</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_MemoryError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_NameError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_OverflowError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_RuntimeError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_NotImplementedError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_SyntaxError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_IndentationError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_TabError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_ReferenceError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_SystemError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_SystemExit</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_TypeError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_UnboundLocalError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_UnicodeError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_UnicodeEncodeError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_UnicodeDecodeError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_UnicodeTranslateError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_ValueError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_ZeroDivisionError</span></tt> |
        <tt class="docutils literal"><span class="pre">SIP_WindowsError</span></tt> | <tt class="docutils literal"><span class="pre">SIP_VMSError</span></tt>]

<em>exceptions</em> ::= <tt class="docutils literal"><span class="pre">throw</span> <span class="pre">(</span></tt> [<em>exception-list</em>] <tt class="docutils literal"><span class="pre">)</span></tt>

<em>exception-list</em> ::= <em>scoped-name</em> [<tt class="docutils literal"><span class="pre">,</span></tt> <em>exception-list</em>]

<em>argument-list</em> ::= <em>argument</em> [<tt class="docutils literal"><span class="pre">,</span></tt> <em>argument-list</em>] [<tt class="docutils literal"><span class="pre">,</span></tt> <tt class="docutils literal"><span class="pre">...</span></tt>]

<em>argument</em> ::= [<em>type</em> [<em>name</em>] [<em>argument-annotations</em>]
        [<em>default-value</em>] | <a class="reference" href="#sip-anyslot">SIP_ANYSLOT</a> [<em>default-value</em>] | <a class="reference" href="#sip-qobject">SIP_QOBJECT</a> |
        <a class="reference" href="#sip-rxobj-con">SIP_RXOBJ_CON</a> | <a class="reference" href="#sip-rxobj-dis">SIP_RXOBJ_DIS</a> | <a class="reference" href="#sip-signal">SIP_SIGNAL</a> [<em>default-value</em>] |
        <a class="reference" href="#sip-slot">SIP_SLOT</a> [<em>default-value</em>] | <a class="reference" href="#sip-slot-con">SIP_SLOT_CON</a> | <a class="reference" href="#sip-slot-dis">SIP_SLOT_DIS</a>]

<em>default-value</em> ::= <tt class="docutils literal"><span class="pre">=</span></tt> <em>expression</em>

<em>expression</em> ::= [<em>value</em> | <em>value</em> <em>binary-operator</em> <em>expression</em>]

<em>value</em> ::= [<em>unary-operator</em>] <em>simple-value</em>

<em>simple-value</em> ::= [<em>scoped-name</em> | <em>function-call</em> | <em>real-value</em> |
        <em>integer-value</em> | <em>boolean-value</em> | <em>string-value</em> |
        <em>character-value</em>]

<em>typed-name</em>::= <em>type</em> <em>name</em>

<em>function-pointer</em>::= <em>type</em> <tt class="docutils literal"><span class="pre">(*</span></tt> <em>name</em> <tt class="docutils literal"><span class="pre">)(</span></tt> [<em>type-list</em>] <tt class="docutils literal"><span class="pre">)</span></tt>

<em>type-list</em> ::= <em>type</em> [<tt class="docutils literal"><span class="pre">,</span></tt> <em>type-list</em>]

<em>function-call</em> ::= <em>scoped-name</em> <tt class="docutils literal"><span class="pre">(</span></tt> [<em>value-list</em>] <tt class="docutils literal"><span class="pre">)</span></tt>

<em>value-list</em> ::= <em>value</em> [<tt class="docutils literal"><span class="pre">,</span></tt> <em>value-list</em>]

<em>real-value</em> ::= a floating point number

<em>integer-value</em> ::= a number

<em>boolean-value</em> ::= [<tt class="docutils literal"><span class="pre">true</span></tt> | <tt class="docutils literal"><span class="pre">false</span></tt>]

<em>string-value</em> ::= <tt class="docutils literal"><span class="pre">&quot;</span></tt> {<em>character</em>} <tt class="docutils literal"><span class="pre">&quot;</span></tt>

<em>character-value</em> ::= <tt class="docutils literal"><span class="pre">`</span></tt> <em>character</em> <tt class="docutils literal"><span class="pre">`</span></tt>

<em>unary-operator</em> ::= [<tt class="docutils literal"><span class="pre">!</span></tt> | <tt class="docutils literal"><span class="pre">~</span></tt> | <tt class="docutils literal"><span class="pre">-</span></tt> | <tt class="docutils literal"><span class="pre">+</span></tt>]

<em>binary-operator</em> ::= [<tt class="docutils literal"><span class="pre">-</span></tt> | <tt class="docutils literal"><span class="pre">+</span></tt> | <tt class="docutils literal"><span class="pre">*</span></tt> | <tt class="docutils literal"><span class="pre">/</span></tt> | <tt class="docutils literal"><span class="pre">&amp;</span></tt> | <tt class="docutils literal"><span class="pre">|</span></tt>]

<em>argument-annotations</em> ::= see <a class="reference" href="#argument-annotations">Argument Annotations</a>

<em>class-annotations</em> ::= see <a class="reference" href="#class-annotations">Class Annotations</a>

<em>enum-annotations</em> ::= see <a class="reference" href="#enum-annotations">Enum Annotations</a>

<em>function-annotations</em> ::= see <a class="reference" href="#function-annotations">Function Annotations</a>

<em>typedef-annotations</em> ::= see <a class="reference" href="#typedef-annotations">Typedef Annotations</a>

<em>variable-annotations</em> ::= see <a class="reference" href="#variable-annotations">Variable Annotations</a>

<em>type</em> ::= [<tt class="docutils literal"><span class="pre">const</span></tt>] <em>base-type</em> {<tt class="docutils literal"><span class="pre">*</span></tt>} [<tt class="docutils literal"><span class="pre">&amp;</span></tt>]

<em>type-list</em> ::= <em>type</em> [<tt class="docutils literal"><span class="pre">,</span></tt> <em>type-list</em>]

<em>base-type</em> ::= [<em>scoped-name</em> | <em>template</em> | <tt class="docutils literal"><span class="pre">struct</span></tt> <em>scoped-name</em> |
        <tt class="docutils literal"><span class="pre">short</span></tt> | <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></tt> | <tt class="docutils literal"><span class="pre">int</span></tt> | <tt class="docutils literal"><span class="pre">unsigned</span></tt> |
        <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> | <tt class="docutils literal"><span class="pre">long</span></tt> | <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt> | <tt class="docutils literal"><span class="pre">float</span></tt> |
        <tt class="docutils literal"><span class="pre">double</span></tt> | <tt class="docutils literal"><span class="pre">bool</span></tt> | <tt class="docutils literal"><span class="pre">char</span></tt> | <tt class="docutils literal"><span class="pre">signed</span> <span class="pre">char</span></tt> |
        <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt> | <tt class="docutils literal"><span class="pre">void</span></tt> | <tt class="docutils literal"><span class="pre">wchar_t</span></tt> | <a class="reference" href="#sip-pycallable">SIP_PYCALLABLE</a> |
        <a class="reference" href="#sip-pydict">SIP_PYDICT</a> | <a class="reference" href="#sip-pylist">SIP_PYLIST</a> | <a class="reference" href="#sip-pyobject">SIP_PYOBJECT</a> | <a class="reference" href="#sip-pyslice">SIP_PYSLICE</a> |
        <a class="reference" href="#sip-pytuple">SIP_PYTUPLE</a> | <a class="reference" href="#sip-pytype">SIP_PYTYPE</a>]

<em>scoped-name</em> ::= <em>name</em> [<tt class="docutils literal"><span class="pre">::</span></tt> <em>scoped-name</em>]

<em>template</em> ::= <em>scoped-name</em> <tt class="docutils literal"><span class="pre">&lt;</span></tt> <em>type-list</em> <tt class="docutils literal"><span class="pre">&gt;</span></tt>

<em>dotted-name</em> ::= <em>name</em> [<tt class="docutils literal"><span class="pre">.</span></tt> <em>dotted-name</em>]

<em>name</em> ::= _A-Za-z {_A-Za-z0-9}
</pre>
<p>Here is a short list of differences between C++ and the subset supported by
SIP that might trip you up.</p>
<blockquote>
<ul class="simple">
<li>SIP does not support the use of <tt class="docutils literal"><span class="pre">[]</span></tt> in types.  Use pointers instead.</li>
<li>A global <tt class="docutils literal"><span class="pre">operator</span></tt> can only be defined if its first argument is a
class or a named enum that has been wrapped in the same module.</li>
<li>Variables declared outside of a class are effectively read-only.</li>
<li>A class's list of super-classes doesn't not include any access specifier
(e.g. <tt class="docutils literal"><span class="pre">public</span></tt>).</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id54" id="variable-numbers-of-arguments" name="variable-numbers-of-arguments">6.2&nbsp;&nbsp;&nbsp;Variable Numbers of Arguments</a></h2>
<p>SIP supports the use of <tt class="docutils literal"><span class="pre">...</span></tt> as the last part of a function signature.  Any
remaining arguments are collected as a Python tuple.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id55" id="additional-sip-types" name="additional-sip-types">6.3&nbsp;&nbsp;&nbsp;Additional SIP Types</a></h2>
<p>SIP supports a number of additional data types that can be used in Python
signatures.</p>
<div class="section">
<h3><a class="toc-backref" href="#id56" id="sip-anyslot" name="sip-anyslot">6.3.1&nbsp;&nbsp;&nbsp;SIP_ANYSLOT</a></h3>
<p>This is both a <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> and a <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is used as the type
of the member instead of <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> in functions that implement the
connection or disconnection of an explicitly generated signal to a slot.
Handwritten code must be provided to interpret the conversion correctly.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id57" id="sip-pycallable" name="sip-pycallable">6.3.2&nbsp;&nbsp;&nbsp;SIP_PYCALLABLE</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python callable object.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id58" id="sip-pydict" name="sip-pydict">6.3.3&nbsp;&nbsp;&nbsp;SIP_PYDICT</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python dictionary object.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id59" id="sip-pylist" name="sip-pylist">6.3.4&nbsp;&nbsp;&nbsp;SIP_PYLIST</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python list object.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id60" id="sip-pyobject" name="sip-pyobject">6.3.5&nbsp;&nbsp;&nbsp;SIP_PYOBJECT</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> of any Python type.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id61" id="sip-pyslice" name="sip-pyslice">6.3.6&nbsp;&nbsp;&nbsp;SIP_PYSLICE</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python slice object.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id62" id="sip-pytuple" name="sip-pytuple">6.3.7&nbsp;&nbsp;&nbsp;SIP_PYTUPLE</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python tuple object.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id63" id="sip-pytype" name="sip-pytype">6.3.8&nbsp;&nbsp;&nbsp;SIP_PYTYPE</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> that is a Python type object.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id64" id="sip-qobject" name="sip-qobject">6.3.9&nbsp;&nbsp;&nbsp;SIP_QOBJECT</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">QObject</span> <span class="pre">*</span></tt> that is a C++ instance of a class derived from Qt's
<tt class="docutils literal"><span class="pre">QObject</span></tt> class.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id65" id="sip-rxobj-con" name="sip-rxobj-con">6.3.10&nbsp;&nbsp;&nbsp;SIP_RXOBJ_CON</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">QObject</span> <span class="pre">*</span></tt> that is a C++ instance of a class derived from Qt's
<tt class="docutils literal"><span class="pre">QObject</span></tt> class.  It is used as the type of the receiver instead of <tt class="docutils literal"><span class="pre">const</span>
<span class="pre">QObject</span> <span class="pre">*</span></tt> in functions that implement a connection to a slot.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id66" id="sip-rxobj-dis" name="sip-rxobj-dis">6.3.11&nbsp;&nbsp;&nbsp;SIP_RXOBJ_DIS</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">QObject</span> <span class="pre">*</span></tt> that is a C++ instance of a class derived from Qt's
<tt class="docutils literal"><span class="pre">QObject</span></tt> class.  It is used as the type of the receiver instead of <tt class="docutils literal"><span class="pre">const</span>
<span class="pre">QObject</span> <span class="pre">*</span></tt> in functions that implement a disconnection from a slot.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id67" id="sip-signal" name="sip-signal">6.3.12&nbsp;&nbsp;&nbsp;SIP_SIGNAL</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> that is used as the type of the signal instead of
<tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> in functions that implement the connection or disconnection
of an explicitly generated signal to a slot.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id68" id="sip-slot" name="sip-slot">6.3.13&nbsp;&nbsp;&nbsp;SIP_SLOT</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> that is used as the type of the member instead of
<tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> in functions that implement the connection or disconnection
of an explicitly generated signal to a slot.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id69" id="sip-slot-con" name="sip-slot-con">6.3.14&nbsp;&nbsp;&nbsp;SIP_SLOT_CON</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> that is used as the type of the member instead of
<tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> in functions that implement the connection of an internally
generated signal to a slot.  The type includes a comma separated list of types
that is the C++ signature of of the signal.</p>
<p>To take an example, <tt class="docutils literal"><span class="pre">QAccel::connectItem()</span></tt> connects an internally generated
signal to a slot.  The signal is emitted when the keyboard accelerator is
activated and it has a single integer argument that is the ID of the
accelerator.  The C++ signature is:</p>
<pre class="literal-block">
bool connectItem(int id, const QObject *receiver, const char *member);
</pre>
<p>The corresponding SIP specification is:</p>
<pre class="literal-block">
bool connectItem(int, SIP_RXOBJ_CON, SIP_SLOT_CON(int));
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id70" id="sip-slot-dis" name="sip-slot-dis">6.3.15&nbsp;&nbsp;&nbsp;SIP_SLOT_DIS</a></h3>
<p>This is a <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> that is used as the type of the member instead of
<tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> in functions that implement the disconnection of an
internally generated signal to a slot.  The type includes a comma separated
list of types that is the C++ signature of of the signal.</p>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id71" id="sip-directives" name="sip-directives">7&nbsp;&nbsp;&nbsp;SIP Directives</a></h1>
<p>In this section we describe each of the directives that can be used in
specification files.  All directives begin with <tt class="docutils literal"><span class="pre">%</span></tt> as the first
non-whitespace character in a line.</p>
<p>Some directives have arguments or contain blocks of code or documentation.  In
the following descriptions these are shown in <em>italics</em>.  Optional arguments
are enclosed in [<em>brackets</em>].</p>
<p>Some directives are used to specify handwritten code.  Handwritten code must
not define names that start with the prefix <tt class="docutils literal"><span class="pre">sip</span></tt>.</p>
<div class="section">
<h2><a class="toc-backref" href="#id72" id="accesscode" name="accesscode">7.1&nbsp;&nbsp;&nbsp;%AccessCode</a></h2>
<pre class="literal-block">
%AccessCode
    <em>code</em>
%End
</pre>
<p>This directive is used immediately after the declaration of an instance of a
wrapped class or structure, or a pointer to such an instance.  You use it to
provide handwritten code that overrides the default behaviour.</p>
<p>For example:</p>
<pre class="literal-block">
class Klass;

Klass *klassInstance;
%AccessCode
    // In this contrived example the C++ library we are wrapping defines
    // klassInstance as Klass ** (which SIP doesn't support) so we
    // explicitly dereference it.
    if (klassInstance &amp;&amp; *klassInstance)
        return *klassInstance;

    // This will get converted to None.
    return 0;
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id73" id="bigetbuffercode" name="bigetbuffercode">7.2&nbsp;&nbsp;&nbsp;%BIGetBufferCode</a></h2>
<pre class="literal-block">
%BIGetBufferCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference" href="#bireleasebuffercode">%BIReleaseBufferCode</a>) is used to specify code
that implements the buffer interface of Python v3.  If Python v2 is being used
then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>Py_buffer *sipBuffer</dt>
<dd>This is a pointer to the Python buffer structure that the handwritten code
must populate.</dd>
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>int sipFlags</dt>
<dd>These are the flags that specify what elements of the <tt class="docutils literal"><span class="pre">sipBuffer</span></tt>
structure must be populated.</dd>
<dt>int sipRes</dt>
<dd>The handwritten code should set this to 0 if there was no error or -1 if
there was an error.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the the structure or class instance,
i.e. <tt class="docutils literal"><span class="pre">self</span></tt>.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id74" id="bigetcharbuffercode" name="bigetcharbuffercode">7.3&nbsp;&nbsp;&nbsp;%BIGetCharBufferCode</a></h2>
<pre class="literal-block">
%BIGetCharBufferCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference" href="#bigetreadbuffercode">%BIGetReadBufferCode</a>, <a class="reference" href="#bigetsegcountcode">%BIGetSegCountCode</a> and
<a class="reference" href="#bigetwritebuffercode">%BIGetWriteBufferCode</a>) is used to specify code that implements the buffer
interface of Python v2.  If Python v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>void **sipPtrPtr</dt>
<dd>This is the pointer used to return the address of the character buffer.</dd>
<dt>SIP_SSIZE_T sipRes</dt>
<dd>The handwritten code should set this to the length of the character buffer
or -1 if there was an error.</dd>
<dt>SIP_SSIZE_T sipSegment</dt>
<dd>This is the number of the segment of the character buffer.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the the structure or class instance,
i.e. <tt class="docutils literal"><span class="pre">self</span></tt>.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id75" id="bigetreadbuffercode" name="bigetreadbuffercode">7.4&nbsp;&nbsp;&nbsp;%BIGetReadBufferCode</a></h2>
<pre class="literal-block">
%BIGetReadBufferCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference" href="#bigetcharbuffercode">%BIGetCharBufferCode</a>, <a class="reference" href="#bigetsegcountcode">%BIGetSegCountCode</a> and
<a class="reference" href="#bigetwritebuffercode">%BIGetWriteBufferCode</a>) is used to specify code that implements the buffer
interface of Python v2.  If Python v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>void **sipPtrPtr</dt>
<dd>This is the pointer used to return the address of the read buffer.</dd>
<dt>SIP_SSIZE_T sipRes</dt>
<dd>The handwritten code should set this to the length of the read buffer or
-1 if there was an error.</dd>
<dt>SIP_SSIZE_T sipSegment</dt>
<dd>This is the number of the segment of the read buffer.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the the structure or class instance,
i.e. <tt class="docutils literal"><span class="pre">self</span></tt>.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id76" id="bigetsegcountcode" name="bigetsegcountcode">7.5&nbsp;&nbsp;&nbsp;%BIGetSegCountCode</a></h2>
<pre class="literal-block">
%BIGetSegCountCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference" href="#bigetcharbuffercode">%BIGetCharBufferCode</a>, <a class="reference" href="#bigetreadbuffercode">%BIGetReadBufferCode</a> and
<a class="reference" href="#bigetwritebuffercode">%BIGetWriteBufferCode</a>) is used to specify code that implements the buffer
interface of Python v2.  If Python v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>SIP_SSIZE_T *sipLenPtr</dt>
<dd>This is the pointer used to return the total length in bytes of all
segments of the buffer.</dd>
<dt>SIP_SSIZE_T sipRes</dt>
<dd>The handwritten code should set this to the number of segments that make
up the buffer.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the the structure or class instance,
i.e. <tt class="docutils literal"><span class="pre">self</span></tt>.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id77" id="bigetwritebuffercode" name="bigetwritebuffercode">7.6&nbsp;&nbsp;&nbsp;%BIGetWriteBufferCode</a></h2>
<pre class="literal-block">
%BIGetWriteBufferCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference" href="#bigetcharbuffercode">%BIGetCharBufferCode</a>, <a class="reference" href="#bigetreadbuffercode">%BIGetReadBufferCode</a>
and <a class="reference" href="#bigetsegcountcode">%BIGetSegCountCode</a> is used to specify code that implements the buffer
interface of Python v2.  If Python v3 is being used then this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>void **sipPtrPtr</dt>
<dd>This is the pointer used to return the address of the write buffer.</dd>
<dt>SIP_SSIZE_T sipRes</dt>
<dd>The handwritten code should set this to the length of the write buffer or
-1 if there was an error.</dd>
<dt>SIP_SSIZE_T sipSegment</dt>
<dd>This is the number of the segment of the write buffer.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the the structure or class instance,
i.e. <tt class="docutils literal"><span class="pre">self</span></tt>.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id78" id="bireleasebuffercode" name="bireleasebuffercode">7.7&nbsp;&nbsp;&nbsp;%BIReleaseBufferCode</a></h2>
<pre class="literal-block">
%BIReleaseBufferCode
    <em>code</em>
%End
</pre>
<p>This directive (along with <a class="reference" href="#bigetbuffercode">%BIGetBufferCode</a>) is used to specify code that
implements the buffer interface of Python v3.  If Python v2 is being used then
this is ignored.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>Py_buffer *sipBuffer</dt>
<dd>This is a pointer to the Python buffer structure.</dd>
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>PyObject *sipSelf</dt>
<dd>This is the Python object that wraps the the structure or class instance,
i.e. <tt class="docutils literal"><span class="pre">self</span></tt>.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id79" id="cmodule" name="cmodule">7.8&nbsp;&nbsp;&nbsp;%CModule</a></h2>
<pre class="literal-block">
%CModule <em>name</em> [<em>version</em>]
</pre>
<p>This directive is used to identify that the library being wrapped is a C
library and to define the name of the module and it's optional version number.</p>
<p>See the <a class="reference" href="#module">%Module</a> directive for an explanation of the version number.</p>
<p>For example:</p>
<pre class="literal-block">
%CModule dbus 1
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id80" id="compositemodule" name="compositemodule">7.9&nbsp;&nbsp;&nbsp;%CompositeModule</a></h2>
<pre class="literal-block">
%CompositeModule <em>name</em>
</pre>
<p>A composite module is one that merges a number of related SIP generated
modules.  For example, a module that merges the modules <tt class="docutils literal"><span class="pre">a_mod</span></tt>, <tt class="docutils literal"><span class="pre">b_mod</span></tt>
and <tt class="docutils literal"><span class="pre">c_mod</span></tt> is equivalent to the following pure Python module:</p>
<pre class="literal-block">
from a_mod import *
from b_mod import *
from c_mod import *
</pre>
<p>Clearly the individual modules should not define module-level objects with the
same name.</p>
<p>This directive is used to specify the name of a composite module.  Any
subsequent <a class="reference" href="#cmodule">%CModule</a> or <a class="reference" href="#module">%Module</a> directive is interpreted as defining a
component module.</p>
<p>For example:</p>
<pre class="literal-block">
%CompositeModule PyQt4.Qt
%Include QtCore/QtCoremod.sip
%Include QtGui/QtGuimod.sip
</pre>
<p>The main purpose of a composite module is as a programmer convenience as they
don't have to remember which which individual module an object is defined in.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id81" id="consolidatedmodule" name="consolidatedmodule">7.10&nbsp;&nbsp;&nbsp;%ConsolidatedModule</a></h2>
<pre class="literal-block">
%ConsolidatedModule <em>name</em>
</pre>
<p>A consolidated module is one that consolidates the wrapper code of a number of
SIP generated modules (refered to as component modules in this context).</p>
<p>This directive is used to specify the name of a consolidated module.  Any
subsequent <a class="reference" href="#cmodule">%CModule</a> or <a class="reference" href="#module">%Module</a> directive is interpreted as defining a
component module.</p>
<p>For example:</p>
<pre class="literal-block">
%ConsolidatedModule PyQt4._qt
%Include QtCore/QtCoremod.sip
%Include QtGui/QtGuimod.sip
</pre>
<p>A consolidated module is not intended to be explicitly imported by an
application.  Instead it is imported by its component modules when they
themselves are imported.</p>
<p>Normally the wrapper code is contained in the component module and is linked
against the corresponding C or C++ library.  The advantage of a consolidated
module is that it allows all of the wrapped C or C++ libraries to be linked
against a single module.  If the linking is done statically then deployment of
generated modules can be greatly simplified.</p>
<p>It follows that a component module can be built in one of two ways, as a
normal standalone module, or as a component of a consolidated module.  When
building as a component the <tt class="docutils literal"><span class="pre">-p</span></tt> command line option should be used to
specify the name of the consolidated module.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id82" id="convertfromtypecode" name="convertfromtypecode">7.11&nbsp;&nbsp;&nbsp;%ConvertFromTypeCode</a></h2>
<pre class="literal-block">
%ConvertFromTypeCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the <a class="reference" href="#mappedtype">%MappedType</a> directive to specify the
handwritten code that converts an instance of a mapped type to a Python
object.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the instance of the mapped type to be converted.  It
will never be zero as the conversion from zero to <tt class="docutils literal"><span class="pre">Py_None</span></tt> is handled
before the handwritten code is called.</dd>
<dt>PyObject *sipTransferObj</dt>
<dd>This specifies any desired ownership changes to the returned object.  If it
is <tt class="docutils literal"><span class="pre">NULL</span></tt> then the ownership should be left unchanged.  If it is
<tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership should be transferred to Python.  Otherwise
ownership should be transferred to C/C++ and the returned object associated
with <em>sipTransferObj</em>.  The code can choose to interpret these changes in
any way.  For example, if the code is converting a C++ container of wrapped
classes to a Python list it is likely that the ownership changes should be
made to each element of the list.</dd>
</dl>
<p>The handwritten code must explicitly return a <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt>.  If there was an
error then a Python exception must be raised and <tt class="docutils literal"><span class="pre">NULL</span></tt> returned.</p>
<p>The following example converts a <tt class="docutils literal"><span class="pre">QList&lt;QWidget</span> <span class="pre">*&gt;</span></tt> instance to a Python
list of <tt class="docutils literal"><span class="pre">QWidget</span></tt> instances:</p>
<pre class="literal-block">
%ConvertFromTypeCode
    PyObject *l;

    // Create the Python list of the correct length.
    if ((l = PyList_New(sipCpp -&gt; size())) == NULL)
        return NULL;

    // Go through each element in the C++ instance and convert it to a
    // wrapped QWidget.
    for (int i = 0; i &lt; sipCpp -&gt; size(); ++i)
    {
        QWidget *w = sipCpp -&gt; at(i);
        PyObject *wobj;

        // Get the Python wrapper for the QWidget instance, creating a new
        // one if necessary, and handle any ownership transfer.
        if ((wobj = sipConvertFromType(w, sipType_QWidget, sipTransferObj)) == NULL)
        {
            // There was an error so garbage collect the Python list.
            Py_DECREF(l);
            return NULL;
        }

        // Add the wrapper to the list.
        PyList_SET_ITEM(l, i, wobj);
    }

    // Return the Python list.
    return l;
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id83" id="converttosubclasscode" name="converttosubclasscode">7.12&nbsp;&nbsp;&nbsp;%ConvertToSubClassCode</a></h2>
<pre class="literal-block">
%ConvertToSubClassCode
    <em>code</em>
%End
</pre>
<p>When SIP needs to wrap a C++ class instance it first checks to make sure it
hasn't already done so.  If it has then it just returns a new reference to the
corresponding Python object.  Otherwise it creates a new Python object of the
appropriate type.  In C++ a function may be defined to return an instance of a
certain class, but can often return a sub-class instead.</p>
<p>This directive is used to specify handwritten code that exploits any available
real-time type information (RTTI) to see if there is a more specific Python
type that can be used when wrapping the C++ instance.  The RTTI may be
provided by the compiler or by the C++ instance itself.</p>
<p>The directive is included in the specification of one of the classes that the
handwritten code handles the type conversion for.  It doesn't matter which
one, but a sensible choice would be the one at the root of that class
hierarchy in the module.</p>
<p>Note that if a class hierarchy extends over a number of modules then this
directive should be used in each of those modules to handle the part of the
hierarchy defined in that module.  SIP will ensure that the different pieces
of code are called in the right order to determine the most specific Python
type to use.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the C++ class instance.</dd>
<dt>void **sipCppRet</dt>
<dd>When the sub-class is derived from more than one super-class then it is
possible that the C++ address of the instance as the sub-class is
different to that of the super-class.  If so, then this must be set to the
C++ address of the instance when cast (usually using <tt class="docutils literal"><span class="pre">static_cast</span></tt>)
from the super-class to the sub-class.</dd>
<dt>const sipTypeDef *sipType</dt>
<dd>The handwritten code must set this to the SIP generated type structure
that corresponds to the class instance.  (The type structure for class
<tt class="docutils literal"><span class="pre">Klass</span></tt> is <tt class="docutils literal"><span class="pre">sipType_Klass</span></tt>.)  If the RTTI of the class instance isn't
recognised then <tt class="docutils literal"><span class="pre">sipType</span></tt> must be set to <tt class="docutils literal"><span class="pre">NULL</span></tt>.  The code doesn't
have to recognise the exact class, only the most specific sub-class that
it can.</dd>
<dt>sipWrapperType *sipClass</dt>
<dd><p class="first">The handwritten code must set this to the SIP generated Python type object
that corresponds to the class instance.  (The type object for class
<tt class="docutils literal"><span class="pre">Klass</span></tt> is <tt class="docutils literal"><span class="pre">sipClass_Klass</span></tt>.)  If the RTTI of the class instance isn't
recognised then <tt class="docutils literal"><span class="pre">sipClass</span></tt> must be set to <tt class="docutils literal"><span class="pre">NULL</span></tt>.  The code doesn't
have to recognise the exact class, only the most specific sub-class that
it can.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use <tt class="docutils literal"><span class="pre">sipType</span></tt>.</p>
</dd>
</dl>
<p>The handwritten code must not explicitly return.</p>
<p>The following example shows the sub-class conversion code for <tt class="docutils literal"><span class="pre">QEvent</span></tt> based
class hierarchy in PyQt:</p>
<pre class="literal-block">
class QEvent
{
%ConvertToSubClassCode
    // QEvent sub-classes provide a unique type ID.
    switch (sipCpp-&gt;type())
    {
    case QEvent::Timer:
        sipType = sipType_QTimerEvent;
        break;

    case QEvent::KeyPress:
    case QEvent::KeyRelease:
        sipType = sipType_QKeyEvent;
        break;

    // Skip the remaining event types to keep the example short.

    default:
        // We don't recognise the type.
        sipType = NULL;
    }
%End

    // The rest of the class specification.

};
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id84" id="converttotypecode" name="converttotypecode">7.13&nbsp;&nbsp;&nbsp;%ConvertToTypeCode</a></h2>
<pre class="literal-block">
%ConvertToTypeCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify the handwritten code that converts a Python
object to a mapped type instance and to handle any ownership transfers.  It is
used as part of the <a class="reference" href="#mappedtype">%MappedType</a> directive and as part of a class
specification.  The code is also called to determine if the Python object is of
the correct type prior to conversion.</p>
<p>When used as part of a class specification it can automatically convert
additional types of Python object.  For example, PyQt uses it in the
specification of the <tt class="docutils literal"><span class="pre">QString</span></tt> class to allow Python string objects and
unicode objects to be used wherever <tt class="docutils literal"><span class="pre">QString</span></tt> instances are expected.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>int *sipIsErr</dt>
<dd>If this is <tt class="docutils literal"><span class="pre">NULL</span></tt> then the code is being asked to check the type of the
Python object.  The check must not have any side effects.  Otherwise the
code is being asked to convert the Python object and a non-zero value
should be returned through this pointer if an error occurred during the
conversion.</dd>
<dt>PyObject *sipPy</dt>
<dd>This is the Python object to be converted.</dd>
<dt><em>type</em> **sipCppPtr</dt>
<dd>This is a pointer through which the address of the mapped type instance (or
zero if appropriate) is returned.  Its value is undefined if <tt class="docutils literal"><span class="pre">sipIsErr</span></tt>
is <tt class="docutils literal"><span class="pre">NULL</span></tt>.</dd>
<dt>PyObject *sipTransferObj</dt>
<dd>This specifies any desired ownership changes to <em>sipPy</em>.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt>
then the ownership should be left unchanged.  If it is <tt class="docutils literal"><span class="pre">Py_None</span></tt> then
ownership should be transferred to Python.  Otherwise ownership should be
transferred to C/C++ and <em>sipPy</em> associated with <em>sipTransferObj</em>.  The
code can choose to interpret these changes in any way.</dd>
</dl>
<p>The handwritten code must explicitly return an <tt class="docutils literal"><span class="pre">int</span></tt> the meaning of which
depends on the value of <tt class="docutils literal"><span class="pre">sipIsErr</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">sipIsErr</span></tt> is <tt class="docutils literal"><span class="pre">NULL</span></tt> then a non-zero value is returned if the Python
object has a type that can be converted to the mapped type.  Otherwise zero is
returned.</p>
<p>If <tt class="docutils literal"><span class="pre">sipIsErr</span></tt> is not <tt class="docutils literal"><span class="pre">NULL</span></tt> then a combination of the following flags is
returned.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SIP_TEMPORARY</span></tt> is set to indicate that the returned instance is a
temporary and should be released to avoid a memory leak.</li>
<li><tt class="docutils literal"><span class="pre">SIP_DERIVED_CLASS</span></tt> is set to indicate that the type of the
returned instance is a derived class.  See <a class="reference" href="#generated-derived-classes">Generated Derived
Classes</a>.</li>
</ul>
</blockquote>
<p>The following example converts a Python list of <tt class="docutils literal"><span class="pre">QPoint</span></tt> instances to a
<tt class="docutils literal"><span class="pre">QList&lt;QPoint&gt;</span></tt> instance:</p>
<pre class="literal-block">
%ConvertToTypeCode
    // See if we are just being asked to check the type of the Python
    // object.
    if (!sipIsErr)
    {
        // Checking whether or not None has been passed instead of a list
        // has already been done.
        if (!PyList_Check(sipPy))
            return 0;

        // Check the type of each element.  We specify SIP_NOT_NONE to
        // disallow None because it is a list of QPoint, not of a pointer
        // to a QPoint, so None isn't appropriate.
        for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
            if (!sipCanConvertToType(PyList_GET_ITEM(sipPy, i),
                                     sipType_QPoint, SIP_NOT_NONE))
                return 0;

        // The type is valid.
        return 1;
    }

    // Create the instance on the heap.
    QList&lt;QPoint&gt; *ql = new QList&lt;QPoint&gt;;

    for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
    {
        QPoint *qp;
        int state;

        // Get the address of the element's C++ instance.  Note that, in
        // this case, we don't apply any ownership changes to the list
        // elements, only to the list itself.
        qp = reinterpret_cast&lt;QPoint *&gt;(sipConvertToType(
                                                PyList_GET_ITEM(sipPy, i),
                                                sipType_QPoint, 0,
                                                SIP_NOT_NONE,
                                                &amp;state, sipIsErr));

        // Deal with any errors.
        if (*sipIsErr)
        {
            sipReleaseType(qp, sipType_QPoint, state);

            // Tidy up.
            delete ql;

            // There is no temporary instance.
            return 0;
        }

        ql -&gt; append(*qp);

        // A copy of the QPoint was appended to the list so we no longer
        // need it.  It may be a temporary instance that should be
        // destroyed, or a wrapped instance that should not be destroyed.
        // sipReleaseType() will do the right thing.
        sipReleaseType(qp, sipType_QPoint, state);
    }

    // Return the instance.
    *sipCppPtr = ql;

    // The instance should be regarded as temporary (and be destroyed as
    // soon as it has been used) unless it has been transferred from
    // Python.  sipGetState() is a convenience function that implements
    // this common transfer behaviour.
    return sipGetState(sipTransferObj);
%End
</pre>
<p>When used in a class specification the handwritten code replaces the code that
would normally be automatically generated.  This means that the handwritten
code must also handle instances of the class itself and not just the additional
types that are being supported.  This should be done by making calls to
<a class="reference" href="#sipcanconverttotype">sipCanConvertToType()</a> to check the object type and <a class="reference" href="#sipconverttotype">sipConvertToType()</a> to
convert the object.  The <tt class="docutils literal"><span class="pre">SIP_NO_CONVERTORS</span></tt> flag <em>must</em> be passed to both
these functions to prevent recursive calls to the handwritten code.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id85" id="copying" name="copying">7.14&nbsp;&nbsp;&nbsp;%Copying</a></h2>
<pre class="literal-block">
%Copying
    <em>text</em>
%End
</pre>
<p>This directive is used to specify some arbitrary text that will be included at
the start of all source files generated by SIP.  It is normally used to
include copyright and licensing terms.</p>
<p>For example:</p>
<pre class="literal-block">
%Copying
Copyright (c) 2008 Riverbank Computing Limited
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id86" id="defaultencoding" name="defaultencoding">7.15&nbsp;&nbsp;&nbsp;%DefaultEncoding</a></h2>
<pre class="literal-block">
%DefaultEncoding <em>string</em>
</pre>
<p>This directory is used to specify the default encoding used for for <tt class="docutils literal"><span class="pre">char</span></tt>,
<tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> or <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> values.  The encoding can be
either <tt class="docutils literal"><span class="pre">&quot;ASCII&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;Latin-1&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;UTF-8&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;None&quot;</span></tt>.  An encoding of
<tt class="docutils literal"><span class="pre">&quot;None&quot;</span></tt> means that the value is unencoded.  The default can be overridden
for a particular value using the <a class="reference" href="#encoding">Encoding</a> annotation.  If the directive is not
specified then <tt class="docutils literal"><span class="pre">&quot;None&quot;</span></tt> is used.</p>
<p>For example:</p>
<pre class="literal-block">
%DefaultEncoding &quot;Latin-1&quot;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id87" id="defaultmetatype" name="defaultmetatype">7.16&nbsp;&nbsp;&nbsp;%DefaultMetatype</a></h2>
<pre class="literal-block">
%DefaultMetatype <em>dotted-name</em>
</pre>
<p>This directive is used to specify the Python type that should be used as the
meta-type for any C/C++ data type that doesn't have an explicit super-type.</p>
<p>If this is not specified then <tt class="docutils literal"><span class="pre">sip.wrappertype</span></tt> is used.</p>
<p>You can also use the <a class="reference" href="#metatype">Metatype</a> class annotation to specify the meta-type
used by a particular C/C++ type.</p>
<p>See the section <a class="reference" href="#types-and-meta-types">Types and Meta-types</a> for more details.</p>
<p>For example:</p>
<pre class="literal-block">
%DefaultMetatype PyQt4.QtCore.pyqtWrapperType
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id88" id="defaultsupertype" name="defaultsupertype">7.17&nbsp;&nbsp;&nbsp;%DefaultSupertype</a></h2>
<pre class="literal-block">
%DefaultSupertype <em>dotted-name</em>
</pre>
<p>This directive is used to specify the Python type that should be used as the
super-type for any C/C++ data type that doesn't have an explicit super-type.</p>
<p>If this is not specified then <tt class="docutils literal"><span class="pre">sip.wrapper</span></tt> is used.</p>
<p>You can also use the <a class="reference" href="#supertype">Supertype</a> class annotation to specify the super-type
used by a particular C/C++ type.</p>
<p>See the section <a class="reference" href="#types-and-meta-types">Types and Meta-types</a> for more details.</p>
<p>For example:</p>
<pre class="literal-block">
%DefaultSupertype sip.simplewrapper
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id89" id="doc" name="doc">7.18&nbsp;&nbsp;&nbsp;%Doc</a></h2>
<pre class="literal-block">
%Doc
    <em>text</em>
%End
</pre>
<p>This directive is used to specify some arbitrary text that will be extracted
by SIP when the <tt class="docutils literal"><span class="pre">-d</span></tt> command line option is used.  The directive can be
specified any number of times and SIP will concatenate all the separate pieces
of text in the order that it sees them.</p>
<p>Documentation that is specified using this directive is local to the module in
which it appears.  It is ignored by modules that <a class="reference" href="#import">%Import</a> it.  Use the
<a class="reference" href="#exporteddoc">%ExportedDoc</a> directive for documentation that should be included by all
modules that <a class="reference" href="#import">%Import</a> this one.</p>
<p>For example:</p>
<pre class="literal-block">
%Doc
&lt;h1&gt;An Example&lt;/h1&gt;
&lt;p&gt;
This fragment of documentation is HTML and is local to the module in
which it is defined.
&lt;/p&gt;
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id90" id="end" name="end">7.19&nbsp;&nbsp;&nbsp;%End</a></h2>
<p>This isn't a directive in itself, but is used to terminate a number of
directives that allow a block of handwritten code or text to be specified.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id91" id="exception" name="exception">7.20&nbsp;&nbsp;&nbsp;%Exception</a></h2>
<pre class="literal-block">
%Exception <em>name</em> [(<em>base-exception)]
{
    [*header-code</em>]
    <em>raise-code</em>
};
</pre>
<p>This directive is used to define new Python exceptions, or to provide a stub
for existing Python exceptions.  It allows handwritten code to be provided
that implements the translation between C++ exceptions and Python exceptions.
The arguments to <tt class="docutils literal"><span class="pre">throw</span> <span class="pre">()</span></tt> specifiers must either be names of classes or the
names of Python exceptions defined by this directive.</p>
<p><em>name</em> is the name of the exception.</p>
<p><em>base-exception</em> is the optional base exception.  This may be either one of
the standard Python exceptions or one defined with a previous <a class="reference" href="#exception">%Exception</a>
directive.</p>
<p><em>header-code</em> is the optional <a class="reference" href="#typeheadercode">%TypeHeaderCode</a> used to specify any external
interface to the exception being defined.</p>
<p><em>raise-code</em> is the <a class="reference" href="#raisecode">%RaiseCode</a> used to specify the handwritten code that
converts a reference to the C++ exception to the Python exception.</p>
<p>For example:</p>
<pre class="literal-block">
%Exception std::exception(SIP_Exception) /PyName=StdException/
{
%TypeHeaderCode
#include &lt;exception&gt;
%End
%RaiseCode
        const char *detail = sipExceptionRef.what();

        SIP_BLOCK_THREADS
        PyErr_SetString(sipException_std_exception, detail);
        SIP_UNBLOCK_THREADS
%End
};
</pre>
<p>In this example we map the standard C++ exception to a new Python exception.
The new exception is called <tt class="docutils literal"><span class="pre">StdException</span></tt> and is derived from the standard
Python exception <tt class="docutils literal"><span class="pre">Exception</span></tt>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id92" id="exporteddoc" name="exporteddoc">7.21&nbsp;&nbsp;&nbsp;%ExportedDoc</a></h2>
<pre class="literal-block">
%ExportedDoc
    <em>text</em>
%End
</pre>
<p>This directive is used to specify some arbitrary text that will be extracted
by SIP when the <tt class="docutils literal"><span class="pre">-d</span></tt> command line option is used.  The directive can be
specified any number of times and SIP will concatenate all the separate pieces
of text in the order that it sees them.</p>
<p>Documentation that is specified using this directive will also be included by
modules that <a class="reference" href="#import">%Import</a> it.</p>
<p>For example:</p>
<pre class="literal-block">
%ExportedDoc
==========
An Example
==========

This fragment of documentation is reStructuredText and will appear in the
module in which it is defined and all modules that %Import it.
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id93" id="exportedheadercode" name="exportedheadercode">7.22&nbsp;&nbsp;&nbsp;%ExportedHeaderCode</a></h2>
<pre class="literal-block">
%ExportedHeaderCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code, typically the declarations
of types, that is placed in a header file that is included by all generated
code for all modules.  It should not include function declarations because
Python modules should not explicitly call functions in another Python module.</p>
<p>See also <a class="reference" href="#modulecode">%ModuleCode</a> and <a class="reference" href="#moduleheadercode">%ModuleHeaderCode</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id94" id="feature" name="feature">7.23&nbsp;&nbsp;&nbsp;%Feature</a></h2>
<pre class="literal-block">
%Feature <em>name</em>
</pre>
<p>This directive is used to declare a feature.  Features (along with
<a class="reference" href="#platforms">%Platforms</a> and <a class="reference" href="#timeline">%Timeline</a>) are used by the <a class="reference" href="#if">%If</a> directive to control
whether or not parts of a specification are processed or ignored.</p>
<p>Features are mutually independent of each other - any combination of features
may be enabled or disable.  By default all features are enabled.  The SIP
<tt class="docutils literal"><span class="pre">-x</span></tt> command line option is used to disable a feature.</p>
<p>If a feature is enabled then SIP will automatically generate a corresponding C
preprocessor symbol for use by handwritten code.  The symbol is the name of
the feature prefixed by <tt class="docutils literal"><span class="pre">SIP_FEATURE_</span></tt>.</p>
<p>For example:</p>
<pre class="literal-block">
%Feature FOO_SUPPORT

%If (FOO_SUPPORT)
void foo();
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id95" id="gcclearcode" name="gcclearcode">7.24&nbsp;&nbsp;&nbsp;%GCClearCode</a></h2>
<pre class="literal-block">
%GCClearCode
    <em>code</em>
%End
</pre>
<p>Python has a cyclic garbage collector which can identify and release unneeded
objects even when their reference counts are not zero.  If a wrapped C
structure or C++ class keeps its own reference to a Python object then, if the
garbage collector is to do its job, it needs to provide some handwritten code
to traverse and potentially clear those embedded references.</p>
<p>See the section <em>Supporting cyclic garbage collection</em> in <a class="reference" href="http://www.python.org/dev/doc/devel/ext/">Embedding and
Extending the Python Interpreter</a>
for the details.</p>
<p>This directive is used to specify the code that clears any embedded references.
(See <a class="reference" href="#gctraversecode">%GCTraverseCode</a> for specifying the code that traverses any embedded
references.)</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>int sipRes</dt>
<dd>The handwritten code should set this to the result to be returned.</dd>
</dl>
<p>The following simplified example is taken from PyQt.  The <tt class="docutils literal"><span class="pre">QCustomEvent</span></tt>
class allows arbitary data to be attached to the event.  In PyQt this data is
always a Python object and so should be handled by the garbage collector:</p>
<pre class="literal-block">
%GCClearCode
    PyObject *obj;

    // Get the object.
    obj = reinterpret_cast&lt;PyObject *&gt;(sipCpp -&gt; data());

    // Clear the pointer.
    sipCpp -&gt; setData(0);

    // Clear the reference.
    Py_XDECREF(obj);

    // Report no error.
    sipRes = 0;
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id96" id="gctraversecode" name="gctraversecode">7.25&nbsp;&nbsp;&nbsp;%GCTraverseCode</a></h2>
<pre class="literal-block">
%GCTraverseCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify the code that traverses any embedded
references for Python's cyclic garbage collector.  (See <a class="reference" href="#gcclearcode">%GCClearCode</a> for a
full explanation.)</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>visitproc sipVisit</dt>
<dd>This is the visit function provided by the garbage collector.</dd>
<dt>void *sipArg</dt>
<dd>This is the argument to the visit function provided by the garbage
collector.</dd>
<dt>int sipRes</dt>
<dd>The handwritten code should set this to the result to be returned.</dd>
</dl>
<p>The following simplified example is taken from PyQt's <tt class="docutils literal"><span class="pre">QCustomEvent</span></tt> class:</p>
<pre class="literal-block">
%GCTraverseCode
    PyObject *obj;

    // Get the object.
    obj = reinterpret_cast&lt;PyObject *&gt;(sipCpp -&gt; data());

    // Call the visit function if there was an object.
    if (obj)
        sipRes = sipVisit(obj, sipArg);
    else
        sipRes = 0;
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id97" id="getcode" name="getcode">7.26&nbsp;&nbsp;&nbsp;%GetCode</a></h2>
<pre class="literal-block">
%GetCode
    <em>code</em>
%End
</pre>
<p>This directive is used after the declaration of a C++ class variable or C
structure member to specify handwritten code to convert it to a Python object.
It is usually used to handle types that SIP cannot deal with automatically.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.  It is not made available if the
variable being wrapped is a static class variable.</dd>
<dt>PyObject *sipPy</dt>
<dd>The handwritten code must set this to the Python representation of the
class variable or structure member.  If there is an error then the code
must raise an exception and set this to <tt class="docutils literal"><span class="pre">NULL</span></tt>.</dd>
<dt>PyObject *sipPyType</dt>
<dd>If the variable being wrapped is a static class variable then this is the
Python type object of the class from which the variable was referenced
(<em>not</em> the class in which it is defined).  It may be safely cast to a
PyTypeObject * or a sipWrapperType *.</dd>
</dl>
<p>For example:</p>
<pre class="literal-block">
struct Entity
{
    /*
     * In this contrived example the C library we are wrapping actually
     * defines this as char buffer[100] which SIP cannot handle
     * automatically.
     */
    char *buffer;
%GetCode
        sipPy = PyString_FromStringAndSize(sipCpp -&gt; buffer, 100);
%End
%SetCode
        char *ptr;
        int length;

        if (PyString_AsStringAndSize(sipPy, &amp;ptr, &amp;length) == -1)
            sipErr = 1;
        else if (length != 100)
        {
            /*
             * Raise an exception because the length isn't exactly right.
             */

            PyErr_SetString(PyExc_ValueError, &quot;an Entity.buffer must be exactly 100 bytes&quot;);
            sipErr = 1;
        }
        else
            memcpy(sipCpp -&gt; buffer, ptr, 100);
%End
}
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id98" id="if" name="if">7.27&nbsp;&nbsp;&nbsp;%If</a></h2>
<pre class="literal-block">
%If (<em>expression</em>)
    <em>specification</em>
%End
</pre>
<p>where</p>
<pre class="literal-block">
<em>expression</em> ::= [<em>ored-qualifiers</em> | <em>range</em>]

<em>ored-qualifiers</em> ::= [<em>qualifier</em> | <em>qualifier</em> <tt class="docutils literal"><span class="pre">||</span></tt> <em>ored-qualifiers</em>]

<em>qualifier</em> ::= [<tt class="docutils literal"><span class="pre">!</span></tt>] [<em>feature</em> | <em>platform</em>]

<em>range</em> ::= [<em>version</em>] <tt class="docutils literal"><span class="pre">-</span></tt> [<em>version</em>]
</pre>
<p>This directive is used in conjunction with features (see <a class="reference" href="#feature">%Feature</a>),
platforms (see <a class="reference" href="#platforms">%Platforms</a>) and versions (see <a class="reference" href="#timeline">%Timeline</a>) to control
whether or not parts of a specification are processed or not.</p>
<p>A <em>range</em> of versions means all versions starting with the lower bound up to
but excluding the upper bound.  If the lower bound is omitted then it is
interpreted as being before the earliest version.  If the upper bound is
omitted then it is interpreted as being after the latest version.</p>
<p>For example:</p>
<pre class="literal-block">
%Feature SUPPORT_FOO
%Platforms {WIN32_PLATFORM POSIX_PLATFORM MACOS_PLATFORM}
%Timeline {V1_0 V1_1 V2_0 V3_0}

%If (!SUPPORT_FOO)
    // Process this if the SUPPORT_FOO feature is disabled.
%End

%If (POSIX_PLATFORM || MACOS_PLATFORM)
    // Process this if either the POSIX_PLATFORM or MACOS_PLATFORM
    // platforms are enabled.
%End

%If (V1_0 - V2_0)
    // Process this if either V1_0 or V1_1 is enabled.
%End

%If (V2_0 - )
    // Process this if either V2_0 or V3_0 is enabled.
%End

%If ( - )
    // Always process this.
%End
</pre>
<p>Note that this directive is not implemented as a preprocessor.  Only the
following parts of a specification are affected by it:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">class</span></tt></li>
<li><a class="reference" href="#convertfromtypecode">%ConvertFromTypeCode</a></li>
<li><a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a></li>
<li><a class="reference" href="#converttotypecode">%ConvertToTypeCode</a></li>
<li><tt class="docutils literal"><span class="pre">enum</span></tt></li>
<li><a class="reference" href="#defaultencoding">%DefaultEncoding</a></li>
<li><a class="reference" href="#defaultmetatype">%DefaultMetatype</a></li>
<li><a class="reference" href="#defaultsupertype">%DefaultSupertype</a></li>
<li><a class="reference" href="#exportedheadercode">%ExportedHeaderCode</a></li>
<li>functions</li>
<li><a class="reference" href="#gcclearcode">%GCClearCode</a></li>
<li><a class="reference" href="#gctraversecode">%GCTraverseCode</a></li>
<li><a class="reference" href="#if">%If</a></li>
<li><a class="reference" href="#initialisationcode">%InitialisationCode</a></li>
<li><a class="reference" href="#mappedtype">%MappedType</a></li>
<li><a class="reference" href="#methodcode">%MethodCode</a></li>
<li><a class="reference" href="#modulecode">%ModuleCode</a></li>
<li><a class="reference" href="#moduleheadercode">%ModuleHeaderCode</a></li>
<li><tt class="docutils literal"><span class="pre">namespace</span></tt></li>
<li><a class="reference" href="#postinitialisationcode">%PostInitialisationCode</a></li>
<li><a class="reference" href="#preinitialisationcode">%PreInitialisationCode</a></li>
<li><tt class="docutils literal"><span class="pre">struct</span></tt></li>
<li><tt class="docutils literal"><span class="pre">typedef</span></tt></li>
<li><a class="reference" href="#typecode">%TypeCode</a></li>
<li><a class="reference" href="#typeheadercode">%TypeHeaderCode</a></li>
<li><a class="reference" href="#unitcode">%UnitCode</a></li>
<li>variables</li>
<li><a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a></li>
</ul>
</blockquote>
<p>Also note that the only way to specify the logical and of qualifiers is to use
nested <a class="reference" href="#if">%If</a> directives.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id99" id="import" name="import">7.28&nbsp;&nbsp;&nbsp;%Import</a></h2>
<pre class="literal-block">
%Import <em>filename</em>
</pre>
<p>This directive is used to import the specification of another module.  This is
needed if the current module makes use of any types defined in the imported
module, e.g. as an argument to a function, or to sub-class.</p>
<p>If <em>filename</em> cannot be opened then SIP prepends <em>filename</em> with the name of
the directory containing the current specification file (i.e. the one
containing the <a class="reference" href="#import">%Import</a> directive) and tries again.  If this also fails then
SIP prepends <em>filename</em> with each of the directories, in turn, specified by
the <tt class="docutils literal"><span class="pre">-I</span></tt> command line option.</p>
<p>For example:</p>
<pre class="literal-block">
%Import qt/qtmod.sip
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id100" id="include" name="include">7.29&nbsp;&nbsp;&nbsp;%Include</a></h2>
<pre class="literal-block">
%Include <em>filename</em>
</pre>
<p>This directive is used to include contents of another file as part of the
specification of the current module.  It is the equivalent of the C
preprocessor's <tt class="docutils literal"><span class="pre">#include</span></tt> directive and is used to structure a large module
specification into manageable pieces.</p>
<p><a class="reference" href="#include">%Include</a> follows the same search process as <a class="reference" href="#import">%Import</a> when trying to open
<em>filename</em>.</p>
<p>For example:</p>
<pre class="literal-block">
%Include qwidget.sip
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id101" id="initialisationcode" name="initialisationcode">7.30&nbsp;&nbsp;&nbsp;%InitialisationCode</a></h2>
<pre class="literal-block">
%InitialisationCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that is embedded in-line
in the generated module initialisation code after the SIP module has been
imported but before the module itself has been initialised.</p>
<p>It is typically used to call <a class="reference" href="#sipregisterpytype">sipRegisterPyType()</a>.</p>
<p>For example:</p>
<pre class="literal-block">
%InitialisationCode
    // The code will be executed when the module is first imported, after
    // the SIP module has been imported, but before other module-specific
    // initialisation has been completed.
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id102" id="id14" name="id14">7.31&nbsp;&nbsp;&nbsp;%License</a></h2>
<pre class="literal-block">
%License /<em>license-annotations</em>/
</pre>
<p>This directive is used to specify the contents of an optional license
dictionary.  The license dictionary is called <tt class="docutils literal"><span class="pre">__license__</span></tt> and is stored in
the module dictionary.  The elements of the dictionary are specified using the
<a class="reference" href="#licensee">Licensee</a>, <a class="reference" href="#signature">Signature</a>, <a class="reference" href="#timestamp">Timestamp</a> and <a class="reference" href="#type">Type</a> annotations.  Only the <a class="reference" href="#type">Type</a>
annotation is compulsory.</p>
<p>Note that this directive isn't an attempt to impose any licensing restrictions
on a module.  It is simply a method for easily embedding licensing information
in a module so that it is accessible to Python scripts.</p>
<p>For example:</p>
<pre class="literal-block">
%License /Type=&quot;GPL&quot;/
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id103" id="mappedtype" name="mappedtype">7.32&nbsp;&nbsp;&nbsp;%MappedType</a></h2>
<pre class="literal-block">
template&lt;<em>type-list</em>&gt;
%MappedType <em>type</em>
{
    [<em>header-code</em>]
    [<em>convert-to-code</em>]
    [<em>convert-from-code</em>]
};

%MappedType <em>type</em>
{
    [<em>header-code</em>]
    [<em>convert-to-code</em>]
    [<em>convert-from-code</em>]
};
</pre>
<p>This directive is used to define an automatic mapping between a C or C++ type
and a Python type.  It can be used as part of a template, or to map a specific
type.</p>
<p>When used as part of a template <em>type</em> cannot itself refer to a template.  Any
occurrences of any of the type names (but not any <tt class="docutils literal"><span class="pre">*</span></tt> or <tt class="docutils literal"><span class="pre">&amp;</span></tt>) in
<em>type-list</em> will be replaced by the actual type names used when the template is
instantiated.  Template mapped types are instantiated automatically as required
(unlike template classes which are only instantiated using <tt class="docutils literal"><span class="pre">typedef</span></tt>).</p>
<p>Any explicit mapped type will be used in preference to any template that maps
the same type, ie. a template will not be automatically instantiated if there
is an explicit mapped type.</p>
<p><em>header-code</em> is the <a class="reference" href="#typeheadercode">%TypeHeaderCode</a> used to specify the library interface
to the type being mapped.</p>
<p><em>convert-to-code</em> is the <a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> used to specify the handwritten
code that converts a Python object to an instance of the mapped type.</p>
<p><em>convert-from-code</em> is the <a class="reference" href="#convertfromtypecode">%ConvertFromTypeCode</a> used to specify the
handwritten code that converts an instance of the mapped type to a Python
object.</p>
<p>For example:</p>
<pre class="literal-block">
template&lt;Type *&gt;
%MappedType QList
{
%TypeHeaderCode
// Include the library interface to the type being mapped.
#include &lt;qlist.h&gt;
%End

%ConvertToTypeCode
    // See if we are just being asked to check the type of the Python
    // object.
    if (sipIsErr == NULL)
    {
        // Check it is a list.
        if (!PyList_Check(sipPy))
            return 0;

        // Now check each element of the list is of the type we expect.
        // The template is for a pointer type so we don't disallow None.
        for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
            if (!sipCanConvertToType(PyList_GET_ITEM(sipPy, i),
                                     sipType_Type, 0))
                return 0;

        return 1;
    }

    // Create the instance on the heap.
    QList&lt;Type *&gt; *ql = new QList&lt;Type *&gt;;

    for (int i = 0; i &lt; PyList_GET_SIZE(sipPy); ++i)
    {
        // Use the SIP API to convert the Python object to the
        // corresponding C++ instance.  Note that we apply any ownership
        // transfer to the list itself, not the individual elements.
        Type *t = reinterpret_cast&lt;Type *&gt;(sipConvertToType(
                                            PyList_GET_ITEM(sipPy, i),
                                            sipType_Type, 0, 0, 0,
                                            sipIsErr));

        if (*sipIsErr)
        {
            // Tidy up.
            delete ql;

            // There is nothing on the heap.
            return 0;
        }

        // Add the pointer to the C++ instance.
        ql -&gt; append(t);
    }

    // Return the instance on the heap.
    *sipCppPtr = ql;

    // Apply the normal transfer.
    return sipGetState(sipTransferObj);
%End

%ConvertFromTypeCode
    PyObject *l;

    // Create the Python list of the correct length.
    if ((l = PyList_New(sipCpp -&gt; size())) == NULL)
        return NULL;

    // Go through each element in the C++ instance and convert it to the
    // corresponding Python object.
    for (int i = 0; i &lt; sipCpp -&gt; size(); ++i)
    {
        Type *t = sipCpp -&gt; at(i);
        PyObject *tobj;

        if ((tobj = sipConvertFromType(t, sipType_Type, sipTransferObj)) == NULL)
        {
            // There was an error so garbage collect the Python list.
            Py_DECREF(l);
            return NULL;
        }

        PyList_SET_ITEM(l, i, tobj);
    }

    // Return the Python list.
    return l;
%End
}
</pre>
<p>Using this we can use, for example, <tt class="docutils literal"><span class="pre">QList&lt;QObject</span> <span class="pre">*&gt;</span></tt> throughout the
module's specification files (and in any module that imports this one).  The
generated code will automatically map this to and from a Python list of QObject
instances when appropriate.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id104" id="methodcode" name="methodcode">7.33&nbsp;&nbsp;&nbsp;%MethodCode</a></h2>
<pre class="literal-block">
%MethodCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the specification of a global function, class
method, operator, constructor or destructor to specify handwritten code that
replaces the normally generated call to the function being wrapped.  It is
usually used to handle argument types and results that SIP cannot deal with
automatically.</p>
<p>Normally the specified code is embedded in-line after the function's arguments
have been successfully converted from Python objects to their C or C++
equivalents.  In this case the specified code must not include any <tt class="docutils literal"><span class="pre">return</span></tt>
statements.</p>
<p>However if the <a class="reference" href="#noargparser">NoArgParser</a> annotation has been used then the specified code
is also responsible for parsing the arguments.  No other code is generated by
SIP and the specified code must include a <tt class="docutils literal"><span class="pre">return</span></tt> statement.</p>
<p>In the context of a destructor the specified code is embedded in-line in the
Python type's deallocation function.  Unlike other contexts it supplements
rather than replaces the normally generated code, so it must not include code
to return the C structure or C++ class instance to the heap.  The code is only
called if ownership of the structure or class is with Python.</p>
<p>The specified code must also handle the Python Global Interpreter Lock (GIL).
If compatibility with SIP v3.x is required then the GIL must be released
immediately before the C++ call and reacquired immediately afterwards as shown
in this example fragment:</p>
<pre class="literal-block">
Py_BEGIN_ALLOW_THREADS
sipCpp -&gt; foo();
Py_END_ALLOW_THREADS
</pre>
<p>If compatibility with SIP v3.x is not required then this is optional but
should be done if the C++ function might block the current thread or take a
significant amount of time to execute.  (See <a class="reference" href="#the-python-global-interpreter-lock">The Python Global Interpreter
Lock</a> and the <a class="reference" href="#releasegil">ReleaseGIL</a> and <a class="reference" href="#holdgil">HoldGIL</a> annotations.)</p>
<p>If the <a class="reference" href="#noargparser">NoArgParser</a> annotation has not been used then the following variables
are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> a0</dt>
<dd><p class="first">There is a variable for each argument of the Python signature (excluding
any <tt class="docutils literal"><span class="pre">self</span></tt> argument) named <tt class="docutils literal"><span class="pre">a0</span></tt>, <tt class="docutils literal"><span class="pre">a1</span></tt>, etc.  The <em>type</em> of the
variable is the same as the type defined in the specification with the
following exceptions:</p>
<ul class="simple">
<li>if the argument is only used to return a value (e.g. it is an <tt class="docutils literal"><span class="pre">int</span> <span class="pre">*</span></tt>
without an <a class="reference" href="#in">In</a> annotation) then the type has one less level of
indirection (e.g. it will be an <tt class="docutils literal"><span class="pre">int</span></tt>)</li>
<li>if the argument is a structure or class (or a reference or a pointer to a
structure or class) then <em>type</em> will always be a pointer to the structure
or class.</li>
</ul>
<p class="last">Note that handwritten code for destructors never has any arguments.</p>
</dd>
<dt>PyObject *a0Wrapper</dt>
<dd>This variable is made available only if the <a class="reference" href="#getwrapper">GetWrapper</a> annotation is
specified for the corresponding argument.  The variable is a pointer to the
Python object that wraps the argument.</dd>
<dt><em>type</em> *sipCpp</dt>
<dd><p class="first">If the directive is used in the context of a class constructor then this
must be set by the handwritten code to the constructed instance.  If it is
set to <tt class="docutils literal"><span class="pre">0</span></tt> and no Python exception is raised then SIP will continue to
try other Python signatures.</p>
<p>If the directive is used in the context of a method (but not the standard
binary operator methods, e.g. <tt class="docutils literal"><span class="pre">__add__</span></tt>) or a destructor then this is a
pointer to the C structure or C++ class instance.</p>
<p>Its <em>type</em> is a pointer to the structure or class.</p>
<p class="last">Standard binary operator methods follow the same convention as global
functions and instead define two arguments called <tt class="docutils literal"><span class="pre">a0</span></tt> and <tt class="docutils literal"><span class="pre">a1</span></tt>.</p>
</dd>
<dt>int sipIsErr</dt>
<dd><p class="first">The handwritten code should set this to a non-zero value, and raise an
appropriate Python exception, if an error is detected.</p>
<p class="last"><tt class="docutils literal"><span class="pre">sipIsErr</span></tt> is not provided for destructors.</p>
</dd>
<dt><em>type</em> sipRes</dt>
<dd><p class="first">The handwritten code should set this to the result to be returned.  The
<em>type</em> of the variable is the same as the type defined in the Python
signature in the specification with the following exception:</p>
<ul class="simple">
<li>if the argument is a structure or class (or a reference or a pointer to a
structure or class) then <em>type</em> will always be a pointer to the structure
or class.</li>
</ul>
<p class="last"><tt class="docutils literal"><span class="pre">sipRes</span></tt> is not provided for inplace operators (e.g. <tt class="docutils literal"><span class="pre">+=</span></tt> or
<tt class="docutils literal"><span class="pre">__imul__</span></tt>) as their results are handled automatically, nor for class
constructors or destructors.</p>
</dd>
<dt>PyObject *sipSelf</dt>
<dd>If the directive is used in the context of a class constructor, destructor
or method then this is the Python object that wraps the the structure or
class instance, i.e. <tt class="docutils literal"><span class="pre">self</span></tt>.</dd>
<dt>bool sipSelfWasArg</dt>
<dd><p class="first">This is only made available for non-abstract, virtual methods.  It is set
if <tt class="docutils literal"><span class="pre">self</span></tt> was explicitly passed as the first argument of the method
rather than being bound to the method.  In other words, the call was:</p>
<pre class="literal-block">
Klass.foo(self, ...)
</pre>
<p>rather than:</p>
<pre class="last literal-block">
self.foo(...)
</pre>
</dd>
</dl>
<p>If the <a class="reference" href="#noargparser">NoArgParser</a> annotation has been used then only the following
variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>PyObject *sipArgs</dt>
<dd>This is the tuple of arguments.</dd>
<dt>PyObject *sipKwds</dt>
<dd>This is the dictionary of keyword arguments.</dd>
</dl>
<p>The following is a complete example:</p>
<pre class="literal-block">
class Klass
{
public:
    virtual int foo(SIP_PYTUPLE);
%MethodCode
        // The C++ API takes a 2 element array of integers but passing a
        // two element tuple is more Pythonic.

        int iarr[2];

        if (PyArg_ParseTuple(a0, &quot;ii&quot;, &amp;iarr[0], &amp;iarr[1]))
        {
            Py_BEGIN_ALLOW_THREADS
            sipRes = sipSelfWasArg ? sipCpp -&gt; Klass::foo(iarr)
                                   : sipCpp -&gt; foo(iarr);
            Py_END_ALLOW_THREADS
        }
        else
        {
            // PyArg_ParseTuple() will have raised the exception.
            sipIsErr = 1;
        }
%End
};
</pre>
<p>As the example is a virtual method <a class="footnote-reference" href="#id16" id="id15" name="id15">[7]</a>, note the use of <tt class="docutils literal"><span class="pre">sipSelfWasArg</span></tt> to
determine exactly which implementation of <tt class="docutils literal"><span class="pre">foo()</span></tt> to call.</p>
<p>If a method is in the <tt class="docutils literal"><span class="pre">protected</span></tt> section of a C++ class then the call
should instead be:</p>
<pre class="literal-block">
sipRes = sipCpp -&gt; sipProtectVirt_foo(sipSelfWasArg, iarr);
</pre>
<p>If a method is in the <tt class="docutils literal"><span class="pre">protected</span></tt> section of a C++ class but is not virtual
then the call should instead be:</p>
<pre class="literal-block">
sipRes = sipCpp -&gt; sipProtect_foo(iarr);
</pre>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15" name="id16">[7]</a></td><td>See <a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a> for a description of how SIP generated code
handles the reimplementation of C++ virtual methods in Python.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id105" id="module" name="module">7.34&nbsp;&nbsp;&nbsp;%Module</a></h2>
<pre class="literal-block">
%Module <em>name</em> [<em>version</em>]
</pre>
<p>This directive is used to identify that the library being wrapped is a C++
library and to define the name of the module and it's optional version number.</p>
<p>The name may contain periods to specify that the module is part of a Python
package.</p>
<p>The optional version number is useful if you (or others) might create other
modules that build on this module, i.e. if another module might <a class="reference" href="#import">%Import</a>
this module.  Under the covers, a module exports an API that is used by modules
that <a class="reference" href="#import">%Import</a> it and the API is given a version number.  A module built on
that module knows the version number of the API that it is expecting.  If,
when the modules are imported at run-time, the version numbers do not match
then a Python exception is raised.  The dependent module must then be re-built
using the correct specification files for the base module.</p>
<p>The version number should be incremented whenever a module is changed.  Some
changes don't affect the exported API, but it is good practice to change the
version number anyway.</p>
<p>For example:</p>
<pre class="literal-block">
%Module qt 5
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id106" id="modulecode" name="modulecode">7.35&nbsp;&nbsp;&nbsp;%ModuleCode</a></h2>
<pre class="literal-block">
%ModuleCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code, typically the
implementations of utility functions, that can be called by other handwritten
code in the module.</p>
<p>For example:</p>
<pre class="literal-block">
%ModuleCode
// Print an object on stderr for debugging purposes.
void dump_object(PyObject *o)
{
    PyObject_Print(o, stderr, 0);
    fprintf(stderr, &quot;\n&quot;);
}
%End
</pre>
<p>See also <a class="reference" href="#exportedheadercode">%ExportedHeaderCode</a> and <a class="reference" href="#moduleheadercode">%ModuleHeaderCode</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id107" id="moduleheadercode" name="moduleheadercode">7.36&nbsp;&nbsp;&nbsp;%ModuleHeaderCode</a></h2>
<pre class="literal-block">
%ModuleHeaderCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code, typically the declarations
of utility functions, that is placed in a header file that is included by all
generated code for the same module.</p>
<p>For example:</p>
<pre class="literal-block">
%ModuleHeaderCode
void dump_object(PyObject *o);
%End
</pre>
<p>See also <a class="reference" href="#exportedheadercode">%ExportedHeaderCode</a> and <a class="reference" href="#modulecode">%ModuleCode</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id108" id="optionalinclude" name="optionalinclude">7.37&nbsp;&nbsp;&nbsp;%OptionalInclude</a></h2>
<pre class="literal-block">
%OptionalInclude <em>filename</em>
</pre>
<p>This directive is identical to the <a class="reference" href="#include">%Include</a> directive except that SIP
silently continues processing if <em>filename</em> could not be opened.</p>
<p>For example:</p>
<pre class="literal-block">
%OptionalInclude license.sip
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id109" id="picklecode" name="picklecode">7.38&nbsp;&nbsp;&nbsp;%PickleCode</a></h2>
<pre class="literal-block">
%PickleCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code to pickle a C structure or
C++ class instance.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.</dd>
<dt>PyObject *sipRes</dt>
<dd>The handwritten code must set this to a tuple of the arguments that will
be passed to the type's __init__() method when the structure or class
instance is unpickled.  If there is an error then the code must raise an
exception and set this to <tt class="docutils literal"><span class="pre">NULL</span></tt>.</dd>
</dl>
<p>For example:</p>
<pre class="literal-block">
class Point
{
    Point(int x, y);

    int x() const;
    int y() const;

%PickleCode
    sipRes = Py_BuildValue(&quot;ii&quot;, sipCpp-&gt;x(), sipCpp-&gt;y());
%End
}
</pre>
<p>Note that SIP works around the Python limitation that prevents nested types
being pickled.</p>
<p>Both named and unnamed enums can be pickled automatically without providing any
handwritten code.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id110" id="platforms" name="platforms">7.39&nbsp;&nbsp;&nbsp;%Platforms</a></h2>
<pre class="literal-block">
%Platforms {<em>name</em> <em>name</em> ...}
</pre>
<p>This directive is used to declare a set of platforms.  Platforms (along with
<a class="reference" href="#feature">%Feature</a> and <a class="reference" href="#timeline">%Timeline</a>) are used by the <a class="reference" href="#if">%If</a> directive to control
whether or not parts of a specification are processed or ignored.</p>
<p>Platforms are mutually exclusive - only one platform can be enabled at a time.
By default all platforms are disabled.  The SIP <tt class="docutils literal"><span class="pre">-t</span></tt> command line option is
used to enable a platform.</p>
<p>For example:</p>
<pre class="literal-block">
%Platforms {WIN32_PLATFORM POSIX_PLATFORM MACOS_PLATFORM}

%If (WIN32_PLATFORM)
void undocumented();
%End

%If (POSIX_PLATFORM)
void documented();
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id111" id="postinitialisationcode" name="postinitialisationcode">7.40&nbsp;&nbsp;&nbsp;%PostInitialisationCode</a></h2>
<pre class="literal-block">
%PostInitialisationCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that is embedded in-line
at the very end of the generated module initialisation code.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt>PyObject *sipModule</dt>
<dd>This is the module object returned by <tt class="docutils literal"><span class="pre">Py_InitModule()</span></tt>.</dd>
<dt>PyObject *sipModuleDict</dt>
<dd>This is the module's dictionary object returned by <tt class="docutils literal"><span class="pre">Py_ModuleGetDict()</span></tt>.</dd>
</dl>
<p>For example:</p>
<pre class="literal-block">
%PostInitialisationCode
    // The code will be executed when the module is first imported and
    // after all other initialisation has been completed.
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id112" id="preinitialisationcode" name="preinitialisationcode">7.41&nbsp;&nbsp;&nbsp;%PreInitialisationCode</a></h2>
<pre class="literal-block">
%PreInitialisationCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that is embedded in-line
at the very start of the generated module initialisation code.</p>
<p>For example:</p>
<pre class="literal-block">
%PreInitialisationCode
    // The code will be executed when the module is first imported and
    // before other initialisation has been completed.
%End
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id113" id="raisecode" name="raisecode">7.42&nbsp;&nbsp;&nbsp;%RaiseCode</a></h2>
<pre class="literal-block">
%RaiseCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the definition of an exception using the
<a class="reference" href="#exception">%Exception</a> directive to specify handwritten code that raises a Python
exception when a C++ exception has been caught.  The code is embedded in-line
as the body of a C++ <tt class="docutils literal"><span class="pre">catch</span> <span class="pre">()</span></tt> clause.</p>
<p>The specified code must handle the Python Global Interpreter Lock (GIL) if
necessary.  The GIL must be acquired before any calls to the Python API and
released after the last call as shown in this example fragment:</p>
<pre class="literal-block">
SIP_BLOCK_THREADS
PyErr_SetNone(PyErr_Exception);
SIP_UNBLOCK_THREADS
</pre>
<p>Finally, the specified code must not include any <tt class="docutils literal"><span class="pre">return</span></tt> statements.</p>
<p>The following variable is made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> &amp;sipExceptionRef</dt>
<dd>This is a reference to the caught C++ exception.  The <em>type</em> of the
reference is the same as the type defined in the <tt class="docutils literal"><span class="pre">throw</span> <span class="pre">()</span></tt> specifier.</dd>
</dl>
<p>See the <a class="reference" href="#exception">%Exception</a> directive for an example.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id114" id="setcode" name="setcode">7.43&nbsp;&nbsp;&nbsp;%SetCode</a></h2>
<pre class="literal-block">
%SetCode
    <em>code</em>
%End
</pre>
<p>This directive is used after the declaration of a C++ class variable or C
structure member to specify handwritten code to convert it from a Python
object.  It is usually used to handle types that SIP cannot deal with
automatically.</p>
<p>The following variables are made available to the handwritten code:</p>
<dl class="docutils">
<dt><em>type</em> *sipCpp</dt>
<dd>This is a pointer to the structure or class instance.  Its <em>type</em> is a
pointer to the structure or class.  It is not made available if the
variable being wrapped is a static class variable.</dd>
<dt>int sipErr</dt>
<dd>If the conversion failed then the handwritten code should raise a Python
exception and set this to a non-zero value.  Its initial value will be
automatically set to zero.</dd>
<dt>PyObject *sipPy</dt>
<dd>This is the Python object that the handwritten code should convert.</dd>
<dt>PyObject *sipPyType</dt>
<dd>If the variable being wrapped is a static class variable then this is the
Python type object of the class from which the variable was referenced
(<em>not</em> the class in which it is defined).  It may be safely cast to a
PyTypeObject * or a sipWrapperType *.</dd>
</dl>
<p>See the <a class="reference" href="#getcode">%GetCode</a> directive for an example.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id115" id="timeline" name="timeline">7.44&nbsp;&nbsp;&nbsp;%Timeline</a></h2>
<pre class="literal-block">
%Timeline {<em>name</em> <em>name</em> ...}
</pre>
<p>This directive is used to declare a set of versions released over a period of
time.  Versions (along with <a class="reference" href="#feature">%Feature</a> and <a class="reference" href="#platforms">%Platforms</a>) are used by the
<a class="reference" href="#if">%If</a> directive to control whether or not parts of a specification are
processed or ignored.</p>
<p>Versions are mutually exclusive - only one version can be enabled at a time.
By default all versions are disabled.  The SIP <tt class="docutils literal"><span class="pre">-t</span></tt> command line option is
used to enable a version.</p>
<p>For example:</p>
<pre class="literal-block">
%Timeline {V1_0 V1_1 V2_0 V3_0}

%If (V1_0 - V2_0)
void foo();
%End

%If (V2_0 -)
void foo(int = 0);
%End
</pre>
<p><a class="reference" href="#timeline">%Timeline</a> can be used any number of times in a module to allow multiple
libraries to be wrapped in the same module.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id116" id="typecode" name="typecode">7.45&nbsp;&nbsp;&nbsp;%TypeCode</a></h2>
<pre class="literal-block">
%TypeCode
    <em>code</em>
%End
</pre>
<p>This directive is used as part of the specification of a C structure or a C++
class to specify handwritten code, typically the implementations of utility
functions, that can be called by other handwritten code in the structure or
class.</p>
<p>For example:</p>
<pre class="literal-block">
class Klass
{
%TypeCode
// Print an instance on stderr for debugging purposes.
static void dump_klass(const Klass *k)
{
    fprintf(stderr,&quot;Klass %s at %p\n&quot;, k -&gt; name(), k);
}
%End

    // The rest of the class specification.

};
</pre>
<p>Because the scope of the code is normally within the generated file that
implements the type, any utility functions would normally be declared
<tt class="docutils literal"><span class="pre">static</span></tt>.  However a naming convention should still be adopted to prevent
clashes of function names within a module in case the SIP <tt class="docutils literal"><span class="pre">-j</span></tt> command line
option is used.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id117" id="typeheadercode" name="typeheadercode">7.46&nbsp;&nbsp;&nbsp;%TypeHeaderCode</a></h2>
<pre class="literal-block">
%TypeHeaderCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that defines the interface
to a C or C++ type being wrapped, either a structure, a class, or a template.
It is used within a class definition or a <a class="reference" href="#mappedtype">%MappedType</a> directive.</p>
<p>Normally <em>code</em> will be a pre-processor <tt class="docutils literal"><span class="pre">#include</span></tt> statement.</p>
<p>For example:</p>
<pre class="literal-block">
// Wrap the Klass class.
class Klass
{
%TypeHeaderCode
#include &lt;klass.h&gt;
%End

    // The rest of the class specification.
};
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id118" id="unitcode" name="unitcode">7.47&nbsp;&nbsp;&nbsp;%UnitCode</a></h2>
<pre class="literal-block">
%UnitCode
    <em>code</em>
%End
</pre>
<p>This directive is used to specify handwritten code that it included at the very
start of a generated compilation unit (ie. C or C++ source file).  It is
typically used to <tt class="docutils literal"><span class="pre">#include</span></tt> a C++ precompiled header file.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id119" id="virtualcatchercode" name="virtualcatchercode">7.48&nbsp;&nbsp;&nbsp;%VirtualCatcherCode</a></h2>
<pre class="literal-block">
%VirtualCatcherCode
    <em>code</em>
%End
</pre>
<p>For most classes there are corresponding <a class="reference" href="#generated-derived-classes">generated derived classes</a> that
contain reimplementations of the class's virtual methods.  These methods (which
SIP calls catchers) determine if there is a corresponding Python
reimplementation and call it if so.  If there is no Python reimplementation
then the method in the original class is called instead.</p>
<p>This directive is used to specify handwritten code that replaces the normally
generated call to the Python reimplementation and the handling of any returned
results.  It is usually used to handle argument types and results that SIP
cannot deal with automatically.</p>
<p>This directive can also be used in the context of a class destructor to
specify handwritten code that is embedded in-line in the internal derived
class's destructor.</p>
<p>In the context of a method the Python Global Interpreter Lock (GIL) is
automatically acquired before the specified code is executed and automatically
released afterwards.</p>
<p>In the context of a destructor the specified code must handle the GIL.  The
GIL must be acquired before any calls to the Python API and released after the
last call as shown in this example fragment:</p>
<pre class="literal-block">
SIP_BLOCK_THREADS
Py_DECREF(obj);
SIP_UNBLOCK_THREADS
</pre>
<p>The following variables are made available to the handwritten code in the
context of a method:</p>
<dl class="docutils">
<dt><em>type</em> a0</dt>
<dd>There is a variable for each argument of the C++ signature named <tt class="docutils literal"><span class="pre">a0</span></tt>,
<tt class="docutils literal"><span class="pre">a1</span></tt>, etc.  The <em>type</em> of the variable is the same as the type defined in
the specification.</dd>
<dt>int a0Key</dt>
<dd>There is a variable for each argument of the C++ signature that has a type
where it is important to ensure that the corresponding Python object is not
garbage collected too soon.  This only applies to output arguments that
return <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated strings.  The variable would normally be passed
to <a class="reference" href="#sipparseresult">sipParseResult()</a> using either the <tt class="docutils literal"><span class="pre">A</span></tt> or <tt class="docutils literal"><span class="pre">B</span></tt> format characters.</dd>
<dt>int sipIsErr</dt>
<dd>The handwritten code should set this to a non-zero value, and raise an
appropriate Python exception, if an error is detected.</dd>
<dt>PyObject *sipMethod</dt>
<dd>This object is the Python reimplementation of the virtual C++ method.  It
is normally passed to <a class="reference" href="#sipcallmethod">sipCallMethod()</a>.</dd>
<dt><em>type</em> sipRes</dt>
<dd>The handwritten code should set this to the result to be returned.  The
<em>type</em> of the variable is the same as the type defined in the C++ signature
in the specification.</dd>
<dt>int sipResKey</dt>
<dd>This variable is only made available if the result has a type where it is
important to ensure that the corresponding Python object is not garbage
collected too soon.  This only applies to <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated strings.  The
variable would normally be passed to <a class="reference" href="#sipparseresult">sipParseResult()</a> using either the
<tt class="docutils literal"><span class="pre">A</span></tt> or <tt class="docutils literal"><span class="pre">B</span></tt> format characters.</dd>
<dt>sipSimpleWrapper *sipPySelf</dt>
<dd>This variableis only made available if either the <tt class="docutils literal"><span class="pre">a0Key</span></tt> or
<tt class="docutils literal"><span class="pre">sipResKey</span></tt> are made available.  It defines the context within which keys
are unique.  The variable would normally be passed to <a class="reference" href="#sipparseresult">sipParseResult()</a>
using the <tt class="docutils literal"><span class="pre">S</span></tt> format character.</dd>
</dl>
<p>No variables are made available in the context of a destructor.</p>
<p>For example:</p>
<pre class="literal-block">
class Klass
{
public:
    virtual int foo(SIP_PYTUPLE) [int (int *)];
%MethodCode
        // The C++ API takes a 2 element array of integers but passing a
        // two element tuple is more Pythonic.

        int iarr[2];

        if (PyArg_ParseTuple(a0, &quot;ii&quot;, &amp;iarr[0], &amp;iarr[1]))
        {
            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp -&gt; Klass::foo(iarr);
            Py_END_ALLOW_THREADS
        }
        else
        {
            // PyArg_ParseTuple() will have raised the exception.
            sipIsErr = 1;
        }
%End
%VirtualCatcherCode
        // Convert the 2 element array of integers to the two element
        // tuple.

        PyObject *result;

        result = sipCallMethod(&amp;sipIsErr, sipMethod, &quot;ii&quot;, a0[0], a0[1]);

        if (result != NULL)
        {
            // Convert the result to the C++ type.
            sipParseResult(&amp;sipIsErr, sipMethod, result, &quot;i&quot;, &amp;sipRes);

            Py_DECREF(result);
        }
%End
};
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id120" id="sip-annotations" name="sip-annotations">8&nbsp;&nbsp;&nbsp;SIP Annotations</a></h1>
<p>In this section we describe each of the annotations that can be used in
specification files.</p>
<p>Annotations can either be argument annotations, class annotations, mapped type
annotations, enum annotations, exception annotations, function annotations,
license annotations, typedef annotations or variable annotations depending on
the context in which they can be used.</p>
<p>Annotations are placed between forward slashes (<tt class="docutils literal"><span class="pre">/</span></tt>).  Multiple annotations
are comma separated within the slashes.</p>
<p>Annotations have a type and, possibly, a value.  The type determines the
format of the value.  The name of an annotation and its value are separated by
<tt class="docutils literal"><span class="pre">=</span></tt>.</p>
<p>Annotations can have one of the following types:</p>
<dl class="docutils">
<dt>boolean</dt>
<dd>This type of annotation has no value and is implicitly true.</dd>
<dt>name</dt>
<dd>The value is a name that is compatible with a C/C++ identifier.  In some
cases the value is optional.</dd>
<dt>dotted name</dt>
<dd>The value is a name that is compatible with an identifier preceded by a
Python scope.</dd>
<dt>string</dt>
<dd>The value is a double quoted string.</dd>
</dl>
<p>The following example shows argument and function annotations:</p>
<pre class="literal-block">
void exec(QWidget * /Transfer/) /ReleaseGIL, PyName=call_exec/;
</pre>
<p>Note that the current version of SIP does not complain about unknown
annotations, or annotations used out of their correct context.</p>
<div class="section">
<h2><a class="toc-backref" href="#id121" id="argument-annotations" name="argument-annotations">8.1&nbsp;&nbsp;&nbsp;Argument Annotations</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id122" id="allownone" name="allownone">8.1.1&nbsp;&nbsp;&nbsp;AllowNone</a></h3>
<p>This boolean annotation specifies that the value of the corresponding argument
(which should be either <a class="reference" href="#sip-pycallable">SIP_PYCALLABLE</a>, <a class="reference" href="#sip-pydict">SIP_PYDICT</a>, <a class="reference" href="#sip-pylist">SIP_PYLIST</a>,
<a class="reference" href="#sip-pyslice">SIP_PYSLICE</a>, <a class="reference" href="#sip-pytuple">SIP_PYTUPLE</a> or <a class="reference" href="#sip-pytype">SIP_PYTYPE</a>) may be <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id123" id="array" name="array">8.1.2&nbsp;&nbsp;&nbsp;Array</a></h3>
<p>This boolean annotation specifies that the corresponding argument (which
should be either <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> or <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span></tt>) refers to an array
rather than a <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated string.  There must be a corresponding
argument with the <a class="reference" href="#arraysize">ArraySize</a> annotation specified.  The annotation may only be
specified once in a list of arguments.</p>
<p>The annotation also implies the <a class="reference" href="#encoding">Encoding</a> annotation with an encoding of
<tt class="docutils literal"><span class="pre">&quot;None&quot;</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id124" id="arraysize" name="arraysize">8.1.3&nbsp;&nbsp;&nbsp;ArraySize</a></h3>
<p>This boolean annotation specifies that the corresponding argument (which
should be either <tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">unsigned</span></tt>,
<tt class="docutils literal"><span class="pre">long</span></tt> or <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt>) refers to the size of an array.  There must be
a corresponding argument with the <a class="reference" href="#array">Array</a> annotation specified.  The annotation
may only be specified once in a list of arguments.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id125" id="constrained" name="constrained">8.1.4&nbsp;&nbsp;&nbsp;Constrained</a></h3>
<p>Python will automatically convert between certain compatible types.  For
example, if a floating pointer number is expected and an integer supplied,
then the integer will be converted appropriately.  This can cause problems
when wrapping C or C++ functions with similar signatures.  For example:</p>
<pre class="literal-block">
// The wrapper for this function will also accept an integer argument
// which Python will automatically convert to a floating point number.
void foo(double);

// The wrapper for this function will never get used.
void foo(int);
</pre>
<p>This boolean annotation specifies that the corresponding argument (which
should be either <tt class="docutils literal"><span class="pre">bool</span></tt>, <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">float</span></tt>, <tt class="docutils literal"><span class="pre">double</span></tt>, <tt class="docutils literal"><span class="pre">enum</span></tt> or a
wrapped class) must match the type without any automatic conversions.  In the
context of a wrapped class the invocation of any <a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> is
suppressed.</p>
<p>The following example gets around the above problem:</p>
<pre class="literal-block">
// The wrapper for this function will only accept floating point numbers.
void foo(double /Constrained/);

// The wrapper for this function will be used for anything that Python can
// convert to an integer, except for floating point numbers.
void foo(int);
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id126" id="encoding" name="encoding">8.1.5&nbsp;&nbsp;&nbsp;Encoding</a></h3>
<p>This string annotation specifies that the corresponding argument (which should
be either <tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> or <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt>) refers to
an encoded character or <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated encoded string with the specified
encoding.  The encoding can be either <tt class="docutils literal"><span class="pre">&quot;ASCII&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;Latin-1&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;UTF-8&quot;</span></tt>
or <tt class="docutils literal"><span class="pre">&quot;None&quot;</span></tt>.  An encoding of <tt class="docutils literal"><span class="pre">&quot;None&quot;</span></tt> means that the corresponding argument
refers to an unencoded character or string.</p>
<p>The default encoding is specified by the <a class="reference" href="#defaultencoding">%DefaultEncoding</a> directive.  If the
directive is not specified then <tt class="docutils literal"><span class="pre">None</span></tt> is used.</p>
<p>Python v3 will use the <tt class="docutils literal"><span class="pre">bytes</span></tt> type to represent the argument if the
encoding is <tt class="docutils literal"><span class="pre">&quot;None&quot;</span></tt> and the <tt class="docutils literal"><span class="pre">str</span></tt> type otherwise.</p>
<p>Python v2 will use the <tt class="docutils literal"><span class="pre">str</span></tt> type to represent the argument if the
encoding is <tt class="docutils literal"><span class="pre">&quot;None&quot;</span></tt> and the <tt class="docutils literal"><span class="pre">unicode</span></tt> type otherwise.</p>
<p>The annotation can also be used as a function, typedef or variable annotation.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id127" id="getwrapper" name="getwrapper">8.1.6&nbsp;&nbsp;&nbsp;GetWrapper</a></h3>
<p>This boolean annotation is only ever used in conjunction with handwritten code
specified with the <a class="reference" href="#methodcode">%MethodCode</a> directive.  It causes an extra variable to
be generated for the corresponding argument which is a pointer to the Python
object that wraps the argument.</p>
<p>See the <a class="reference" href="#methodcode">%MethodCode</a> directive for more detail.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id128" id="in" name="in">8.1.7&nbsp;&nbsp;&nbsp;In</a></h3>
<p>This boolean annotation is used to specify that the corresponding argument
(which should be a pointer type) is used to pass a value to the function.</p>
<p>For pointers to wrapped C structures or C++ class instances, <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> and
<tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span></tt> then this annotation is assumed unless the <a class="reference" href="#out">Out</a> annotation
is specified.</p>
<p>For pointers to other types then this annotation must be explicitly specified
if required.  The argument will be dereferenced to obtain the actual value.</p>
<p>Both <a class="reference" href="#in">In</a> and <a class="reference" href="#out">Out</a> may be specified for the same argument.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id129" id="keepreference" name="keepreference">8.1.8&nbsp;&nbsp;&nbsp;KeepReference</a></h3>
<p>This boolean annotation is used to specify that a reference to the
corresponding argument should be kept to ensure that the object is not garbage
collected.  If the method is called again with a new argument then the
reference to the previous argument is discarded.  Note that ownership of the
argument is not changed.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id130" id="out" name="out">8.1.9&nbsp;&nbsp;&nbsp;Out</a></h3>
<p>This boolean annotation is used to specify that the corresponding argument
(which should be a pointer type) is used by the function to return a value as
an element of a tuple.</p>
<p>For pointers to wrapped C structures or C++ class instances, <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> and
<tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span></tt> then this annotation must be explicitly specified if
required.</p>
<p>For pointers to other types then this annotation is assumed unless the <a class="reference" href="#in">In</a>
annotation is specified.</p>
<p>Both <a class="reference" href="#in">In</a> and <a class="reference" href="#out">Out</a> may be specified for the same argument.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id131" id="resultsize" name="resultsize">8.1.10&nbsp;&nbsp;&nbsp;ResultSize</a></h3>
<p>This boolean annotation is used with functions or methods that return a
<tt class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt> or <tt class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span></tt>.  It identifies an argument that defines the
size of the block of memory whose address is being returned.  This allows the
<tt class="docutils literal"><span class="pre">sip.voidptr</span></tt> object that wraps the address to support the Python buffer
protocol and allows the memory to be read and updated when wrapped by the
Python <tt class="docutils literal"><span class="pre">buffer()</span></tt> builtin.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id132" id="singleshot" name="singleshot">8.1.11&nbsp;&nbsp;&nbsp;SingleShot</a></h3>
<p>This boolean annotation is used only with arguments of type <a class="reference" href="#sip-rxobj-con">SIP_RXOBJ_CON</a> to
specify that the signal connected to the slot will only ever be emitted once.
This prevents a certain class of memory leaks.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id133" id="transfer" name="transfer">8.1.12&nbsp;&nbsp;&nbsp;Transfer</a></h3>
<p>This boolean annotation is used to specify that ownership of the corresponding
argument (which should be a wrapped C structure or C++ class instance) is
transferred from Python to C++.  In addition, if the argument is of a class
method, then it is associated with the class instance with regard to the
cyclic garbage collector.</p>
<p>Note that this can also be used as a function annotation.</p>
<p>See <a class="reference" href="#ownership-of-objects">Ownership of Objects</a> for more detail.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id134" id="transferback" name="transferback">8.1.13&nbsp;&nbsp;&nbsp;TransferBack</a></h3>
<p>This boolean annotation is used to specify that ownership of the corresponding
argument (which should be a wrapped C structure or C++ class instance) is
transferred back to Python from C++.  In addition, any association of the
argument with regard to the cyclic garbage collector with another instance is
removed.</p>
<p>Note that this can also be used as a function annotation.</p>
<p>See <a class="reference" href="#ownership-of-objects">Ownership of Objects</a> for more detail.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id135" id="transferthis" name="transferthis">8.1.14&nbsp;&nbsp;&nbsp;TransferThis</a></h3>
<p>This boolean annotation is only used in C++ constructors or methods.  In the
context of a constructor or factory method it specifies that ownership of the
instance being created is transferred from Python to C++ if the corresponding
argument (which should be a wrapped C structure or C++ class instance) is not
<tt class="docutils literal"><span class="pre">None</span></tt>.  In addition, the newly created instance is associated with the
argument with regard to the cyclic garbage collector.</p>
<p>In the context of a non-factory method it specifies that ownership of <tt class="docutils literal"><span class="pre">this</span></tt>
is transferred from Python to C++ if the corresponding argument is not
<tt class="docutils literal"><span class="pre">None</span></tt>.  If it is <tt class="docutils literal"><span class="pre">None</span></tt> then ownership is transferred to Python.</p>
<p>The annotation may be used more that once, in which case ownership is
transferred to last instance that is not <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p>Note that this can also be used as a function annotation.</p>
<p>See <a class="reference" href="#ownership-of-objects">Ownership of Objects</a> for more detail.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id136" id="class-annotations" name="class-annotations">8.2&nbsp;&nbsp;&nbsp;Class Annotations</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id137" id="abstract" name="abstract">8.2.1&nbsp;&nbsp;&nbsp;Abstract</a></h3>
<p>This boolean annotation is used to specify that the class has additional pure
virtual methods that have not been specified and so it cannot be instantiated
or sub-classed from Python.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id138" id="delaydtor" name="delaydtor">8.2.2&nbsp;&nbsp;&nbsp;DelayDtor</a></h3>
<p>This boolean annotation is used to specify that the class's destructor should
not be called until the Python interpreter exits.  It would normally only be
applied to singleton classes.</p>
<p>When the Python interpreter exits the order in which any wrapped instances are
garbage collected is unpredictable.  However, the underlying C or C++ instances
may need to be destroyed in a certain order.  If this annotation is specified
then when the wrapped instance is garbage collected the C or C++ instance is
not destroyed but instead added to a list of delayed instances.  When the
interpreter exits then the function <tt class="docutils literal"><span class="pre">sipDelayedDtors</span></tt> is called with the
list of delayed instances.  <tt class="docutils literal"><span class="pre">sipDelayedDtors</span></tt> can then choose to call (or
ignore) the destructors in any desired order.</p>
<p>The <tt class="docutils literal"><span class="pre">sipDelayedDtors</span></tt> function must be specified using the <a class="reference" href="#modulecode">%ModuleCode</a>
directive.  It's signature is as follows:</p>
<pre class="literal-block">
static void sipDelayedDtors(const sipDelayedDtor *dd_list);
</pre>
<p><tt class="docutils literal"><span class="pre">dd_list</span></tt> is the linked list of delayed instances.  The following fields are
defined.</p>
<dl class="docutils">
<dt>const char *dd_name</dt>
<dd>This is the name of the class excluding any package or module name.</dd>
<dt>void *dd_ptr</dt>
<dd>This is the address of the C or C++ instance to be destroyed.  It's exact
type depends on the value of <tt class="docutils literal"><span class="pre">dd_isderived</span></tt>.</dd>
<dt>int dd_isderived</dt>
<dd>This is non-zero if the type of <tt class="docutils literal"><span class="pre">dd_ptr</span></tt> is actually the generated
derived class.  This allows the correct destructor to be called.  See
<a class="reference" href="#generated-derived-classes">Generated Derived Classes</a>.</dd>
<dt>sipDelayedDtor *dd_next</dt>
<dd>This is the address of the next entry in the list or zero if this is the
last one.</dd>
</dl>
<p>Note that the above applies only to C and C++ instances that are owned by
Python.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id139" id="deprecated" name="deprecated">8.2.3&nbsp;&nbsp;&nbsp;Deprecated</a></h3>
<p>This boolean annotation is used to specify that the class is deprecated.  It is
the equivalent of annotating all the class's constructors, function and methods
as being deprecated.</p>
<p>Note that this can also be used as a function annotation.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id140" id="external" name="external">8.2.4&nbsp;&nbsp;&nbsp;External</a></h3>
<p>This boolean annotation is used to specify that the class is defined in another
module.  Declarations of external classes are private to the module in which
they appear.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id141" id="metatype" name="metatype">8.2.5&nbsp;&nbsp;&nbsp;Metatype</a></h3>
<p>This dotted name annotation specifies the name of the Python type object (i.e.
the value of the <tt class="docutils literal"><span class="pre">tp_name</span></tt> field) used as the meta-type used when creating
the type object for this C structure or C++ type.</p>
<p>See the section <a class="reference" href="#types-and-meta-types">Types and Meta-types</a> for more details.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id142" id="nodefaultctors" name="nodefaultctors">8.2.6&nbsp;&nbsp;&nbsp;NoDefaultCtors</a></h3>
<p>This boolean annotation is used to suppress the automatic generation of default
constructors for the class.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id143" id="pyname" name="pyname">8.2.7&nbsp;&nbsp;&nbsp;PyName</a></h3>
<p>This name annotation specifies an alternative name for the class being wrapped
which is used when it is referred to from Python.  It is required when a class
name is the same as a Python keyword.  It may also be used to avoid name
clashes with other objects (e.g. enums, exceptions, functions) that have the
same name in the same C++ scope.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id144" id="supertype" name="supertype">8.2.8&nbsp;&nbsp;&nbsp;Supertype</a></h3>
<p>This dotted name annotation specifies the name of the Python type object (i.e.
the value of the <tt class="docutils literal"><span class="pre">tp_name</span></tt> field) used as the super-type used when creating
the type object for this C structure or C++ type.</p>
<p>See the section <a class="reference" href="#types-and-meta-types">Types and Meta-types</a> for more details.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id145" id="mapped-type-annotations" name="mapped-type-annotations">8.3&nbsp;&nbsp;&nbsp;Mapped Type Annotations</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id146" id="norelease" name="norelease">8.3.1&nbsp;&nbsp;&nbsp;NoRelease</a></h3>
<p>This boolean annotation is used to specify that the mapped type does not
support the <a class="reference" href="#sipreleasetype">sipReleaseType()</a> function.  Any <a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> should not
create temporary instances of the mapped type, i.e. it should not return
<tt class="docutils literal"><span class="pre">SIP_TEMPORARY</span></tt>.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id147" id="enum-annotations" name="enum-annotations">8.4&nbsp;&nbsp;&nbsp;Enum Annotations</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id148" id="id17" name="id17">8.4.1&nbsp;&nbsp;&nbsp;PyName</a></h3>
<p>This name annotation specifies an alternative name for the enum or enum member
being wrapped which is used when it is referred to from Python.  It is required
when an enum or enum member name is the same as a Python keyword.  It may also
be used to avoid name clashes with other objects (e.g. classes, exceptions,
functions) that have the same name in the same C++ scope.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id149" id="exception-annotations" name="exception-annotations">8.5&nbsp;&nbsp;&nbsp;Exception Annotations</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id150" id="id18" name="id18">8.5.1&nbsp;&nbsp;&nbsp;PyName</a></h3>
<p>This name annotation specifies an alternative name for the exception being
defined which is used when it is referred to from Python.  It is required when
an exception name is the same as a Python keyword.  It may also be used to
avoid name clashes with other objects (e.g. classes, enums, functions) that
have the same name.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id151" id="function-annotations" name="function-annotations">8.6&nbsp;&nbsp;&nbsp;Function Annotations</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id152" id="autogen" name="autogen">8.6.1&nbsp;&nbsp;&nbsp;AutoGen</a></h3>
<p>This optional name annotation is used with class methods to specify that the
method be automatically included in all sub-classes.  The value is the name of
a feature (specified using the <a class="reference" href="#feature">%Feature</a> directive) which must be enabled
for the method to be generated.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id153" id="default" name="default">8.6.2&nbsp;&nbsp;&nbsp;Default</a></h3>
<p>This boolean annotation is only used with C++ constructors.  Sometimes SIP
needs to create a class instance.  By default it uses a constructor with no
compulsory arguments if one is specified.  (SIP will automatically generate a
constructor with no arguments if no constructors are specified.)  This
annotation is used to explicitly specify which constructor to use.  Zero is
passed as the value of any arguments to the constructor.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id154" id="id19" name="id19">8.6.3&nbsp;&nbsp;&nbsp;Deprecated</a></h3>
<p>This boolean annotation is used to specify that the constructor or function is
deprecated.  A deprecation warning is issued whenever the constructor or
function is called.</p>
<p>Note that this can also be used as a class annotation.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id155" id="factory" name="factory">8.6.4&nbsp;&nbsp;&nbsp;Factory</a></h3>
<p>This boolean annotation specifies that the value returned by the function
(which should be a wrapped C structure or C++ class instance) is a newly
created instance and is owned by Python.</p>
<p>See <a class="reference" href="#ownership-of-objects">Ownership of Objects</a> for more detail.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id156" id="holdgil" name="holdgil">8.6.5&nbsp;&nbsp;&nbsp;HoldGIL</a></h3>
<p>This boolean annotation specifies that the Python Global Interpreter Lock (GIL)
is not released before the call to the underlying C or C++ function.  See
<a class="reference" href="#the-python-global-interpreter-lock">The Python Global Interpreter Lock</a> and the <a class="reference" href="#releasegil">ReleaseGIL</a> annotation.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id157" id="newthread" name="newthread">8.6.6&nbsp;&nbsp;&nbsp;NewThread</a></h3>
<p>This boolean annotation specifies that the function will create a new thread.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id158" id="noargparser" name="noargparser">8.6.7&nbsp;&nbsp;&nbsp;NoArgParser</a></h3>
<p>This boolean annotation is used with global functions to specify that the
supplied <a class="reference" href="#methodcode">%MethodCode</a> will handle the parsing of the arguments.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id159" id="noderived" name="noderived">8.6.8&nbsp;&nbsp;&nbsp;NoDerived</a></h3>
<p>This boolean annotation is only used with C++ constructors.  In many cases SIP
generates a derived class for each class being wrapped (see <a class="reference" href="#generated-derived-classes">Generated Derived
Classes</a>).  This derived class contains constructors with the same C++
signatures as the class being wrapped.  Sometimes you may want to define a
Python constructor that has no corresponding C++ constructor.  This annotation
is used to suppress the generation of the constructor in the derived class.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id160" id="numeric" name="numeric">8.6.9&nbsp;&nbsp;&nbsp;Numeric</a></h3>
<p>This boolean annotation specifies that the operator should be interpreted as a
numeric operator rather than a sequence operator.  Python uses the <tt class="docutils literal"><span class="pre">+</span></tt>
operator for adding numbers and concatanating sequences, and the <tt class="docutils literal"><span class="pre">*</span></tt> operator
for multiplying numbers and repeating sequences.  SIP tries to work out which
is meant by looking at other operators that have been defined for the type.
If it finds either <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">-=</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">/=</span></tt>, <tt class="docutils literal"><span class="pre">%</span></tt> or <tt class="docutils literal"><span class="pre">%=</span></tt> defined then
it assumes that <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt> and <tt class="docutils literal"><span class="pre">*=</span></tt> should be numeric operators.
Otherwise, if it finds either <tt class="docutils literal"><span class="pre">[]</span></tt>, <tt class="docutils literal"><span class="pre">__getitem__()</span></tt>, <tt class="docutils literal"><span class="pre">__setitem__()</span></tt> or
<tt class="docutils literal"><span class="pre">__delitem__()</span></tt> defined then it assumes that they should be sequence
operators.  This annotation is used to force SIP to treat the operator as
numeric.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id161" id="posthook" name="posthook">8.6.10&nbsp;&nbsp;&nbsp;PostHook</a></h3>
<p>This name annotation is used to specify the name of a Python builtin that is
called immediately after the call to the underlying C or C++ function or any
handwritten code.  The builtin is not called if an error occurred.  It is
primarily used to integrate with debuggers.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id162" id="prehook" name="prehook">8.6.11&nbsp;&nbsp;&nbsp;PreHook</a></h3>
<p>This name annotation is used to specify the name of a Python builtin that is
called immediately after the function's arguments have been successfully
parsed and before the call to the underlying C or C++ function or any
handwritten code.  It is primarily used to integrate with debuggers.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id163" id="id20" name="id20">8.6.12&nbsp;&nbsp;&nbsp;PyName</a></h3>
<p>This name annotation specifies an alternative name for the function being
wrapped which is used when it is referred to from Python.  It is required when
a function or method name is the same as a Python keyword.  It may also be used
to avoid name clashes with other objects (e.g. classes, enums, exceptions) that
have the same name in the same C++ scope.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id164" id="releasegil" name="releasegil">8.6.13&nbsp;&nbsp;&nbsp;ReleaseGIL</a></h3>
<p>This boolean annotation specifies that the Python Global Interpreter Lock (GIL)
is released before the call to the underlying C or C++ function and reacquired
afterwards.  It should be used for functions that might block or take a
significant amount of time to execute.  See <a class="reference" href="#the-python-global-interpreter-lock">The Python Global Interpreter
Lock</a> and the <a class="reference" href="#holdgil">HoldGIL</a> annotation.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id165" id="id21" name="id21">8.6.14&nbsp;&nbsp;&nbsp;Transfer</a></h3>
<p>This boolean annotation specifies that ownership of the value returned by the
function (which should be a wrapped C structure or C++ class instance) is
transferred to C++.  It is only used in the context of a class constructor or a
method.</p>
<p>In the case of methods returned values (unless they are new references to
already wrapped values) are normally owned by C++ anyway.  However, in
addition, an association between the returned value and the instance containing
the method is created with regard to the cyclic garbage collector.</p>
<p>Note that this can also be used as an argument annotation.</p>
<p>See <a class="reference" href="#ownership-of-objects">Ownership of Objects</a> for more detail.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id166" id="id22" name="id22">8.6.15&nbsp;&nbsp;&nbsp;TransferBack</a></h3>
<p>This boolean annotation specifies that ownership of the value returned by the
function (which should be a wrapped C structure or C++ class instance) is
transferred back to Python from C++.  Normally returned values (unless they are
new references to already wrapped values) are owned by C++.  In addition, any
association of the returned value with regard to the cyclic garbage collector
with another instance is removed.</p>
<p>Note that this can also be used as an argument annotation.</p>
<p>See <a class="reference" href="#ownership-of-objects">Ownership of Objects</a> for more detail.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id167" id="id23" name="id23">8.6.16&nbsp;&nbsp;&nbsp;TransferThis</a></h3>
<p>This boolean annotation specifies that ownership of <tt class="docutils literal"><span class="pre">this</span></tt> is transferred
from Python to C++.</p>
<p>Note that this can also be used as an argument annotation.</p>
<p>See <a class="reference" href="#ownership-of-objects">Ownership of Objects</a> for more detail.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id168" id="license-annotations" name="license-annotations">8.7&nbsp;&nbsp;&nbsp;License Annotations</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id169" id="licensee" name="licensee">8.7.1&nbsp;&nbsp;&nbsp;Licensee</a></h3>
<p>This optional string annotation specifies the license's licensee.  No
restrictions are placed on the contents of the string.</p>
<p>See the <a class="reference" href="#id14">%License</a> directive.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id170" id="signature" name="signature">8.7.2&nbsp;&nbsp;&nbsp;Signature</a></h3>
<p>This optional string annotation specifies the license's signature.  No
restrictions are placed on the contents of the string.</p>
<p>See the <a class="reference" href="#id14">%License</a> directive.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id171" id="timestamp" name="timestamp">8.7.3&nbsp;&nbsp;&nbsp;Timestamp</a></h3>
<p>This optional string annotation specifies the license's timestamp.  No
restrictions are placed on the contents of the string.</p>
<p>See the <a class="reference" href="#id14">%License</a> directive.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id172" id="type" name="type">8.7.4&nbsp;&nbsp;&nbsp;Type</a></h3>
<p>This string annotation specifies the license's type.  No restrictions are
placed on the contents of the string.</p>
<p>See the <a class="reference" href="#id14">%License</a> directive.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id173" id="typedef-annotations" name="typedef-annotations">8.8&nbsp;&nbsp;&nbsp;Typedef Annotations</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id174" id="notypename" name="notypename">8.8.1&nbsp;&nbsp;&nbsp;NoTypeName</a></h3>
<p>This boolean annotation specifies that the definition of the type rather than
the name of the type being defined should be used in the generated code.</p>
<p>Normally a typedef would be defined as follows:</p>
<pre class="literal-block">
typedef bool MyBool;
</pre>
<p>This would result in <tt class="docutils literal"><span class="pre">MyBool</span></tt> being used in the generated code.</p>
<p>Specifying the annotation means that <tt class="docutils literal"><span class="pre">bool</span></tt> will be used in the generated
code instead.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id175" id="variable-annotations" name="variable-annotations">8.9&nbsp;&nbsp;&nbsp;Variable Annotations</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id176" id="id24" name="id24">8.9.1&nbsp;&nbsp;&nbsp;PyName</a></h3>
<p>This name annotation specifies an alternative name for the variable being
wrapped which is used when it is referred to from Python.  It is required when
a variable name is the same as a Python keyword.  It may also be used to avoid
name clashes with other objects (e.g. classes, functions) that have the same
name in the same C++ scope.</p>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id177" id="sip-api-for-handwritten-code" name="sip-api-for-handwritten-code">9&nbsp;&nbsp;&nbsp;SIP API for Handwritten Code</a></h1>
<p>In this section we describe the API that can be used by handwritten code in
specification files.</p>
<div class="section">
<h2><a class="toc-backref" href="#id178" id="sip-api-major-nr" name="sip-api-major-nr">9.1&nbsp;&nbsp;&nbsp;SIP_API_MAJOR_NR</a></h2>
<p>This is a C preprocessor symbol that defines the major number of the SIP API.
Its value is a number.  There is no direct relationship between this and the
SIP version number.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id179" id="sip-api-minor-nr" name="sip-api-minor-nr">9.2&nbsp;&nbsp;&nbsp;SIP_API_MINOR_NR</a></h2>
<p>This is a C preprocessor symbol that defines the minor number of the SIP API.
Its value is a number.  There is no direct relationship between this and the
SIP version number.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id180" id="sip-block-threads" name="sip-block-threads">9.3&nbsp;&nbsp;&nbsp;SIP_BLOCK_THREADS</a></h2>
<p>This is a C preprocessor macro that will make sure the Python Global
Interpreter Lock (GIL) is acquired.  Python API calls must only be made when
the GIL has been acquired.  There must be a corresponding
<a class="reference" href="#sip-unblock-threads">SIP_UNBLOCK_THREADS</a> at the same lexical scope.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id181" id="sip-ssize-t" name="sip-ssize-t">9.4&nbsp;&nbsp;&nbsp;SIP_SSIZE_T</a></h2>
<p>This is a C preprocessor macro that is defined as <tt class="docutils literal"><span class="pre">Py_ssize_t</span></tt> for Python
v2.5 and later, and as <tt class="docutils literal"><span class="pre">int</span></tt> for earlier versions of Python.  It makes it
easier to write PEP 353 compliant handwritten code.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id182" id="sip-unblock-threads" name="sip-unblock-threads">9.5&nbsp;&nbsp;&nbsp;SIP_UNBLOCK_THREADS</a></h2>
<p>This is a C preprocessor macro that will restore the Python Global Interpreter
Lock (GIL) to the state it was prior to the corresponding <a class="reference" href="#sip-block-threads">SIP_BLOCK_THREADS</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id183" id="sip-version" name="sip-version">9.6&nbsp;&nbsp;&nbsp;SIP_VERSION</a></h2>
<p>This is a C preprocessor symbol that defines the SIP version number
represented as a 3 part hexadecimal number (e.g. v4.0.0 is represented as
<tt class="docutils literal"><span class="pre">0x040000</span></tt>).</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id184" id="sip-version-str" name="sip-version-str">9.7&nbsp;&nbsp;&nbsp;SIP_VERSION_STR</a></h2>
<p>This is a C preprocessor symbol that defines the SIP version number
represented as a string.  For development snapshots it will start with
<tt class="docutils literal"><span class="pre">snapshot-</span></tt>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id185" id="sipbadcatcherresult" name="sipbadcatcherresult">9.8&nbsp;&nbsp;&nbsp;sipBadCatcherResult()</a></h2>
<dl class="docutils">
<dt>void sipBadCatcherResult(PyObject *method)</dt>
<dd>This raises a Python exception when the result of a Python reimplementation
of a C++ method doesn't have the expected type.  It is normally called by
handwritten code specified with the <a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a> directive.
<em>method</em> is the Python method and would normally be the supplied
<tt class="docutils literal"><span class="pre">sipMethod</span></tt>.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id186" id="sipbadlengthforslice" name="sipbadlengthforslice">9.9&nbsp;&nbsp;&nbsp;sipBadLengthForSlice()</a></h2>
<dl class="docutils">
<dt>void sipBadLengthForSlice(SIP_SSIZE_T seqlen, SIP_SSIZE_T slicelen)</dt>
<dd>This raises a Python exception when the length of a slice object is
inappropriate for a sequence-like object.  It is normally called by
handwritten code specified for <tt class="docutils literal"><span class="pre">__setitem__()</span></tt> methods.  <em>seqlen</em> is the
length of the sequence.  <em>slicelen</em> is the length of the slice.  With
versions of Python prior to v2.5 the arguments have type <tt class="docutils literal"><span class="pre">int</span></tt>.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id187" id="sipbuildresult" name="sipbuildresult">9.10&nbsp;&nbsp;&nbsp;sipBuildResult()</a></h2>
<dl class="docutils">
<dt>PyObject *sipBuildResult(int *iserr, const char *format, ...)</dt>
<dd><p class="first">This creates a Python object based on a format string and associated
values in a similar way to the Python <tt class="docutils literal"><span class="pre">Py_BuildValue()</span></tt> function.  If
there was an error then <tt class="docutils literal"><span class="pre">NULL</span></tt> is returned and a Python exception is
raised.  If <em>iserr</em> is not <tt class="docutils literal"><span class="pre">NULL</span></tt> then the location it points to is set
to a non-zero value.  <em>format</em> is the string of format characters.</p>
<p>If <em>format</em> begins and ends with parentheses then a tuple of objects is
created.  If <em>format</em> contains more than one format character then
parentheses must be specified.</p>
<p>In the following description the first letter is the format character, the
entry in parentheses is the Python object type that the format character
will create, and the entry in brackets are the types of the C/C++ values
to be passed.</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt> (string) [char]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">char</span></tt> to a Python v2 or v3 string object.</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt> (boolean) [int]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">int</span></tt> to a Python boolean.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt> (string/bytes) [char]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">char</span></tt> to a Python v2 string object or a Python v3
bytes object.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt> (float) [double]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">double</span></tt> to a Python floating point number.</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt> (integer) [enum]</dt>
<dd>Convert an anonymous C/C++ <tt class="docutils literal"><span class="pre">enum</span></tt> to a Python integer.</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt> (float) [float]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">float</span></tt> to a Python floating point number.</dd>
<dt><tt class="docutils literal"><span class="pre">g</span></tt> (string/bytes) [char *, SIP_SSIZE_T]</dt>
<dd>Convert a C/C++ character array and its length to a Python v2 string
object or a Python v3 bytes object.  If the array is <tt class="docutils literal"><span class="pre">NULL</span></tt> then the
length is ignored and the result is <tt class="docutils literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt> (integer) [short]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">short</span></tt> to a Python integer.</dd>
<dt><tt class="docutils literal"><span class="pre">i</span></tt> (integer) [int]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">int</span></tt> to a Python integer.</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt> (long) [long]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">long</span></tt> to a Python integer.</dd>
<dt><tt class="docutils literal"><span class="pre">m</span></tt> (long) [unsigned long]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt> to a Python long.</dd>
<dt><tt class="docutils literal"><span class="pre">n</span></tt> (long) [long long]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt> to a Python long.</dd>
<dt><tt class="docutils literal"><span class="pre">o</span></tt> (long) [unsigned long long]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt> to a Python long.</dd>
<dt><tt class="docutils literal"><span class="pre">s</span></tt> (string/bytes) [char *]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated string to a Python v2 string object
or a Python v3 bytes object.  If the string pointer is <tt class="docutils literal"><span class="pre">NULL</span></tt> then
the result is <tt class="docutils literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt> (long) [unsigned short]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></tt> to a Python long.</dd>
<dt><tt class="docutils literal"><span class="pre">u</span></tt> (long) [unsigned int]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> to a Python long.</dd>
<dt><tt class="docutils literal"><span class="pre">w</span></tt> (unicode/string) [wchar_t]</dt>
<dd>Convert a C/C++ wide character to a Python v2 unicode object or a
Python v3 string object.</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt> (unicode/string) [wchar_t *]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">L'\0'</span></tt> terminated wide character string to a Python
v2 unicode object or a Python v3 string object.  If the string pointer
is <tt class="docutils literal"><span class="pre">NULL</span></tt> then the result is <tt class="docutils literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt> (string) [char *]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated string to a Python v2 or v3 string
object.  If the string pointer is <tt class="docutils literal"><span class="pre">NULL</span></tt> then the result is
<tt class="docutils literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt> (wrapped instance) [<em>type</em> *, sipWrapperType *, PyObject *]</dt>
<dd><p class="first">Convert a new C structure or a new C++ class instance to a Python class
instance object.  Ownership of the structure or instance is determined
by the <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> argument.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> and the instance has
already been wrapped then the ownership is unchanged.  If it is
<tt class="docutils literal"><span class="pre">NULL</span></tt> or <tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership will be with Python.  Otherwise
ownership will be with C/C++ and the instance associated with the
<tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> argument.  The Python class is influenced by any
applicable <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use <tt class="docutils literal"><span class="pre">N</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt> (wrapped instance) [<em>type</em> *, sipWrapperType *, PyObject *]</dt>
<dd><p class="first">Convert a C structure or a C++ class instance to a Python class
instance object.  If the structure or class instance has already been
wrapped then the result is a new reference to the existing class
instance object.  Ownership of the structure or instance is determined
by the <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> argument.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> and the instance has
already been wrapped then the ownership is unchanged.  If it is
<tt class="docutils literal"><span class="pre">NULL</span></tt> and the instance is newly wrapped then ownership will be with
C/C++.  If it is <tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership is transferred to Python
via a call to <a class="reference" href="#siptransferback">sipTransferBack()</a>.  Otherwise ownership is transferred
to C/C++ and the instance associated with the <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> argument
via a call to <a class="reference" href="#siptransferto">sipTransferTo()</a>.  The Python class is influenced by
any applicable <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use <tt class="docutils literal"><span class="pre">D</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt> (wrapped instance) [<em>type</em> *, const sipTypeDef *, PyObject *]</dt>
<dd>Convert a C structure, C++ class or mapped type instance to a Python
object.  If the instance has already been wrapped then the result is a
new reference to the existing object.  Ownership of the instance is
determined by the <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> argument.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> and the
instance has already been wrapped then the ownership is unchanged.  If
it is <tt class="docutils literal"><span class="pre">NULL</span></tt> and the instance is newly wrapped then ownership will be
with C/C++.  If it is <tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership is transferred to
Python via a call to <a class="reference" href="#siptransferback">sipTransferBack()</a>.  Otherwise ownership is
transferred to C/C++ and the instance associated with the
<tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> argument via a call to <a class="reference" href="#siptransferto">sipTransferTo()</a>.  The Python
class is influenced by any applicable <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code.</dd>
<dt><tt class="docutils literal"><span class="pre">E</span></tt> (wrapped enum) [enum, PyTypeObject *]</dt>
<dd><p class="first">Convert a named C/C++ <tt class="docutils literal"><span class="pre">enum</span></tt> to an instance of the corresponding
Python named enum type.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use <tt class="docutils literal"><span class="pre">F</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">F</span></tt> (wrapped enum) [enum, sipTypeDef *]</dt>
<dd>Convert a named C/C++ <tt class="docutils literal"><span class="pre">enum</span></tt> to an instance of the corresponding
Python named enum type.</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt> (unicode) [wchar_t *, SIP_SSIZE_T]</dt>
<dd>Convert a C/C++ wide character array and its length to a Python unicode
object.  If the array is <tt class="docutils literal"><span class="pre">NULL</span></tt> then the length is ignored and the
result is <tt class="docutils literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt> (wrapped instance) [<em>type</em> *, sipTypeDef *, PyObject *]</dt>
<dd>Convert a new C structure, C++ class or mapped type instance to a
Python object.  Ownership of the instance is determined by the
<tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> argument.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> and the instance has
already been wrapped then the ownership is unchanged.  If it is
<tt class="docutils literal"><span class="pre">NULL</span></tt> or <tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership will be with Python.  Otherwise
ownership will be with C/C++ and the instance associated with the
<tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> argument.  The Python class is influenced by any
applicable <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code.</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt> (object) [PyObject *]</dt>
<dd>The result is value passed without any conversions.  The reference
count is unaffected, i.e. a reference is taken.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt> (object) [PyObject *]</dt>
<dd>The result is value passed without any conversions.  The reference
count is incremented.</dd>
<dt><tt class="docutils literal"><span class="pre">V</span></tt> (sip.voidptr) [void *]</dt>
<dd>Convert a C/C++ <tt class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt> Python <tt class="docutils literal"><span class="pre">sip.voidptr</span></tt> object.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id188" id="sipcallmethod" name="sipcallmethod">9.11&nbsp;&nbsp;&nbsp;sipCallMethod()</a></h2>
<dl class="docutils">
<dt>PyObject *sipCallMethod(int *iserr, PyObject *method, const char *format, ...)</dt>
<dd><p class="first">This calls a Python method passing a tuple of arguments based on a format
string and associated values in a similar way to the Python
<tt class="docutils literal"><span class="pre">PyObject_CallObject()</span></tt> function.  If there was an error then <tt class="docutils literal"><span class="pre">NULL</span></tt> is
returned and a Python exception is raised.  If <em>iserr</em> is not <tt class="docutils literal"><span class="pre">NULL</span></tt>
then the location it points to is set to a non-zero value.  <em>method</em> is the
Python bound method to call.  <em>format</em> is the string of format characters
(see <a class="reference" href="#sipbuildresult">sipBuildResult()</a>).</p>
<p class="last">This is normally called by handwritten code specified with the
<a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a> directive with <em>method</em> being the supplied
<tt class="docutils literal"><span class="pre">sipMethod</span></tt>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id189" id="sipcanconverttoenum" name="sipcanconverttoenum">9.12&nbsp;&nbsp;&nbsp;sipCanConvertToEnum()</a></h2>
<dl class="docutils">
<dt>int sipCanConvertToEnum(PyObject *obj, const sipTypeDef *td)</dt>
<dd>This returns a non-zero value if a Python object can be converted to a
named enum.  <em>obj</em> is the Python object.  <em>td</em> is the generated type
structure corresponding to the enum.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id190" id="sipcanconverttoinstance" name="sipcanconverttoinstance">9.13&nbsp;&nbsp;&nbsp;sipCanConvertToInstance()</a></h2>
<dl class="docutils">
<dt>int sipCanConvertToInstance(PyObject *obj, sipWrapperType *type, int flags)</dt>
<dd><p class="first">This returns a non-zero value if a Python object can be converted to an
instance of a C structure or C++ class.  <em>obj</em> is the Python object.
<em>type</em> is the generated type corresponding to the C/C++ type being checked.
<em>flags</em> is any combination of the following values used to fine tune the
check.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SIP_NOT_NONE</span></tt> causes the check to fail if <em>obj</em> is <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">SIP_NO_CONVERTORS</span></tt> suppresses the use of of any
<a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> for <em>type</em>.</li>
</ul>
</blockquote>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipcanconverttotype">sipCanConvertToType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id191" id="sipcanconverttomappedtype" name="sipcanconverttomappedtype">9.14&nbsp;&nbsp;&nbsp;sipCanConvertToMappedType()</a></h2>
<dl class="docutils">
<dt>int sipCanConvertToMappedType(PyObject *obj, const sipMappedType *mt, int flags)</dt>
<dd><p class="first">This returns a non-zero value if a Python object can be converted to an
instance of a C structure or C++ class which has been implemented as a
mapped type.  <em>obj</em> is the Python object.  <em>mt</em> is an opaque structure
returned by <a class="reference" href="#sipfindmappedtype">sipFindMappedType()</a>.  <em>flags</em> is any combination of the
following values used to fine tune the check.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SIP_NOT_NONE</span></tt> causes the check to fail if <em>obj</em> is <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
</ul>
</blockquote>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipcanconverttotype">sipCanConvertToType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id192" id="sipcanconverttotype" name="sipcanconverttotype">9.15&nbsp;&nbsp;&nbsp;sipCanConvertToType()</a></h2>
<dl class="docutils">
<dt>int sipCanConvertToType(PyObject *obj, const sipTypeDef *td, int flags)</dt>
<dd><p class="first">This returns a non-zero value if a Python object can be converted to an
instance of a C structure, C++ class or mapped type.  <em>obj</em> is the Python
object.  <em>td</em> is the generated type structure corresponding to the C/C++
type being checked.  <em>flags</em> is any combination of the following values
used to fine tune the check.</p>
<blockquote class="last">
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SIP_NOT_NONE</span></tt> causes the check to fail if <em>obj</em> is <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">SIP_NO_CONVERTORS</span></tt> suppresses the use of of any
<a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> for <em>td</em>.  It is ignored for mapped types.</li>
</ul>
</blockquote>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id193" id="sipclassname" name="sipclassname">9.16&nbsp;&nbsp;&nbsp;sipClassName()</a></h2>
<dl class="docutils">
<dt>PyObject *sipClassName(PyObject *obj)</dt>
<dd><p class="first">This returns the class name of a wrapped instance as a Python string.  It
comes with a reference.</p>
<p>This is deprecated from SIP v4.8.  Instead you should use the following:</p>
<pre class="last literal-block">
PyString_FromString(obj-&gt;ob_type-&gt;tp_name)
</pre>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id194" id="sipconvertfromconstvoidptr" name="sipconvertfromconstvoidptr">9.17&nbsp;&nbsp;&nbsp;sipConvertFromConstVoidPtr()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromConstVoidPtr(const void *cpp)</dt>
<dd>This creates a <tt class="docutils literal"><span class="pre">sip.voidptr</span></tt> object for a memory address.  The object
will not be writeable and has no associated size.  <em>cpp</em> is the memory
address.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id195" id="sipconvertfromconstvoidptrandsize" name="sipconvertfromconstvoidptrandsize">9.18&nbsp;&nbsp;&nbsp;sipConvertFromConstVoidPtrAndSize()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromConstVoidPtrAndSize(const void *cpp, SIP_SSIZE_T size)</dt>
<dd>This creates a <tt class="docutils literal"><span class="pre">sip.voidptr</span></tt> object for a memory address.  The object
will not be writeable.  <em>cpp</em> is the memory address.  <em>size</em> is the size
associated with the address.  The object can be used as an immutable buffer
object.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id196" id="sipconvertfromenum" name="sipconvertfromenum">9.19&nbsp;&nbsp;&nbsp;sipConvertFromEnum()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromEnum(int eval, const sipTypeDef *td)</dt>
<dd>This converts a named C/C++ <tt class="docutils literal"><span class="pre">enum</span></tt> to an instance of the corresponding
generated Python named enum type.  <em>eval</em> is the enumerated value to
convert.  <em>td</em> is the generated Python type structure (see <a class="reference" href="#generated-type-structures">Generated Type
Structures</a>).</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id197" id="sipconvertfrominstance" name="sipconvertfrominstance">9.20&nbsp;&nbsp;&nbsp;sipConvertFromInstance()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromInstance(void *cpp, sipWrapperType *type, PyObject *transferObj)</dt>
<dd><p class="first">This converts a C structure or a C++ class instance to a Python class
instance object.  <em>cpp</em> is the C/C++ instance.  If the instance has already
been wrapped then the result is a new reference to the existing instance
object.  <em>type</em> is the generated type corresponding to the C/C++ type.
<em>transferObj</em> controls the ownership of the returned value.  If the
structure or class instance has already been wrapped then the result is a
new reference to the existing class instance object.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> and
the instance has already been wrapped then the ownership is unchanged.  If
it is <tt class="docutils literal"><span class="pre">NULL</span></tt> and the instance is newly wrapped then ownership will be
with C/C++.  If it is <tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership is transferred to Python
via a call to <a class="reference" href="#siptransferback">sipTransferBack()</a>.  Otherwise ownership is transferred to
C/C++ and the instance associated with <em>transferObj</em> via a call to
<a class="reference" href="#siptransferto">sipTransferTo()</a>.  The Python class is influenced by any applicable
<a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipconvertfromtype">sipConvertFromType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id198" id="sipconvertfrommappedtype" name="sipconvertfrommappedtype">9.21&nbsp;&nbsp;&nbsp;sipConvertFromMappedType()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromMappedType(void *cpp, const sipMappedType *mt, PyObject *transferObj)</dt>
<dd><p class="first">This converts a C structure or a C++ class instance wrapped as a mapped
type to a Python object.  <em>cpp</em> is the C/C++ instance.  <em>mt</em> is the opaque
structure returned by <a class="reference" href="#sipfindmappedtype">sipFindMappedType()</a>.  <em>transferObj</em> controls any
ownership changes to <em>obj</em>.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> then the ownership is
unchanged.  If it is <tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership is transferred to Python
via a call to <a class="reference" href="#siptransferback">sipTransferBack()</a>.  Otherwise ownership is transferred to
C/C++ and the instance associated with the <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt> argument via a
call to <a class="reference" href="#siptransferto">sipTransferTo()</a>.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipconvertfromtype">sipConvertFromType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id199" id="sipconvertfromnamedenum" name="sipconvertfromnamedenum">9.22&nbsp;&nbsp;&nbsp;sipConvertFromNamedEnum()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromNamedEnum(int eval, PyTypeObject *type)</dt>
<dd><p class="first">This converts a named C/C++ <tt class="docutils literal"><span class="pre">enum</span></tt> to an instance of the corresponding
Python named enum type.  <em>eval</em> is the enumerated value to convert.  <em>type</em>
is the generated Python type object (see <a class="reference" href="#generated-named-enum-type-objects">Generated Named Enum Type
Objects</a>).</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipconvertfromenum">sipConvertFromEnum()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id200" id="sipconvertfromnewinstance" name="sipconvertfromnewinstance">9.23&nbsp;&nbsp;&nbsp;sipConvertFromNewInstance()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromNewInstance(void *cpp, sipWrapperType *type, PyObject *transferObj)</dt>
<dd><p class="first">This converts a new C structure or a new C++ class instance to a Python
class instance object.  <em>cpp</em> is the C/C++ instance.  <em>type</em> is the
generated type corresponding to the C/C++ type.  <em>transferObj</em> controls the
ownership of the returned value.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> or <tt class="docutils literal"><span class="pre">Py_None</span></tt> then
ownership will be with Python.  Otherwise ownership will be with C/C++ and
the instance associated with <em>transferObj</em>.  The Python class is influenced
by any applicable <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipconvertfromnewtype">sipConvertFromNewType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id201" id="sipconvertfromnewtype" name="sipconvertfromnewtype">9.24&nbsp;&nbsp;&nbsp;sipConvertFromNewType()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromNewType(void *cpp, const sipTypeDef *td, PyObject *transferObj)</dt>
<dd>This converts a new C structure, C++ class or mapped type instance to a
Python object.  <em>cpp</em> is the C/C++ instance.  <em>td</em> is the generated type
structure corresponding to the C/C++ type.  <em>transferObj</em> controls the
ownership of the returned value.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> or <tt class="docutils literal"><span class="pre">Py_None</span></tt> then
ownership will be with Python.  Otherwise ownership will be with C/C++ and
the instance associated with <em>transferObj</em>.  The Python class is influenced
by any applicable <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id202" id="sipconvertfromsequenceindex" name="sipconvertfromsequenceindex">9.25&nbsp;&nbsp;&nbsp;sipConvertFromSequenceIndex()</a></h2>
<dl class="docutils">
<dt>SIP_SSIZE_T sipConvertFromSequenceIndex(SIP_SSIZE_T idx, SIP_SSIZE_T len)</dt>
<dd>This converts a Python sequence index (i.e. where a negative value refers
to the offset from the end of the sequence) to a C/C++ array index.  If the
index was out of range then a negative value is returned and a Python
exception raised.  With versions of Python prior to v2.5 the result and the
arguments have type <tt class="docutils literal"><span class="pre">int</span></tt>.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id203" id="sipconvertfromsliceobject" name="sipconvertfromsliceobject">9.26&nbsp;&nbsp;&nbsp;sipConvertFromSliceObject()</a></h2>
<dl class="docutils">
<dt>int sipConvertFromSliceObject(PyObject *slice, SIP_SSIZE_T length, SIP_SSIZE_T *start, SIP_SSIZE_T *stop, SIP_SSIZE_T *step, SIP_SSIZE_T *slicelength)</dt>
<dd>This is a thin wrapper around the Python <tt class="docutils literal"><span class="pre">PySlice_GetIndicesEx()</span></tt>
function provided to make it easier to write handwritten code that is
compatible with SIP v3.x and versions of Python earlier that v2.3.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id204" id="sipconvertfromtype" name="sipconvertfromtype">9.27&nbsp;&nbsp;&nbsp;sipConvertFromType()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromType(void *cpp, const sipTypeDef *td, PyObject *transferObj)</dt>
<dd>This converts a C structure, a C++ class instance or a mapped type to a
Python object.  <em>cpp</em> is the C/C++ instance.  If the instance has already
been wrapped then the result is a new reference to the existing object.
<em>td</em> is the generated type structure corresponding to the C/C++ type.
<em>transferObj</em> controls the ownership of the returned value.  If the
structure or class instance has already been wrapped then the result is a
new reference to the existing object.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> and the instance
has already been wrapped then the ownership is unchanged.  If it is
<tt class="docutils literal"><span class="pre">NULL</span></tt> and the instance is newly wrapped then ownership will be with
C/C++.  If it is <tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership is transferred to Python via a
call to <a class="reference" href="#siptransferback">sipTransferBack()</a>.  Otherwise ownership is transferred to C/C++
and the instance associated with <em>transferObj</em> via a call to
<a class="reference" href="#siptransferto">sipTransferTo()</a>.  The Python class is influenced by any applicable
<a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id205" id="sipconvertfromvoidptr" name="sipconvertfromvoidptr">9.28&nbsp;&nbsp;&nbsp;sipConvertFromVoidPtr()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromVoidPtr(void *cpp)</dt>
<dd>This creates a <tt class="docutils literal"><span class="pre">sip.voidptr</span></tt> object for a memory address.  The object
will be writeable but has no associated size.  <em>cpp</em> is the memory address.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id206" id="sipconvertfromvoidptrandsize" name="sipconvertfromvoidptrandsize">9.29&nbsp;&nbsp;&nbsp;sipConvertFromVoidPtrAndSize()</a></h2>
<dl class="docutils">
<dt>PyObject *sipConvertFromVoidPtrAndSize(void *cpp, SIP_SSIZE_T size)</dt>
<dd>This creates a <tt class="docutils literal"><span class="pre">sip.voidptr</span></tt> object for a memory address.  The object
will be writeable.  <em>cpp</em> is the memory address.  <em>size</em> is the size
associated with the address.  The object can be used as a mutable buffer
object.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id207" id="sipconverttoinstance" name="sipconverttoinstance">9.30&nbsp;&nbsp;&nbsp;sipConvertToInstance()</a></h2>
<dl class="docutils">
<dt>void *sipConvertToInstance(PyObject *obj, sipWrapperType *type, PyObject *transferObj, int flags, int *state, int *iserr)</dt>
<dd><p class="first">This converts a Python object to an instance of a C structure or C++ class
assuming that a previous call to <a class="reference" href="#sipcanconverttoinstance">sipCanConvertToInstance()</a> has been
successful.  <em>obj</em> is the Python object.  <em>type</em> is the generated type
corresponding to the C/C++ type returned.  It may be any class in the
object's class hierarchy.  <em>transferObj</em> controls any ownership changes to
<em>obj</em>.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> then the ownership is unchanged.  If it is
<tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership is transferred to Python via a call to
<a class="reference" href="#siptransferback">sipTransferBack()</a>.  Otherwise ownership is transferred to C/C++ and
<em>obj</em> associated with <em>transferObj</em> via a call to <a class="reference" href="#siptransferto">sipTransferTo()</a>.
<em>flags</em> is any combination of the following values used to fine tune the
check.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SIP_NOT_NONE</span></tt> causes the check to fail if <em>obj</em> is <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">SIP_NO_CONVERTORS</span></tt> suppresses the use of of any
<a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> for <em>type</em>.</li>
</ul>
</blockquote>
<p>If <em>state</em> is not <tt class="docutils literal"><span class="pre">NULL</span></tt> then the location it points to is set to
describe the state of the returned C/C++ instance and is the value returned
by any <a class="reference" href="#converttotypecode">%ConvertToTypeCode</a>.  The calling code must then release the value
at some point to prevent a memory leak by calling <a class="reference" href="#sipreleaseinstance">sipReleaseInstance()</a>.
If there is an error then the location <em>iserr</em> points to is set to a
non-zero value.  If it was initially a non-zero value then the conversion
isn't attempted in the first place.  (This allows several calls to be made
that share the same error flag so that it only needs to be tested once
rather than after each call.)</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipconverttotype">sipConvertToType()</a></p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id208" id="sipconverttomappedtype" name="sipconverttomappedtype">9.31&nbsp;&nbsp;&nbsp;sipConvertToMappedType()</a></h2>
<dl class="docutils">
<dt>void *sipConvertToMappedType(PyObject *obj, const sipMappedType *mt, PyObject *transferObj, int flags, int *state, int *iserr)</dt>
<dd><p class="first">This converts a Python object to an instance of a C structure or C++
class that is implemented as a mapped type assuming that a previous call to
<a class="reference" href="#sipcanconverttomappedtype">sipCanConvertToMappedType()</a> has been successful.  <em>obj</em> is the Python
object.  <em>mt</em> is the opaque structure returned by <a class="reference" href="#sipfindmappedtype">sipFindMappedType()</a>.
<em>transferObj</em> controls any ownership changes to <em>obj</em>.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt>
then the ownership is unchanged.  If it is <tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership is
transferred to Python via a call to <a class="reference" href="#siptransferback">sipTransferBack()</a>.  Otherwise
ownership is transferred to C/C++ and <em>obj</em> associated with <em>transferObj</em>
via a call to <a class="reference" href="#siptransferto">sipTransferTo()</a>.  <em>flags</em> is any combination of the
following values used to fine tune the check.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SIP_NOT_NONE</span></tt> causes the check to fail if <em>obj</em> is <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
</ul>
</blockquote>
<p>If <em>state</em> is not <tt class="docutils literal"><span class="pre">NULL</span></tt> then the location it points to is set to
describe the state of the returned C/C++ instance and is the value returned
by any <a class="reference" href="#converttotypecode">%ConvertToTypeCode</a>.  The calling code must then release the value
at some point to prevent a memory leak by calling
<a class="reference" href="#sipreleasemappedtype">sipReleaseMappedType()</a>.  If there is an error then the location <em>iserr</em>
points to is set to a non-zero value.  If it was initially a non-zero value
then the conversion isn't attempted in the first place.  (This allows
several calls to be made that share the same error flag so that it only
needs to be tested once rather than after each call.)</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipconverttotype">sipConvertToType()</a></p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id209" id="sipconverttotype" name="sipconverttotype">9.32&nbsp;&nbsp;&nbsp;sipConvertToType()</a></h2>
<dl class="docutils">
<dt>void *sipConvertToType(PyObject *obj, const sipTypeDef *td, PyObject *transferObj, int flags, int *state, int *iserr)</dt>
<dd><p class="first">This converts a Python object to an instance of a C structure, C++ class or
mapped type assuming that a previous call to <a class="reference" href="#sipcanconverttotype">sipCanConvertToType()</a> has
been successful.  <em>obj</em> is the Python object.  <em>td</em> is the generated type
structure corresponding to the C/C++ type returned.  It may be any class in
the object's class hierarchy.  <em>transferObj</em> controls any ownership changes
to <em>obj</em>.  If it is <tt class="docutils literal"><span class="pre">NULL</span></tt> then the ownership is unchanged.  If it is
<tt class="docutils literal"><span class="pre">Py_None</span></tt> then ownership is transferred to Python via a call to
<a class="reference" href="#siptransferback">sipTransferBack()</a>.  Otherwise ownership is transferred to C/C++ and
<em>obj</em> associated with <em>transferObj</em> via a call to <a class="reference" href="#siptransferto">sipTransferTo()</a>.
<em>flags</em> is any combination of the following values used to fine tune the
check.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SIP_NOT_NONE</span></tt> causes the check to fail if <em>obj</em> is <tt class="docutils literal"><span class="pre">None</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">SIP_NO_CONVERTORS</span></tt> suppresses the use of of any
<a class="reference" href="#converttotypecode">%ConvertToTypeCode</a> for <em>td</em>.  It is ignored for mapped types.</li>
</ul>
</blockquote>
<p class="last">If <em>state</em> is not <tt class="docutils literal"><span class="pre">NULL</span></tt> then the location it points to is set to
describe the state of the returned C/C++ instance and is the value returned
by any <a class="reference" href="#converttotypecode">%ConvertToTypeCode</a>.  The calling code must then release the value
at some point to prevent a memory leak by calling <a class="reference" href="#sipreleasetype">sipReleaseType()</a>.  If
there is an error then the location <em>iserr</em> points to is set to a non-zero
value.  If it was initially a non-zero value then the conversion isn't
attempted in the first place.  (This allows several calls to be made that
share the same error flag so that it only needs to be tested once rather
than after each call.)</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id210" id="sipconverttovoidptr" name="sipconverttovoidptr">9.33&nbsp;&nbsp;&nbsp;sipConvertToVoidPtr()</a></h2>
<dl class="docutils">
<dt>void *sipConvertToVoidPtr(PyObject *obj)</dt>
<dd>This converts a Python object to a memory address.  <tt class="docutils literal"><span class="pre">obj</span></tt> may be
<tt class="docutils literal"><span class="pre">Py_None</span></tt>, a <tt class="docutils literal"><span class="pre">sip.voidptr</span></tt> or a PyCObject.  The memory address is
returned.  <tt class="docutils literal"><span class="pre">PyErr_Occurred()</span></tt> must be used to determine if the conversion
was successful.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id211" id="sipexportsymbol" name="sipexportsymbol">9.34&nbsp;&nbsp;&nbsp;sipExportSymbol()</a></h2>
<dl class="docutils">
<dt>int sipExportSymbol(const char *name, void *sym)</dt>
<dd>Python does not allow extension modules to directly access symbols in
another extension module.  This exports a symbol, referenced by a name,
that can subsequently be imported, using <a class="reference" href="#sipimportsymbol">sipImportSymbol()</a>, by another
module.  <em>name</em> is the name of the symbol and <em>sym</em> is its value.  Zero is
returned if there was no error.  A negative value is returned if <em>name</em> is
already associated with a symbol or there was some other error.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id212" id="sipfindclass" name="sipfindclass">9.35&nbsp;&nbsp;&nbsp;sipFindClass()</a></h2>
<dl class="docutils">
<dt>sipWrapperType *sipFindClass(const char *type)</dt>
<dd><p class="first">This returns a pointer to the generated type corresponding to a C/C++ type.
<em>type</em> is the C/C++ declaration of the type.  <tt class="docutils literal"><span class="pre">NULL</span></tt> is returned if the
C/C++ type doesn't exist.  The value of the pointer will not change and
may be saved in a static cache.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use <a class="reference" href="#sipfindtype">sipFindType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id213" id="sipfindmappedtype" name="sipfindmappedtype">9.36&nbsp;&nbsp;&nbsp;sipFindMappedType()</a></h2>
<dl class="docutils">
<dt>const sipMappedType *sipFindMappedType(const char *type)</dt>
<dd><p class="first">This returns a pointer to an opaque structure describing a mapped type.
<em>type</em> is the C/C++ declaration of the type.  <tt class="docutils literal"><span class="pre">NULL</span></tt> is returned if the
mapped type doesn't exist.  The value of the pointer will not change and
may be saved in a static cache.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use <a class="reference" href="#sipfindtype">sipFindType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id214" id="sipfindnamedenum" name="sipfindnamedenum">9.37&nbsp;&nbsp;&nbsp;sipFindNamedEnum()</a></h2>
<dl class="docutils">
<dt>PyTypeObject *sipFindNamedEnum(const char *type)</dt>
<dd><p class="first">This returns a pointer to the generated type corresponding to a named C/C++
enum.  <em>type</em> is the C/C++ declaration of the enum.  <tt class="docutils literal"><span class="pre">NULL</span></tt> is returned
if the named C/C++ enum doesn't exist.  The value of the pointer will not
change and may be saved in a static cache.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use <a class="reference" href="#sipfindtype">sipFindType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id215" id="sipfindtype" name="sipfindtype">9.38&nbsp;&nbsp;&nbsp;sipFindType()</a></h2>
<dl class="docutils">
<dt>const sipTypeDef *sipFindType(const char *type)</dt>
<dd>This returns a pointer to the SIP generated type structure corresponding to
a C/C++ type.  <em>type</em> is the C/C++ declaration of the type.  NULL is
returned if the type doesn't exist.  The value of the pointer will not
change and may be saved in a static cache.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id216" id="sipforceconverttoinstance" name="sipforceconverttoinstance">9.39&nbsp;&nbsp;&nbsp;sipForceConvertToInstance()</a></h2>
<dl class="docutils">
<dt>void *sipForceConvertToInstance(PyObject *obj, sipWrapperType *type, PyObject *transferObj, int flags, int *state, int *iserr)</dt>
<dd><p class="first">This converts a Python object to an instance of a C structure or C++ class
by calling <a class="reference" href="#sipcanconverttoinstance">sipCanConvertToInstance()</a> and, if it is successfull, calling
<a class="reference" href="#sipconverttoinstance">sipConvertToInstance()</a>.  See <a class="reference" href="#sipconverttoinstance">sipConvertToInstance()</a> for a full
description of the arguments.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipforceconverttotype">sipForceConvertToType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id217" id="sipforceconverttomappedtype" name="sipforceconverttomappedtype">9.40&nbsp;&nbsp;&nbsp;sipForceConvertToMappedType()</a></h2>
<dl class="docutils">
<dt>void *sipForceConvertToMappedType(PyObject *obj, const sipMappedType *mt, PyObject *transferObj, int flags, int *state, int *iserr)</dt>
<dd><p class="first">This converts a Python object to an instance of a C structure or C++ class
which has been implemented as a mapped type by calling
<a class="reference" href="#sipcanconverttomappedtype">sipCanConvertToMappedType()</a> and, if it is successfull, calling
<a class="reference" href="#sipconverttomappedtype">sipConvertToMappedType()</a>.  See <a class="reference" href="#sipconverttomappedtype">sipConvertToMappedType()</a> for a full
description of the arguments.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipforceconverttotype">sipForceConvertToType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id218" id="sipforceconverttotype" name="sipforceconverttotype">9.41&nbsp;&nbsp;&nbsp;sipForceConvertToType()</a></h2>
<dl class="docutils">
<dt>void *sipForceConvertToType(PyObject *obj, const sipTypeDef *td, PyObject *transferObj, int flags, int *state, int *iserr)</dt>
<dd>This converts a Python object to an instance of a C structure, C++ class or
mapped type by calling <a class="reference" href="#sipcanconverttotype">sipCanConvertToType()</a> and, if it is successfull,
calling <a class="reference" href="#sipconverttotype">sipConvertToType()</a>.  See <a class="reference" href="#sipconverttotype">sipConvertToType()</a> for a full
description of the arguments.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id219" id="sipfree" name="sipfree">9.42&nbsp;&nbsp;&nbsp;sipFree()</a></h2>
<dl class="docutils">
<dt>void sipFree(void *mem)</dt>
<dd>This returns an area of memory allocated by <a class="reference" href="#sipmalloc">sipMalloc()</a> to the heap.
<em>mem</em> is a pointer to the area of memory.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id220" id="sipgetpyobject" name="sipgetpyobject">9.43&nbsp;&nbsp;&nbsp;sipGetPyObject()</a></h2>
<dl class="docutils">
<dt>PyObject *sipGetPyObject(void *cppptr, const sipTypeDef *td)</dt>
<dd>This returns a borrowed reference to the Python object for a C structure or
C++ class instance.  If the structure or class instance hasn't been wrapped
then <tt class="docutils literal"><span class="pre">NULL</span></tt> is returned (and no Python exception is raised).  <em>cppptr</em> is
the pointer to the structure or class instance.  <em>td</em> is the generated type
structure corresponding to the C/C++ type.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id221" id="sipgetwrapper" name="sipgetwrapper">9.44&nbsp;&nbsp;&nbsp;sipGetWrapper()</a></h2>
<dl class="docutils">
<dt>PyObject *sipGetWrapper(void *cppptr, sipWrapperType *type)</dt>
<dd><p class="first">This returns a borrowed reference to the wrapped instance object for a C
structure or C++ class instance.  If the structure or class instance
hasn't been wrapped then <tt class="docutils literal"><span class="pre">NULL</span></tt> is returned (and no Python exception is
raised).  <em>cppptr</em> is the pointer to the structure or class instance.
<em>type</em> is the generated type corresponding to the C/C++ type.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipgetpyobject">sipGetPyObject()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id222" id="sipimportsymbol" name="sipimportsymbol">9.45&nbsp;&nbsp;&nbsp;sipImportSymbol()</a></h2>
<dl class="docutils">
<dt>void *sipImportSymbol(const char *name)</dt>
<dd>Python does not allow extension modules to directly access symbols in
another extension module.  This imports a symbol, referenced by a name,
that has previously been exported, using <a class="reference" href="#sipexportsymbol">sipExportSymbol()</a>, by another
module.  <em>name</em> is the name of the symbol.  The value of the symbol is
returned if there was no error.  <tt class="docutils literal"><span class="pre">NULL</span></tt> is returned if there is no such
symbol.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id223" id="sipinttypeclassmap" name="sipinttypeclassmap">9.46&nbsp;&nbsp;&nbsp;sipIntTypeClassMap</a></h2>
<p>This C structure is used with <a class="reference" href="#sipmapinttoclass">sipMapIntToClass()</a> to define a mapping
between integer based RTTI and <a class="reference" href="#generated-type-objects">generated type objects</a>.  The structure
elements are as follows.</p>
<dl class="docutils">
<dt>int typeInt</dt>
<dd>The integer RTTI.</dd>
<dt>sipWrapperType **pyType.</dt>
<dd>A pointer to the corresponding Python type object.</dd>
</dl>
<p>This is deprecated from SIP v4.8.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id224" id="siplong-asunsignedlong" name="siplong-asunsignedlong">9.47&nbsp;&nbsp;&nbsp;sipLong_AsUnsignedLong()</a></h2>
<dl class="docutils">
<dt>unsigned long sipLong_AsUnsignedLong(PyObject *obj)</dt>
<dd>This function is a thin wrapper around PyLong_AsUnsignedLong() that works
around a bug in Python v2.3.x and earlier when converting integer objects.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id225" id="sipmalloc" name="sipmalloc">9.48&nbsp;&nbsp;&nbsp;sipMalloc()</a></h2>
<dl class="docutils">
<dt>void *sipMalloc(size_t nbytes)</dt>
<dd>This allocates an area of memory of size <em>nytes</em> on the heap using the
Python <tt class="docutils literal"><span class="pre">PyMem_Malloc()</span></tt> function.  If there was an error then <tt class="docutils literal"><span class="pre">NULL</span></tt> is
returned and a Python exception raised.  See <a class="reference" href="#sipfree">sipFree()</a>.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id226" id="sipmapinttoclass" name="sipmapinttoclass">9.49&nbsp;&nbsp;&nbsp;sipMapIntToClass()</a></h2>
<dl class="docutils">
<dt>sipWrapperType *sipMapIntToClass(int type, const sipIntTypeClassMap *map, int maplen)</dt>
<dd><p class="first">This is used in <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code as a convenient way of
converting integer based RTTI to the corresponding Python type object.
<em>type</em> is the RTTI.  <em>map</em> is the table of known RTTI and the corresponding
type objects (see <a class="reference" href="#sipinttypeclassmap">sipIntTypeClassMap</a>).  The entries in the table must be
sorted in ascending order of RTTI.  <em>maplen</em> is the number of entries in
the table.  The corresponding Python type object is returned, or <tt class="docutils literal"><span class="pre">NULL</span></tt>
if <em>type</em> wasn't in <em>map</em>.</p>
<p class="last">This is deprecated from SIP v4.8.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id227" id="sipmapstringtoclass" name="sipmapstringtoclass">9.50&nbsp;&nbsp;&nbsp;sipMapStringToClass()</a></h2>
<dl class="docutils">
<dt>sipWrapperType *sipMapStringToClass(char *type, const sipStringTypeClassMap *map, int maplen)</dt>
<dd><p class="first">This is used in <a class="reference" href="#converttosubclasscode">%ConvertToSubClassCode</a> code as a convenient way of
converting <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated string based RTTI to the corresponding
Python type object.  <em>type</em> is the RTTI.  <em>map</em> is the table of known RTTI
and the corresponding type objects (see <a class="reference" href="#sipstringtypeclassmap">sipStringTypeClassMap</a>).  The
entries in the table must be sorted in ascending order of RTTI.  <em>maplen</em>
is the number of entries in the table.  The corresponding Python type
object is returned, or <tt class="docutils literal"><span class="pre">NULL</span></tt> if <em>type</em> wasn't in <em>map</em>.</p>
<p class="last">This is deprecated from SIP v4.8.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id228" id="sipparseresult" name="sipparseresult">9.51&nbsp;&nbsp;&nbsp;sipParseResult()</a></h2>
<dl class="docutils">
<dt>int sipParseResult(int *iserr, PyObject *method, PyObject *result, const char *format, ...)</dt>
<dd><p class="first">This converts a Python object (usually returned by a method) to C/C++ based
on a format string and associated values in a similar way to the Python
<tt class="docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt> function.  If there was an error then a negative
value is returned and a Python exception is raised.  If <em>iserr</em> is not
<tt class="docutils literal"><span class="pre">NULL</span></tt> then the location it points to is set to a non-zero value.
<em>method</em> is the Python bound method that returned the <em>result</em> object.
<em>format</em> is the string of format characters.</p>
<p>This is normally called by handwritten code specified with the
<a class="reference" href="#virtualcatchercode">%VirtualCatcherCode</a> directive with <em>method</em> being the supplied
<tt class="docutils literal"><span class="pre">sipMethod</span></tt> and <tt class="docutils literal"><span class="pre">result</span></tt> being the value returned by
<a class="reference" href="#sipcallmethod">sipCallMethod()</a>.</p>
<p>If <em>format</em> begins and ends with parentheses then <em>result</em> must be a Python
tuple and the rest of <em>format</em> is applied to the tuple contents.</p>
<p>In the following description the first letter is the format character, the
entry in parentheses is the Python object type that the format character
will convert, and the entry in brackets are the types of the C/C++ values
to be passed.</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">ae</span></tt> (object) [char *]</dt>
<dd>Convert a Python string-like object of length 1 to a C/C++ <tt class="docutils literal"><span class="pre">char</span></tt>
according to the encoding <tt class="docutils literal"><span class="pre">e</span></tt>.  <tt class="docutils literal"><span class="pre">e</span></tt> can either be <tt class="docutils literal"><span class="pre">A</span></tt> for ASCII,
<tt class="docutils literal"><span class="pre">L</span></tt> for Latin-1, or <tt class="docutils literal"><span class="pre">8</span></tt> for UTF-8.  For Python v2 the object may be
either a string or a unicode object that can be encoded.  For Python v3
the object may either be a bytes object or a string object that can be
encoded.  An object that supports the buffer protocol may also be used.</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt> (integer) [bool *]</dt>
<dd>Convert a Python integer to a C/C++ <tt class="docutils literal"><span class="pre">bool</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt> (string/bytes) [char *]</dt>
<dd>Convert a Python v2 string object or a Python v3 bytes object of length
1 to a C/C++ <tt class="docutils literal"><span class="pre">char</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt> (float) [double *]</dt>
<dd>Convert a Python floating point number to a C/C++ <tt class="docutils literal"><span class="pre">double</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt> (integer) [enum *]</dt>
<dd>Convert a Python integer to an anonymous C/C++ <tt class="docutils literal"><span class="pre">enum</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt> (float) [float *]</dt>
<dd>Convert a Python floating point number to a C/C++ <tt class="docutils literal"><span class="pre">float</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">g</span></tt> (string/bytes) [const char **, SIP_SSIZE_T *]</dt>
<dd>Convert a Python v2 string object or a Python v3 bytes object to a
C/C++ character array and its length.  If the Python object is
<tt class="docutils literal"><span class="pre">Py_None</span></tt> then the array and length are <tt class="docutils literal"><span class="pre">NULL</span></tt> and zero
respectively.</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt> (integer) [short *]</dt>
<dd>Convert a Python integer to a C/C++ <tt class="docutils literal"><span class="pre">short</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">i</span></tt> (integer) [int *]</dt>
<dd>Convert a Python integer to a C/C++ <tt class="docutils literal"><span class="pre">int</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt> (long) [long *]</dt>
<dd>Convert a Python long to a C/C++ <tt class="docutils literal"><span class="pre">long</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">m</span></tt> (long) [unsigned long *]</dt>
<dd>Convert a Python long to a C/C++ <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">n</span></tt> (long) [long long *]</dt>
<dd>Convert a Python long to a C/C++ <tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">o</span></tt> (long) [unsigned long long *]</dt>
<dd>Convert a Python long to a C/C++ <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">s</span></tt> (string/bytes) [const char **]</dt>
<dd><p class="first">Convert a Python v2 string object or a Python v3 bytes object to a
C/C++ <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated string.  If the Python object is <tt class="docutils literal"><span class="pre">Py_None</span></tt>
then the string is <tt class="docutils literal"><span class="pre">NULL</span></tt>.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use <tt class="docutils literal"><span class="pre">B</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt> (long) [unsigned short *]</dt>
<dd>Convert a Python long to a C/C++ <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">u</span></tt> (long) [unsigned int *]</dt>
<dd>Convert a Python long to a C/C++ <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">w</span></tt> (unicode/string) [wchar_t *]</dt>
<dd>Convert a Python v2 unicode object or a Python v3 string object of
length 1 to a C/C++ wide character.</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt> (unicode/string) [wchar_t **]</dt>
<dd>Convert a Python v2 unicode object or a Python v3 string object to a
C/C++ <tt class="docutils literal"><span class="pre">L'\0'</span></tt> terminated wide character string.  If the Python object
is <tt class="docutils literal"><span class="pre">Py_None</span></tt> then the string is <tt class="docutils literal"><span class="pre">NULL</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">Ae</span></tt> (object) [int, const char **]</dt>
<dd>Convert a Python string-like object to a C/C++ <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated
string according to the encoding <tt class="docutils literal"><span class="pre">e</span></tt>.  <tt class="docutils literal"><span class="pre">e</span></tt> can either be <tt class="docutils literal"><span class="pre">A</span></tt> for
ASCII, <tt class="docutils literal"><span class="pre">L</span></tt> for Latin-1, or <tt class="docutils literal"><span class="pre">8</span></tt> for UTF-8.  If the Python object is
<tt class="docutils literal"><span class="pre">Py_None</span></tt> then the string is <tt class="docutils literal"><span class="pre">NULL</span></tt>.  The integer uniquely
identifies the object in the context defined by the <tt class="docutils literal"><span class="pre">S</span></tt> format
character and allows an extra reference to the object to be kept to
ensure that the string remains valid.  For Python v2 the object may be
either a string or a unicode object that can be encoded.  For Python v3
the object may either be a bytes object or a string object that can be
encoded.  An object that supports the buffer protocol may also be used.</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt> (string/bytes) [int, const char **]</dt>
<dd>Convert a Python v2 string object or a Python v3 bytes object to a
C/C++ <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated string.  If the Python object is <tt class="docutils literal"><span class="pre">Py_None</span></tt>
then the string is <tt class="docutils literal"><span class="pre">NULL</span></tt>.  The integer uniquely identifies the
object in the context defined by the <tt class="docutils literal"><span class="pre">S</span></tt> format character and allows
an extra reference to the object to be kept to ensure that the string
remains valid.</dd>
<dt><tt class="docutils literal"><span class="pre">Cf</span></tt> (wrapped class) [sipWrapperType *, int *, void **]</dt>
<dd><p class="first">Convert a Python object to a C structure or a C++ class instance and
return its state as described in <a class="reference" href="#sipconverttoinstance">sipConvertToInstance()</a>.  <tt class="docutils literal"><span class="pre">f</span></tt> is a
combination of the following flags encoded as an ASCII character by
adding <tt class="docutils literal"><span class="pre">0</span></tt> to the combined value:</p>
<blockquote>
<p>0x01 disallows the conversion of <tt class="docutils literal"><span class="pre">Py_None</span></tt> to <tt class="docutils literal"><span class="pre">NULL</span></tt></p>
<p>0x02 implements the <a class="reference" href="#factory">Factory</a> annotation</p>
<dl class="docutils">
<dt>0x04 suppresses the return of the state of the returned C/C++</dt>
<dd>instance.  Note that the <tt class="docutils literal"><span class="pre">int</span> <span class="pre">*</span></tt> used to return the state is
not passed if this flag is specified.</dd>
</dl>
</blockquote>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use <tt class="docutils literal"><span class="pre">Df</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Df</span></tt> (wrapped instance) [const sipTypeDef *, int *, void **]</dt>
<dd><p class="first">Convert a Python object to a C structure, C++ class or mapped type
instance and return its state as described in <a class="reference" href="#sipconverttotype">sipConvertToType()</a>.
<tt class="docutils literal"><span class="pre">f</span></tt> is a combination of the following flags encoded as an ASCII
character by adding <tt class="docutils literal"><span class="pre">0</span></tt> to the combined value:</p>
<blockquote class="last">
<p>0x01 disallows the conversion of <tt class="docutils literal"><span class="pre">Py_None</span></tt> to <tt class="docutils literal"><span class="pre">NULL</span></tt></p>
<p>0x02 implements the <a class="reference" href="#factory">Factory</a> annotation</p>
<dl class="docutils">
<dt>0x04 suppresses the return of the state of the returned C/C++</dt>
<dd>instance.  Note that the <tt class="docutils literal"><span class="pre">int</span> <span class="pre">*</span></tt> used to return the state is
not passed if this flag is specified.</dd>
</dl>
</blockquote>
</dd>
<dt><tt class="docutils literal"><span class="pre">E</span></tt> (wrapped enum) [PyTypeObject *, enum *]</dt>
<dd><p class="first">Convert a Python named enum type to the corresponding C/C++ <tt class="docutils literal"><span class="pre">enum</span></tt>.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use <tt class="docutils literal"><span class="pre">F</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">F</span></tt> (wrapped enum) [sipTypeDef *, enum *]</dt>
<dd>Convert a Python named enum type to the corresponding C/C++ <tt class="docutils literal"><span class="pre">enum</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt> (unicode) [wchar_t **, SIP_SSIZE_T *]</dt>
<dd>Convert a Python unicode object to a C/C++ wide character array and its
length.  If the Python object is <tt class="docutils literal"><span class="pre">Py_None</span></tt> then the array and length
are <tt class="docutils literal"><span class="pre">NULL</span></tt> and zero respectively.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt> (object) [PyTypeObject *, PyObject **]</dt>
<dd>A Python object is checked to see if it is a certain type and then
returned without any conversions.  The reference count is incremented.
The Python object may be <tt class="docutils literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt> (object) [PyObject **]</dt>
<dd>A Python object is returned without any conversions.  The reference
count is incremented.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt> [sipSimpleWrapper *]</dt>
<dd>This format character, if used, must be the first.  It is used with
other format characters to define a context and doesn't itself convert
an argument.</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt> (object) [PyTypeObject *, PyObject **]</dt>
<dd>A Python object is checked to see if it is a certain type and then
returned without any conversions.  The reference count is incremented.
The Python object may not be <tt class="docutils literal"><span class="pre">Py_None</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">V</span></tt> (sip.voidptr) [void *]</dt>
<dd>Convert a Python <tt class="docutils literal"><span class="pre">sip.voidptr</span></tt> object to a C/C++ <tt class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">Z</span></tt> (object) []</dt>
<dd>Check that a Python object is <tt class="docutils literal"><span class="pre">Py_None</span></tt>.  No value is returned.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id229" id="sipregisterattributegetter" name="sipregisterattributegetter">9.52&nbsp;&nbsp;&nbsp;sipRegisterAttributeGetter()</a></h2>
<dl class="docutils">
<dt>int sipRegisterAttributeGetter(const sipTypeDef *td, sipAttrGetterFunc getter)</dt>
<dd><p class="first">This registers a handler that will called just before SIP needs to get an
attribute from a wrapped type's dictionary for the first time.  The handler
must then populate the type's dictionary with any lazy attributes.  -1 is
returned if there was an error registering the handler, 0 is returned
otherwise.</p>
<p><em>td</em> is an optional generated type definition which means that the handler
will only be called for types with that type or sub-classed from it.  If it
is <tt class="docutils literal"><span class="pre">NULL</span></tt> then the handler will be called for all types.</p>
<p><em>getter</em> is the handler and it has the following signature.</p>
<dl class="docutils">
<dt>int handler(const sipTypeDef *td, PyObject *dict)</dt>
<dd><p class="first"><em>td</em> is the generated type definition of the type whose dictionary is
to be populated.</p>
<p><em>dict</em> is the dictionary to be populated.</p>
<p class="last">-1 is returned if there is an error, 0 is returned otherwise.</p>
</dd>
</dl>
<p class="last">See the section <a class="reference" href="#lazy-type-attributes">Lazy Type Attributes</a> for more details.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id230" id="sipregisterpytype" name="sipregisterpytype">9.53&nbsp;&nbsp;&nbsp;sipRegisterPyType()</a></h2>
<dl class="docutils">
<dt>int sipRegisterPyType(PyTypeObject *type)</dt>
<dd><p class="first">This registers a type object that can be used as the meta-type or
super-type of a wrapped C++ type.  <em>type</em> is the type.  -1 is returned if
there was an error registering the type, 0 is returned otherwise.</p>
<p class="last">See the section <a class="reference" href="#types-and-meta-types">Types and Meta-types</a> for more details.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id231" id="sipreleaseinstance" name="sipreleaseinstance">9.54&nbsp;&nbsp;&nbsp;sipReleaseInstance()</a></h2>
<dl class="docutils">
<dt>void sipReleaseInstance(void *cpp, sipWrapperType *type, int state)</dt>
<dd><p class="first">This destroys a wrapped C/C++ instance if it was a temporary instance.  It
is called after a call to either <a class="reference" href="#sipconverttoinstance">sipConvertToInstance()</a> or
<a class="reference" href="#sipforceconverttoinstance">sipForceConvertToInstance()</a>.  <em>cpp</em> is the wrapped C/C++ instance.
<em>type</em> is the generated type corresponding to <em>cpp</em>.  <em>state</em> describes the
state of the instance.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipreleasetype">sipReleaseType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id232" id="sipreleasemappedtype" name="sipreleasemappedtype">9.55&nbsp;&nbsp;&nbsp;sipReleaseMappedType()</a></h2>
<dl class="docutils">
<dt>void sipReleaseMappedType(void *cpp, const sipMappedType *mt, int state)</dt>
<dd><p class="first">This destroys a wrapped C/C++ mapped type if it was a temporary instance.
It is called after a call to either <a class="reference" href="#sipconverttomappedtype">sipConvertToMappedType()</a> or
<a class="reference" href="#sipforceconverttomappedtype">sipForceConvertToMappedType()</a>.  <em>cpp</em> is the wrapped C/C++ instance.
<em>mt</em> is the opaque structure returned by <a class="reference" href="#sipfindmappedtype">sipFindMappedType()</a>.  <em>state</em>
describes the state of the instance.</p>
<p class="last">This is deprecated from SIP v4.8.  Instead you should use
<a class="reference" href="#sipreleasetype">sipReleaseType()</a>.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id233" id="sipreleasetype" name="sipreleasetype">9.56&nbsp;&nbsp;&nbsp;sipReleaseType()</a></h2>
<dl class="docutils">
<dt>void sipReleaseType(void *cpp, const sipTypeDef *td, int state)</dt>
<dd>This destroys a wrapped C/C++ or mapped type instance if it was a temporary
instance.  It is called after a call to either <a class="reference" href="#sipconverttotype">sipConvertToType()</a> or
<a class="reference" href="#sipforceconverttotype">sipForceConvertToType()</a>.  <em>cpp</em> is the wrapped C/C++ instance.  <em>td</em> is
the generated type structure.  <em>state</em> describes the state of the instance.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id234" id="sipresolvetypedef" name="sipresolvetypedef">9.57&nbsp;&nbsp;&nbsp;sipResolveTypedef()</a></h2>
<dl class="docutils">
<dt>const char *sipResolveTypedef(const char *name)</dt>
<dd>If <em>name</em> refers to a C/C++ typedef then the value of that typedef is
returned, otherwise <tt class="docutils literal"><span class="pre">NULL</span></tt> is returned.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id235" id="sipsimplewrapper" name="sipsimplewrapper">9.58&nbsp;&nbsp;&nbsp;sipSimpleWrapper</a></h2>
<p>This is a C structure that represents a Python wrapped instance whose type is
<tt class="docutils literal"><span class="pre">sip.simplewrapper</span></tt>.  It is an extension of the <tt class="docutils literal"><span class="pre">PyObject</span></tt> structure and so
may be safely cast to it.</p>
<p>It includes a member called <tt class="docutils literal"><span class="pre">user</span></tt> which is of type <tt class="docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></tt>.  This can
be used for any purpose by handwritten code and will automatically be garbage
collected at the appropriate time.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id236" id="sipsimplewrapper-type" name="sipsimplewrapper-type">9.59&nbsp;&nbsp;&nbsp;sipSimpleWrapper_Type</a></h2>
<p>This is a pointer to a <tt class="docutils literal"><span class="pre">PyTypeObject</span></tt> structure that is the type of a
<a class="reference" href="#sipsimplewrapper">sipSimpleWrapper</a> structure and is the C implementation of
<tt class="docutils literal"><span class="pre">sip.simplewrapper</span></tt>.  It may be safely cast to <a class="reference" href="#sipwrappertype">sipWrapperType</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id237" id="sipstringtypeclassmap" name="sipstringtypeclassmap">9.60&nbsp;&nbsp;&nbsp;sipStringTypeClassMap</a></h2>
<p>This C structure is used with <a class="reference" href="#sipmapstringtoclass">sipMapStringToClass()</a> to define a mapping
between <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated string based RTTI and <a class="reference" href="#generated-type-objects">generated type objects</a>.
The structure elements are as follows.</p>
<dl class="docutils">
<dt>char *typeString</dt>
<dd>The <tt class="docutils literal"><span class="pre">'\0'</span></tt> terminated string RTTI.</dd>
<dt>sipWrapperType **pyType.</dt>
<dd>A pointer to the corresponding Python type object.</dd>
</dl>
<p>This is deprecated from SIP v4.8.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id238" id="siptransferback" name="siptransferback">9.61&nbsp;&nbsp;&nbsp;sipTransferBack()</a></h2>
<dl class="docutils">
<dt>void sipTransferBack(PyObject *obj)</dt>
<dd>This transfers ownership of a Python wrapped instance to Python (see
<a class="reference" href="#ownership-of-objects">Ownership of Objects</a>).  <em>obj</em> is the wrapped instance.  In addition,
any association of the instance with regard to the cyclic garbage
collector with another instance is removed.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id239" id="siptransferbreak" name="siptransferbreak">9.62&nbsp;&nbsp;&nbsp;sipTransferBreak()</a></h2>
<dl class="docutils">
<dt>void sipTransferBreak(PyObject *obj)</dt>
<dd>Any association of a Python wrapped instance with regard to the cyclic
garbage collector with another instance is removed.  <em>obj</em> is the wrapped
instance.  Ownership of the instance should be with C++.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id240" id="siptransferto" name="siptransferto">9.63&nbsp;&nbsp;&nbsp;sipTransferTo()</a></h2>
<dl class="docutils">
<dt>void sipTransferTo(PyObject *obj, PyObject *owner)</dt>
<dd>This transfers ownership of a Python wrapped instance to C++ (see
<a class="reference" href="#ownership-of-objects">Ownership of Objects</a>).  <em>obj</em> is the wrapped instance.  <em>owner</em> is an
optional wrapped instance that <em>obj</em> becomes associated with with regard
to the cyclic garbage collector.  If <em>owner</em> is <tt class="docutils literal"><span class="pre">NULL</span></tt> then no such
association is made.  If <em>owner</em> is the same value as <em>obj</em> then any
reference cycles involving <em>obj</em> can never be detected or broken by the
cyclic garbage collector.  Responsibility for calling the C++ instance's
destructor is always transfered to C++.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id241" id="siptypeaspytypeobject" name="siptypeaspytypeobject">9.64&nbsp;&nbsp;&nbsp;sipTypeAsPyTypeObject()</a></h2>
<dl class="docutils">
<dt>PyTypeObject *sipTypeAsPyTypeObject(sipTypeDef *td)</dt>
<dd><p class="first">This returns a pointer to the Python type object that SIP creates from a
generated type structure.  <em>td</em> is the type structure.</p>
<p>If the type structure refers to a C structure or C++ class then it may be
safely cast to a <a class="reference" href="#sipwrappertype">sipWrapperType</a>.</p>
<p class="last">If the type structure refers to a mapped type then <tt class="docutils literal"><span class="pre">NULL</span></tt> will be
returned.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id242" id="siptypefrompytypeobject" name="siptypefrompytypeobject">9.65&nbsp;&nbsp;&nbsp;sipTypeFromPyTypeObject()</a></h2>
<dl class="docutils">
<dt>const sipTypeDef *sipTypeFromPyTypeObject(PyTypeObject *py_type)</dt>
<dd><p class="first">This returns a pointer to the SIP generated type structure for a Python
type.  <em>py_type</em> is the Python type object.</p>
<p class="last">If the Python type doesn't correspond to a SIP generated type then <tt class="docutils literal"><span class="pre">NULL</span></tt>
will be returned.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id243" id="siptypeisclass" name="siptypeisclass">9.66&nbsp;&nbsp;&nbsp;sipTypeIsClass()</a></h2>
<dl class="docutils">
<dt>int sipTypeIsClass(sipTypeDef *td)</dt>
<dd>This returns a non-zero value if the generated type structure refers to a
C structure or C++ class.  <em>td</em> is the type structure.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id244" id="siptypeisenum" name="siptypeisenum">9.67&nbsp;&nbsp;&nbsp;sipTypeIsEnum()</a></h2>
<dl class="docutils">
<dt>int sipTypeIsEnum(sipTypeDef *td)</dt>
<dd>This returns a non-zero value if the generated type structure refers to a
named enum.  <em>td</em> is the type structure.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id245" id="siptypeismapped" name="siptypeismapped">9.68&nbsp;&nbsp;&nbsp;sipTypeIsMapped()</a></h2>
<dl class="docutils">
<dt>int sipTypeIsMapped(sipTypeDef *td)</dt>
<dd>This returns a non-zero value if the generated type structure refers to a
mapped type.  <em>td</em> is the type structure.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id246" id="siptypeisnamespace" name="siptypeisnamespace">9.69&nbsp;&nbsp;&nbsp;sipTypeIsNamespace()</a></h2>
<dl class="docutils">
<dt>int sipTypeIsNamespace(sipTypeDef *td)</dt>
<dd>This returns a non-zero value if the generated type structure refers to a
C++ namespace.  <em>td</em> is the type structure.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id247" id="siptypename" name="siptypename">9.70&nbsp;&nbsp;&nbsp;sipTypeName()</a></h2>
<dl class="docutils">
<dt>const char *sipTypeName(const sipTypeDef *td)</dt>
<dd>This returns the C/C++ name of a SIP generated type.  <em>td</em> is the type
structure.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id248" id="siptypescope" name="siptypescope">9.71&nbsp;&nbsp;&nbsp;sipTypeScope()</a></h2>
<dl class="docutils">
<dt>const sipTypeDef *sipTypeScope(const sipTypeDef *td)</dt>
<dd>This returns the SIP generated type structure of the scope of another
SIP generated type structure.  <tt class="docutils literal"><span class="pre">NULL</span></tt> will be returned if the type has no
scope.</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id249" id="sipvoidptr-type" name="sipvoidptr-type">9.72&nbsp;&nbsp;&nbsp;sipVoidPtr_Type</a></h2>
<p>This is a pointer to a <tt class="docutils literal"><span class="pre">PyTypeObject</span></tt> structure that is the type of a
<tt class="docutils literal"><span class="pre">PyObject</span></tt> structure that is used to wrap a <tt class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id250" id="sipwrapper" name="sipwrapper">9.73&nbsp;&nbsp;&nbsp;sipWrapper</a></h2>
<p>This is a C structure that represents a Python wrapped instance whose type is
<tt class="docutils literal"><span class="pre">sip.wrapper</span></tt>.  It is an extension of the <a class="reference" href="#sipsimplewrapper">sipSimpleWrapper</a> and
<tt class="docutils literal"><span class="pre">PyObject</span></tt> structures and so may be safely cast to both.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id251" id="sipwrapper-check" name="sipwrapper-check">9.74&nbsp;&nbsp;&nbsp;sipWrapper_Check()</a></h2>
<dl class="docutils">
<dt>int sipWrapper_Check(PyObject *obj)</dt>
<dd><p class="first">This returns a non-zero value if a Python object is a wrapped instance.
<em>obj</em> is the Python object.</p>
<p>This is deprecated from SIP v4.8.  Instead you should use the following:</p>
<pre class="last literal-block">
PyObject_TypeCheck(obj, sipWrapper_Type)
</pre>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id252" id="sipwrapper-type" name="sipwrapper-type">9.75&nbsp;&nbsp;&nbsp;sipWrapper_Type</a></h2>
<p>This is a pointer to a <tt class="docutils literal"><span class="pre">PyTypeObject</span></tt> structure that is the type of a
<a class="reference" href="#sipwrapper">sipWrapper</a> structure and is the C implementation of <tt class="docutils literal"><span class="pre">sip.wrapper</span></tt>.  It may
be safely cast to <a class="reference" href="#sipwrappertype">sipWrapperType</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id253" id="sipwrappertype" name="sipwrappertype">9.76&nbsp;&nbsp;&nbsp;sipWrapperType</a></h2>
<p>This is a C structure that represents a SIP generated type object.  It is an
extension of the <tt class="docutils literal"><span class="pre">PyTypeObject</span></tt> structure (which is itself an extension of
the <tt class="docutils literal"><span class="pre">PyObject</span></tt> structure) and so may be safely cast to <tt class="docutils literal"><span class="pre">PyTypeObject</span></tt> (and
<tt class="docutils literal"><span class="pre">PyObject</span></tt>).</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id254" id="sipwrappertype-type" name="sipwrappertype-type">9.77&nbsp;&nbsp;&nbsp;sipWrapperType_Type</a></h2>
<p>This is a pointer to a <tt class="docutils literal"><span class="pre">PyTypeObject</span></tt> structure that is the type of a
<a class="reference" href="#sipwrappertype">sipWrapperType</a> structure and is the C implementation of <tt class="docutils literal"><span class="pre">sip.wrappertype</span></tt>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id255" id="generated-type-structures" name="generated-type-structures">9.78&nbsp;&nbsp;&nbsp;Generated Type Structures</a></h2>
<p>SIP generates an opaque type structure for each C structure, C++ class, C++
namespace, named enum or mapped type being wrapped.  These are <tt class="docutils literal"><span class="pre">sipTypeDef</span></tt>
structures and are used extensively by the SIP API.</p>
<p>The names of these structure are prefixed by <tt class="docutils literal"><span class="pre">sipType_</span></tt>.</p>
<p>For those structures that correspond to C structures, C++ classes, C++
namespaces or named enums the remaining part of the name is the fully
qualified name of the structure, class, namespace or enum name.  Any <tt class="docutils literal"><span class="pre">::</span></tt>
scope separators are replaced by an underscore.  For example, the type object
for class <tt class="docutils literal"><span class="pre">Klass</span></tt> is <tt class="docutils literal"><span class="pre">sipType_Klass</span></tt>.</p>
<p>For those structure that correspond to mapped types the remaining part of the
name is generated by SIP.  The only way for handwritten code to obtain a
pointer to a structure for a mapped type is to use <a class="reference" href="#sipfindtype">sipFindType()</a>.</p>
<p>The type structures of all imported types are available to handwritten code.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id256" id="generated-type-objects" name="generated-type-objects">9.79&nbsp;&nbsp;&nbsp;Generated Type Objects</a></h2>
<p>SIP generates a <a class="reference" href="#sipwrappertype">sipWrapperType</a> type object for each C structure or C++ class
being wrapped.</p>
<p>These objects are named with the structure or class name prefixed by
<tt class="docutils literal"><span class="pre">sipClass_</span></tt>.  For example, the type object for class <tt class="docutils literal"><span class="pre">Klass</span></tt> is
<tt class="docutils literal"><span class="pre">sipClass_Klass</span></tt>.</p>
<p>Using these names is deprecated from SIP v4.8.  Instead use the corresponding
generated type structure (see <a class="reference" href="#generated-type-structures">Generated Type Structures</a>) and
<a class="reference" href="#siptypeaspytypeobject">sipTypeAsPyTypeObject()</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id257" id="generated-named-enum-type-objects" name="generated-named-enum-type-objects">9.80&nbsp;&nbsp;&nbsp;Generated Named Enum Type Objects</a></h2>
<p>SIP generates a type object for each named enum being wrapped.  These are
PyTypeObject structures.  (Anonymous enums are wrapped as Python integers.)</p>
<p>These objects are named with the fully qualified enum name (i.e. including any
enclosing scope) prefixed by <tt class="docutils literal"><span class="pre">sipEnum_</span></tt>.  For example, the type object for
enum <tt class="docutils literal"><span class="pre">Enum</span></tt> defined in class <tt class="docutils literal"><span class="pre">Klass</span></tt> is <tt class="docutils literal"><span class="pre">sipEnum_Klass_Enum</span></tt>.</p>
<p>Using these names is deprecated from SIP v4.8.  Instead use the corresponding
generated type structure (see <a class="reference" href="#generated-type-structures">Generated Type Structures</a>) and
<a class="reference" href="#siptypeaspytypeobject">sipTypeAsPyTypeObject()</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id258" id="generated-derived-classes" name="generated-derived-classes">9.81&nbsp;&nbsp;&nbsp;Generated Derived Classes</a></h2>
<p>For most C++ classes being wrapped SIP generates a derived class with the same
name prefixed by <tt class="docutils literal"><span class="pre">sip</span></tt>.  For example, the derived class for class <tt class="docutils literal"><span class="pre">Klass</span></tt>
is <tt class="docutils literal"><span class="pre">sipKlass</span></tt>.</p>
<p>If a C++ class doesn't have any virtual or protected methods in it or any of
it's super-class hierarchy, or does not emit any Qt signals, then a derived
class is not generated.</p>
<p>Most of the time handwritten code should ignore the derived classes.  The only
exception is that handwritten constructor code specified using the
<a class="reference" href="#methodcode">%MethodCode</a> directive should call the derived class's constructor (which
has the same C++ signature) rather then the wrapped class's constructor.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id259" id="generated-exception-objects" name="generated-exception-objects">9.82&nbsp;&nbsp;&nbsp;Generated Exception Objects</a></h2>
<p>SIP generates a Python object for each exception defined with the <cite>%Exception_</cite>
directive.</p>
<p>These objects are named with the fully qualified exception name (i.e. including
any enclosing scope) prefixed by <tt class="docutils literal"><span class="pre">sipException_</span></tt>.  For example, the type
object for enum <tt class="docutils literal"><span class="pre">Except</span></tt> defined in class <tt class="docutils literal"><span class="pre">Klass</span></tt> is
<tt class="docutils literal"><span class="pre">sipException_Klass_Except</span></tt>.</p>
<p>The objects of all imported exceptions are available to handwritten code.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id260" id="using-the-sip-api-when-embedding" name="using-the-sip-api-when-embedding">10&nbsp;&nbsp;&nbsp;Using the SIP API when Embedding</a></h1>
<p>The SIP API described in the previous section is intended to be called from
handwritten code in SIP generated modules.  However it is also often necessary
to call it from C or C++ applications that embed the Python interpreter and
need to pass C or C++ instances between the application and the interpreter.</p>
<p>The API is exported by the SIP module as a <tt class="docutils literal"><span class="pre">sipAPIDef</span></tt> data structure
containing a set of function pointers.  The data structure is defined in the
SIP header file <tt class="docutils literal"><span class="pre">sip.h</span></tt>.  The data structure is wrapped as a Python
<tt class="docutils literal"><span class="pre">PyCObject</span></tt> object and is referenced by the name <tt class="docutils literal"><span class="pre">_C_API</span></tt> in the SIP
module dictionary.</p>
<p>Each member of the data structure is a pointer to one of the functions of the
SIP API.  The name of the member can be derived from the function name by
replacing the <tt class="docutils literal"><span class="pre">sip</span></tt> prefix with <tt class="docutils literal"><span class="pre">api</span></tt> and converting each word in the
name to lower case and preceding it with an underscore.  For example:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">sipExportSymbol</span></tt> becomes <tt class="docutils literal"><span class="pre">api_export_symbol</span></tt></p>
<p><tt class="docutils literal"><span class="pre">sipWrapperCheck</span></tt> becomes <tt class="docutils literal"><span class="pre">api_wrapper_check</span></tt></p>
</blockquote>
<p>Note that the type objects that SIP generates for a wrapped module (see
<a class="reference" href="#generated-type-structures">Generated Type Structures</a>, <a class="reference" href="#generated-named-enum-type-objects">Generated Named Enum Type Objects</a> and
<a class="reference" href="#generated-exception-objects">Generated Exception Objects</a>) cannot be refered to directly and must be
obtained using the <a class="reference" href="#sipfindtype">sipFindType()</a> function.  Of course, the corresponding
modules must already have been imported into the interpreter.</p>
<p>The following code fragment shows how to get a pointer to the <tt class="docutils literal"><span class="pre">sipAPIDef</span></tt>
data structure:</p>
<pre class="literal-block">
#include &lt;sip.h&gt;

const sipAPIDef *get_sip_api()
{
    PyObject *sip_module;
    PyObject *sip_module_dict;
    PyObject *c_api;

    /* Import the SIP module. */
    sip_module = PyImport_ImportModule(&quot;sip&quot;);

    if (sip_module == NULL)
        return NULL;

    /* Get the module's dictionary. */
    sip_module_dict = PyModule_GetDict(sip_module);

    /* Get the &quot;_C_API&quot; attribute. */
    c_api = PyDict_GetItemString(sip_module_dict, &quot;_C_API&quot;);

    if (c_api == NULL)
        return NULL;

    /* Sanity check that it is the right type. */
    if (!PyCObject_Check(c_api))
        return NULL;

    /* Get the actual pointer from the object. */
    return (const sipAPIDef *)PyCObject_AsVoidPtr(c_api);
}
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id261" id="using-the-sip-module-in-applications" name="using-the-sip-module-in-applications">11&nbsp;&nbsp;&nbsp;Using the SIP Module in Applications</a></h1>
<p>The main purpose of the SIP module is to provide functionality common to all
SIP generated bindings.  It is loaded automatically and most of the time you
will completely ignore it.  However, it does expose some functionality that can
be used by applications.</p>
<dl class="docutils">
<dt>cast(obj, type)</dt>
<dd>This does the Python equivalent of casting a C++ instance to one of its
sub or super-class types.  <em>obj</em> is the Python object and <em>type</em> is the
type.  A new Python object is returned that wraps the same C++ instance as
<em>obj</em>, but has the type <em>type</em>.</dd>
<dt>delete(obj)</dt>
<dd>For C++ instances this calls the C++ destructor.  For C structures it
returns the structure's memory to the heap.  <em>obj</em> is the Python object.</dd>
<dt>dump(obj)</dt>
<dd>This writes various bits of useful information about the internal state of
the Python object that wraps a C++ instance or C structure.</dd>
<dt>isdeleted(obj)</dt>
<dd>This returns True if the C++ instance or C structure has been destroyed or
returned to the heap.  <em>obj</em> is the Python object.</dd>
<dt>setdeleted(obj)</dt>
<dd>This marks the C++ instance or C structure as having been destroyed or
returned to the heap so that future references to it raise an exception
rather than cause a program crash.  Normally SIP handles such things
automatically, but there are circumstances where this isn't possible.
<em>obj</em> is the Python object.</dd>
<dt>settracemask(mask)</dt>
<dd><p class="first">If the bindings have been created with SIP's <tt class="docutils literal"><span class="pre">-r</span></tt> command line option
then the generated code will produce debugging statements that trace the
execution of the code.  (It is particularly useful when trying to
understand the operation of a C++ library's virtual function calls.)</p>
<p>Debugging statements are generated at the following points:</p>
<ul class="simple">
<li>in a C++ virtual function (<em>mask</em> is <tt class="docutils literal"><span class="pre">0x0001</span></tt>)</li>
<li>in a C++ constructor (<em>mask</em> is <tt class="docutils literal"><span class="pre">0x0002</span></tt>)</li>
<li>in a C++ destructor (<em>mask</em> is <tt class="docutils literal"><span class="pre">0x0004</span></tt>)</li>
<li>in a Python type's __init__ method (<em>mask</em> is <tt class="docutils literal"><span class="pre">0x0008</span></tt>)</li>
<li>in a Python type's __del__ method (<em>mask</em> is <tt class="docutils literal"><span class="pre">0x0010</span></tt>)</li>
<li>in a Python type's ordinary method (<em>mask</em> is <tt class="docutils literal"><span class="pre">0x0020</span></tt>).</li>
</ul>
<p class="last">By default the trace mask is zero and all debugging statements are
disabled.</p>
</dd>
<dt>SIP_VERSION</dt>
<dd>This is a Python integer object that represents the SIP version number as
a 3 part hexadecimal number (e.g. v4.0.0 is represented as <tt class="docutils literal"><span class="pre">0x040000</span></tt>).
It was first implemented in SIP v4.2.</dd>
<dt>SIP_VERSION_STR</dt>
<dd>This is a Python string object that defines the SIP version number as
represented as a string.  For development snapshots it will start with
<tt class="docutils literal"><span class="pre">snapshot-</span></tt>.  It was first implemented in SIP v4.3.</dd>
<dt>transferback(obj)</dt>
<dd>This function is a wrapper around <a class="reference" href="#siptransferback">sipTransferBack()</a>.</dd>
<dt>transferto(obj, owner)</dt>
<dd>This function is a wrapper around <a class="reference" href="#siptransferto">sipTransferTo()</a>.</dd>
<dt>unwrapinstance(obj)</dt>
<dd>Return the address, as a number, of the wrapped C/C++ structure or class
instance <em>obj</em>.</dd>
<dt>voidptr</dt>
<dd><p class="first">This is the type object for the type SIP uses to represent a C/C++
<tt class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt>.  It may have a size associated with the address in which case
the Python buffer protocol is supported.  This means that the memory can
be treated as a mutable array of bytes when wrapped with the <tt class="docutils literal"><span class="pre">buffer()</span></tt>
builtin.  The type has the following methods:</p>
<dl class="last docutils">
<dt>__init__(self, address, size=-1, writeable=True)</dt>
<dd><tt class="docutils literal"><span class="pre">address</span></tt> is either another <tt class="docutils literal"><span class="pre">voidptr</span></tt>, <tt class="docutils literal"><span class="pre">None</span></tt>, a Python CObject,
or an integer.  <tt class="docutils literal"><span class="pre">size</span></tt> is the optional associated size of the block
of memory and is negative if the size is not known.  <tt class="docutils literal"><span class="pre">writeable</span></tt> is
set if the memory is writeable.  If it is not specified, and
<tt class="docutils literal"><span class="pre">address</span></tt> is a <tt class="docutils literal"><span class="pre">voidptr</span></tt> then its value will be used.</dd>
<dt>__int__(self)</dt>
<dd>This returns the address as an integer.</dd>
<dt>__hex__(self)</dt>
<dd>This returns the address as a hexadecimal string.</dd>
<dt>ascobject(self)</dt>
<dd>This returns the address as a Python CObject.</dd>
<dt>asstring(self, size=-1)</dt>
<dd>This returns a copy of the block of memory as a Python v2 string object
or a Python v3 bytes object.  If <tt class="docutils literal"><span class="pre">size</span></tt> is given then it specifies
the number of bytes to copy.  If it is not given (or is negative) then
the size associated with the address is used.  If there is no
associated size then an exception is raised.</dd>
<dt>getsize(self)</dt>
<dd>This returns the size associated with the address.  It will be
negative if there is no associated size.</dd>
<dt>setsize(self, size)</dt>
<dd>This sets the size associated with the address.  If <tt class="docutils literal"><span class="pre">size</span></tt> is
negative then no size is associated.</dd>
<dt>getwriteable(self)</dt>
<dd>This returns the writeable state of the memory.</dd>
<dt>setwriteable(self, writeable)</dt>
<dd>writeable state of the memory.</dd>
</dl>
</dd>
<dt>wrapinstance(addr, type)</dt>
<dd>A C/C++ structure or class instance is wrapped and the Python object
created is returned.  If the instance has already been wrapped then a new
reference to the existing object is returned.  <em>addr</em> is the address of
the instance represented as a number.  <em>type</em> is the type of the object
(e.g. <tt class="docutils literal"><span class="pre">qt.QWidget</span></tt>).</dd>
<dt>wrapper</dt>
<dd>This is the type object of the base type of all instances wrapped by SIP.</dd>
<dt>wrappertype</dt>
<dd>This is the type object of the metatype of the <tt class="docutils literal"><span class="pre">wrapper</span></tt> type.</dd>
</dl>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id262" id="the-sip-build-system" name="the-sip-build-system">12&nbsp;&nbsp;&nbsp;The SIP Build System</a></h1>
<p>The purpose of the build system is to make it easy for you to write
configuration scripts in Python for your own bindings.  The build system takes
care of the details of particular combinations of platform and compiler.  It
supports over 50 different platform/compiler combinations.</p>
<p>The build system is implemented as a pure Python module called <tt class="docutils literal"><span class="pre">sipconfig</span></tt>
that contains a number of classes and functions.  Using this module you can
write bespoke configuration scripts (e.g. PyQt's <tt class="docutils literal"><span class="pre">configure.py</span></tt>) or use it
with other Python based build systems (e.g.
<a class="reference" href="http://www.python.org/sigs/distutils-sig/distutils.html">Distutils</a> and
<a class="reference" href="http://www.scons.org">SCons</a>).</p>
<p>An important feature of SIP is the ability to generate bindings that are built
on top of existing bindings.  For example, both
<a class="reference" href="http://www.riverbankcomputing.com/software/pykde/">PyKDE</a> and
<a class="reference" href="http://pyqwt.sourceforge.net/">PyQwt</a> are built on top of PyQt but all three
packages are maintained by different developers.  To make this easier PyQt
includes its own configuration module, <tt class="docutils literal"><span class="pre">pyqtconfig</span></tt>, that contains additional
classes intended to be used by the configuration scripts of bindings built on
top of PyQt.  The SIP build system includes facilities that do a lot of the
work of creating these additional configuration modules.</p>
<div class="section">
<h2><a class="toc-backref" href="#id263" id="sipconfig-functions" name="sipconfig-functions">12.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">sipconfig</span></tt> Functions</a></h2>
<dl class="docutils">
<dt>create_config_module(module, template, content, macros=None)</dt>
<dd><p class="first">This creates a configuration module (e.g. <tt class="docutils literal"><span class="pre">pyqtconfig</span></tt>) from a template
file and a string.</p>
<p><tt class="docutils literal"><span class="pre">module</span></tt> is the name of the configuration module file to create.</p>
<p><tt class="docutils literal"><span class="pre">template</span></tt> is the name of the template file.</p>
<p><tt class="docutils literal"><span class="pre">content</span></tt> is a string which replaces every occurence of the pattern
<tt class="docutils literal"><span class="pre">&#64;SIP_CONFIGURATION&#64;</span></tt> in the template file.  The content string is
usually created from a Python dictionary using
<tt class="docutils literal"><span class="pre">sipconfig.create_content()</span></tt>.  <tt class="docutils literal"><span class="pre">content</span></tt> may also be a dictionary, in
which case <tt class="docutils literal"><span class="pre">sipconfig.create_content()</span></tt> is automatically called to
convert it to a string.</p>
<p class="last"><tt class="docutils literal"><span class="pre">macros</span></tt> is an optional dictionary of platform specific build macros.  It
is only used if <tt class="docutils literal"><span class="pre">sipconfig.create_content()</span></tt> is called automatically to
convert a <tt class="docutils literal"><span class="pre">content</span></tt> dictionary to a string.</p>
</dd>
<dt>create_content(dict, macros=None)</dt>
<dd><p class="first">This converts a Python dictionary to a string that can be parsed by the
Python interpreter and converted back to an equivalent dictionary.  It is
typically used to generate the content string for
<tt class="docutils literal"><span class="pre">sipconfig.create_config_module()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">dict</span></tt> is the Python dictionary to convert.</p>
<p><tt class="docutils literal"><span class="pre">macros</span></tt> is the optional dictionary of platform specific build macros.</p>
<p class="last">Returns the dictionary as a string.</p>
</dd>
<dt>create_wrapper(script, wrapper, gui=0)</dt>
<dd><p class="first">This creates a platform dependent executable wrapper around a Python
script.</p>
<p><tt class="docutils literal"><span class="pre">script</span></tt> is the full pathname of the script.</p>
<p><tt class="docutils literal"><span class="pre">wrapper</span></tt> is the pathname of the wrapper to create.</p>
<p><tt class="docutils literal"><span class="pre">gui</span></tt> is non-zero if a GUI enabled version of the interpreter should be
used on platforms that require it.</p>
<p class="last">Returns the platform specific name of the wrapper.</p>
</dd>
<dt>error(msg)</dt>
<dd><p class="first">This displays an error message on <tt class="docutils literal"><span class="pre">stderr</span></tt> and calls <tt class="docutils literal"><span class="pre">sys.exit()</span></tt> with
a value of 1.</p>
<p class="last"><tt class="docutils literal"><span class="pre">msg</span></tt> is the text of the message and should not include any newline
characters.</p>
</dd>
<dt>format(msg, leftmargin=0, rightmargin=78)</dt>
<dd><p class="first">This formats a message by inserting newline characters at appropriate
places.</p>
<p><tt class="docutils literal"><span class="pre">msg</span></tt> is the text of the message and should not include any newline
characters.</p>
<p><tt class="docutils literal"><span class="pre">leftmargin</span></tt> is the optional position of the left margin.</p>
<p class="last"><tt class="docutils literal"><span class="pre">rightmargin</span></tt> is the optional position of the right margin.</p>
</dd>
<dt>inform(msg)</dt>
<dd><p class="first">This displays an information message on <tt class="docutils literal"><span class="pre">stdout</span></tt>.</p>
<p class="last"><tt class="docutils literal"><span class="pre">msg</span></tt> is the text of the message and should not include any newline
characters.</p>
</dd>
<dt>parse_build_macros(filename, names, overrides=None, properties=None)</dt>
<dd><p class="first">This parses a qmake compatible file of build system macros and converts it
to a dictionary.  A macro is a name/value pair.  The dictionary is returned
or None if any of the overrides was invalid.</p>
<p><tt class="docutils literal"><span class="pre">filename</span></tt> is the name of the file to parse.</p>
<p><tt class="docutils literal"><span class="pre">names</span></tt> is a list of the macro names to extract from the file.</p>
<p><tt class="docutils literal"><span class="pre">overrides</span></tt> is an optional list of macro names and values that modify
those found in the file.  They are of the form <em>name=value</em> (in which case
the value replaces the value found in the file) or <em>name+=value</em> (in which
case the value is appended to the value found in the file).</p>
<p class="last"><tt class="docutils literal"><span class="pre">properties</span></tt> is an optional dictionary of property name and values that
are used to resolve any expressions of the form <tt class="docutils literal"><span class="pre">$[name]</span></tt> in the file.</p>
</dd>
<dt>read_version(filename, description, numdefine=None, strdefine=None)</dt>
<dd><p class="first">This extracts version information for a package from a file, usually a C or
C++ header file.  The version information must each be specified as a
<tt class="docutils literal"><span class="pre">#define</span></tt> of a numeric (hexadecimal or decimal) value and/or a string
value.</p>
<p><tt class="docutils literal"><span class="pre">filename</span></tt> is the name of the file to read.</p>
<p><tt class="docutils literal"><span class="pre">description</span></tt> is a descriptive name of the package used in error
messages.</p>
<p><tt class="docutils literal"><span class="pre">numdefine</span></tt> is the optional name of the <tt class="docutils literal"><span class="pre">#define</span></tt> of the version as a
number.  If it is <tt class="docutils literal"><span class="pre">None</span></tt> then the numeric version is ignored.</p>
<p><tt class="docutils literal"><span class="pre">strdefine</span></tt> is the optional name of the <tt class="docutils literal"><span class="pre">#define</span></tt> of the version as a
string.  If it is <tt class="docutils literal"><span class="pre">None</span></tt> then the string version is ignored.</p>
<p class="last">Returns a tuple of the numeric and string versions.  <tt class="docutils literal"><span class="pre">sipconfig.error()</span></tt>
is called if either were required but could not be found.</p>
</dd>
<dt>version_to_sip_tag(version, tags, description)</dt>
<dd><p class="first">This converts a version number to a SIP version tag.  SIP uses the
<a class="reference" href="#timeline">%Timeline</a> directive to define the chronology of the different versions
of the C/C++ library being wrapped.  Typically it is not necessary to
define a version tag for every version of the library, but only for those
versions that affect the library's API as SIP sees it.</p>
<p><tt class="docutils literal"><span class="pre">version</span></tt> is the numeric version number of the C/C++ library being
wrapped.  If it is negative then the latest version is assumed.  (This is
typically useful if a snapshot is indicated by a negative version number.)</p>
<p><tt class="docutils literal"><span class="pre">tags</span></tt> is the dictionary of SIP version tags keyed by the corresponding
C/C++ library version number.  The tag used is the one with the smallest
key (i.e. earliest version) that is greater than <tt class="docutils literal"><span class="pre">version</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">description</span></tt> is a descriptive name of the C/C++ library used in error
messages.</p>
<p class="last">Returns the SIP version tag.  <tt class="docutils literal"><span class="pre">sipconfig.error()</span></tt> is called if the C/C++
library version number did not correspond to a SIP version tag.</p>
</dd>
<dt>version_to_string(v)</dt>
<dd><p class="first">This converts a 3 part version number encoded as a hexadecimal value to a
string.</p>
<p><tt class="docutils literal"><span class="pre">v</span></tt> is the version number.</p>
<p class="last">Returns a string.</p>
</dd>
</dl>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id264" id="sipconfig-classes" name="sipconfig-classes">12.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">sipconfig</span></tt> Classes</a></h2>
<dl class="docutils">
<dt>Configuration</dt>
<dd><p class="first">This class encapsulates configuration values that can be accessed as
instance objects.  A sub-class may provide a dictionary of additional
configuration values in its constructor the elements of which will have
precedence over the super-class's values.</p>
<p>The following configuration values are provided:</p>
<blockquote>
<dl class="docutils">
<dt>default_bin_dir</dt>
<dd>The name of the directory where executables should be installed by
default.</dd>
<dt>default_mod_dir</dt>
<dd>The name of the directory where SIP generated modules should be
installed by default.</dd>
<dt>default_sip_dir</dt>
<dd>The name of the base directory where the <tt class="docutils literal"><span class="pre">.sip</span></tt> files for SIP
generated modules should be installed by default.  A sub-directory
with the same name as the module should be created and its <tt class="docutils literal"><span class="pre">.sip</span></tt>
files should be installed in the sub-directory.  The <tt class="docutils literal"><span class="pre">.sip</span></tt>
files only need to be installed if you might want to build other
bindings based on them.</dd>
<dt>platform</dt>
<dd>The name of the platform/compiler for which the build system has
been configured for.</dd>
<dt>py_conf_inc_dir</dt>
<dd>The name of the directory containing the <tt class="docutils literal"><span class="pre">pyconfig.h</span></tt> header
file.</dd>
<dt>py_inc_dir</dt>
<dd>The name of the directory containing the <tt class="docutils literal"><span class="pre">Python.h</span></tt> header file.</dd>
<dt>py_lib_dir</dt>
<dd>The name of the directory containing the Python interpreter
library.</dd>
<dt>py_version</dt>
<dd>The Python version as a 3 part hexadecimal number (e.g. v2.3.3 is
represented as <tt class="docutils literal"><span class="pre">0x020303</span></tt>).</dd>
<dt>sip_bin</dt>
<dd>The full pathname of the SIP executable.</dd>
<dt>sip_config_args</dt>
<dd>The command line passed to <tt class="docutils literal"><span class="pre">configure.py</span></tt> when SIP was
configured.</dd>
<dt>sip_inc_dir</dt>
<dd>The name of the directory containing the <tt class="docutils literal"><span class="pre">sip.h</span></tt> header file.</dd>
<dt>sip_mod_dir</dt>
<dd>The name of the directory containing the SIP module.</dd>
<dt>sip_version</dt>
<dd>The SIP version as a 3 part hexadecimal number (e.g. v4.0.0 is
represented as <tt class="docutils literal"><span class="pre">0x040000</span></tt>).</dd>
<dt>sip_version_str</dt>
<dd>The SIP version as a string.  For development snapshots it will
start with <tt class="docutils literal"><span class="pre">snapshot-</span></tt>.</dd>
<dt>universal</dt>
<dd>The name of the MacOS/X SDK used when creating universal binaries.</dd>
</dl>
</blockquote>
<dl class="last docutils">
<dt>__init__(self, sub_cfg=None)</dt>
<dd><p class="first">Initialise the instance.</p>
<p class="last"><tt class="docutils literal"><span class="pre">sub_cfg</span></tt> is an optional list of sub-class configurations.  It should
only be used by the <tt class="docutils literal"><span class="pre">__init__()</span></tt> method of a sub-class to append its
own dictionary of configuration values before passing the list to its
super-class.</p>
</dd>
<dt>build_macros(self)</dt>
<dd>Return the dictionary of platform specific build macros.</dd>
<dt>set_build_macros(self, macros)</dt>
<dd>Set the dictionary of platform specific build macros to be use when
generating Makefiles.  Normally there is no need to change the default
macros.</dd>
</dl>
</dd>
<dt>Makefile</dt>
<dd><p class="first">This class encapsulates a Makefile.  It is intended to be sub-classed to
generate Makefiles for particular purposes.  It handles all platform and
compiler specific flags, but allows them to be adjusted to suit the
requirements of a particular module or program.  These are defined using a
number of macros which can be accessed as instance objects.</p>
<p>The following instance objects are provided to help in fine tuning the
generated Makefile:</p>
<blockquote>
<dl class="docutils">
<dt>chkdir</dt>
<dd>A string that will check for the existence of a directory.</dd>
<dt>config</dt>
<dd>A reference to the <tt class="docutils literal"><span class="pre">configuration</span></tt> argument that was passed to
the constructor.</dd>
<dt>console</dt>
<dd>A reference to the <tt class="docutils literal"><span class="pre">console</span></tt> argument that was passed to the
constructor.</dd>
<dt>copy</dt>
<dd>A string that will copy a file.</dd>
<dt>extra_cflags</dt>
<dd>A list of additional flags passed to the C compiler.</dd>
<dt>extra_cxxflags</dt>
<dd>A list of additional flags passed to the C++ compiler.</dd>
<dt>extra_defines</dt>
<dd>A list of additional macro names passed to the C/C++ preprocessor.</dd>
<dt>extra_include_dirs</dt>
<dd>A list of additional include directories passed to the C/C++
preprocessor.</dd>
<dt>extra_lflags</dt>
<dd>A list of additional flags passed to the linker.</dd>
<dt>extra_lib_dirs</dt>
<dd>A list of additional library directories passed to the linker.</dd>
<dt>extra_libs</dt>
<dd>A list of additional libraries passed to the linker.  The names of
the libraries must be in platform neutral form (i.e. without any
platform specific prefixes, version numbers or extensions).</dd>
<dt>generator</dt>
<dd>A string that defines the platform specific style of Makefile.  The
only supported values are <tt class="docutils literal"><span class="pre">UNIX</span></tt> and something else that is not
<tt class="docutils literal"><span class="pre">UNIX</span></tt>.</dd>
<dt>mkdir</dt>
<dd>A string that will create a directory.</dd>
<dt>rm</dt>
<dd>A string that will remove a file.</dd>
</dl>
</blockquote>
<dl class="last docutils">
<dt>__init__(self, configuration, console=0, qt=0, opengl=0, python=0, threaded=0, warnings=None, debug=0, dir=None, makefile=&quot;Makefile&quot;, installs=None, universal='')</dt>
<dd><p class="first">Initialise the instance.</p>
<p><tt class="docutils literal"><span class="pre">configuration</span></tt> is the current configuration and is an instance of
the <tt class="docutils literal"><span class="pre">Configuration</span></tt> class or a sub-class.</p>
<p><tt class="docutils literal"><span class="pre">console</span></tt> is set if the target is a console (rather than GUI) target.
This only affects Windows and is ignored on other platforms.</p>
<p><tt class="docutils literal"><span class="pre">qt</span></tt> is set if the target uses Qt.  For Qt v4 a list of Qt libraries
may be specified and a simple non-zero value implies QtCore and QtGui.</p>
<p><tt class="docutils literal"><span class="pre">opengl</span></tt> is set if the target uses OpenGL.</p>
<p><tt class="docutils literal"><span class="pre">python</span></tt> is set if the target uses Python.h.</p>
<p><tt class="docutils literal"><span class="pre">threaded</span></tt> is set if the target requires thread support.  It is set
automatically if the target uses Qt and Qt has thread support enabled.</p>
<p><tt class="docutils literal"><span class="pre">warnings</span></tt> is set if compiler warning messages should be enabled.
The default of <tt class="docutils literal"><span class="pre">None</span></tt> means that warnings are enabled for SIP v4.x
and disabled for SIP v3.x.</p>
<p><tt class="docutils literal"><span class="pre">debug</span></tt> is set if debugging symbols should be generated.</p>
<p><tt class="docutils literal"><span class="pre">dir</span></tt> is the name of the directory where build files are read from
and Makefiles are written to.  The default of <tt class="docutils literal"><span class="pre">None</span></tt> means the
current directory is used.</p>
<p><tt class="docutils literal"><span class="pre">makefile</span></tt> is the name of the generated Makefile.</p>
<p><tt class="docutils literal"><span class="pre">installs</span></tt> is a list of extra install targets.  Each element is a two
part list, the first of which is the source and the second is the
destination.  If the source is another list then it is a list of source
files and the destination is a directory.</p>
<p class="last"><tt class="docutils literal"><span class="pre">universal</span></tt> is the name of the SDK if universal binaries are to be
created under MacOS/X.</p>
</dd>
<dt>clean_build_file_objects(self, mfile, build)</dt>
<dd><p class="first">This generates the Makefile commands that will remove any files
generated during the build of the default target.</p>
<p><tt class="docutils literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
<p class="last"><tt class="docutils literal"><span class="pre">build</span></tt> is the dictionary created from parsing the build file.</p>
</dd>
<dt>finalise(self)</dt>
<dd>This is called just before the Makefile is generated to ensure that it
is fully configured.  It must be reimplemented by a sub-class.</dd>
<dt>generate(self)</dt>
<dd>This generates the Makefile.</dd>
<dt>generate_macros_and_rules(self, mfile)</dt>
<dd><p class="first">This is the default implementation of the Makefile macros and rules
generation.</p>
<p class="last"><tt class="docutils literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
</dd>
<dt>generate_target_clean(self, mfile)</dt>
<dd><p class="first">This is the default implementation of the Makefile clean target
generation.</p>
<p class="last"><tt class="docutils literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
</dd>
<dt>generate_target_default(self, mfile)</dt>
<dd><p class="first">This is the default implementation of the Makefile default target
generation.</p>
<p class="last"><tt class="docutils literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
</dd>
<dt>generate_target_install(self, mfile)</dt>
<dd><p class="first">This is the default implementation of the Makefile install target
generation.</p>
<p class="last"><tt class="docutils literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
</dd>
<dt>install_file(self, mfile, src, dst, strip=0)</dt>
<dd><p class="first">This generates the Makefile commands to install one or more files to a
directory.</p>
<p><tt class="docutils literal"><span class="pre">mfile</span></tt> is the Python file object of the Makefile.</p>
<p><tt class="docutils literal"><span class="pre">src</span></tt> is the name of a single file to install or a list of a number
of files to install.</p>
<p><tt class="docutils literal"><span class="pre">dst</span></tt> is the name of the destination directory.</p>
<p class="last"><tt class="docutils literal"><span class="pre">strip</span></tt> is set if the files should be stripped of unneeded symbols
after having been installed.</p>
</dd>
<dt>optional_list(self, name)</dt>
<dd><p class="first">This returns an optional Makefile macro as a list.</p>
<p><tt class="docutils literal"><span class="pre">name</span></tt> is the name of the macro.</p>
<p class="last">Returns the macro as a list.</p>
</dd>
<dt>optional_string(self, name, default=&quot;&quot;)</dt>
<dd><p class="first">This returns an optional Makefile macro as a string.</p>
<p><tt class="docutils literal"><span class="pre">name</span></tt> is the name of the macro.</p>
<p><tt class="docutils literal"><span class="pre">default</span></tt> is the optional default value of the macro.</p>
<p class="last">Returns the macro as a string.</p>
</dd>
<dt>parse_build_file(self, filename)</dt>
<dd><p class="first">This parses a build file (created with the <tt class="docutils literal"><span class="pre">-b</span></tt> SIP command line
option) and converts it to a dictionary.  It can also validate an
existing dictionary created through other means.</p>
<p><tt class="docutils literal"><span class="pre">filename</span></tt> is the name of the build file, or is a dictionary to be
validated.  A valid dictionary will contain the name of the target to
build (excluding any platform specific extension) keyed by <tt class="docutils literal"><span class="pre">target</span></tt>;
the names of all source files keyed by <tt class="docutils literal"><span class="pre">sources</span></tt>; and, optionally,
the names of all header files keyed by <tt class="docutils literal"><span class="pre">headers</span></tt>.</p>
<p class="last">Returns a dictionary corresponding to the parsed build file.</p>
</dd>
<dt>platform_lib(self, clib, framework=0)</dt>
<dd><p class="first">This converts a library name to a platform specific form.</p>
<p><tt class="docutils literal"><span class="pre">clib</span></tt> is the name of the library in cannonical form.</p>
<p><tt class="docutils literal"><span class="pre">framework</span></tt> is set if the library is implemented as a MacOS
framework.</p>
<p class="last">Return the platform specific name.</p>
</dd>
<dt>ready(self)</dt>
<dd>This is called to ensure that the Makefile is fully configured.  It is
normally called automatically when needed.</dd>
<dt>required_string(self, name)</dt>
<dd><p class="first">This returns a required Makefile macro as a string.</p>
<p><tt class="docutils literal"><span class="pre">name</span></tt> is the name of the macro.</p>
<p class="last">Returns the macro as a string.  An exception is raised if the macro
does not exist or has an empty value.</p>
</dd>
</dl>
</dd>
<dt>ModuleMakefile(Makefile)</dt>
<dd><p class="first">This class encapsulates a Makefile to build a generic Python extension
module.</p>
<dl class="last docutils">
<dt>__init__(self, configuration, build_file, install_dir=None, static=0, console=0, opengl=0, threaded=0, warnings=None, debug=0, dir=None, makefile=&quot;Makefile&quot;, installs=None, strip=1, export_all=0, universal='')</dt>
<dd><p class="first">Initialise the instance.</p>
<p><tt class="docutils literal"><span class="pre">configuration</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">build_file</span></tt> is the name of the build file.  Build files are
generated using the <tt class="docutils literal"><span class="pre">-b</span></tt> SIP command line option.</p>
<p><tt class="docutils literal"><span class="pre">install_dir</span></tt> is the name of the directory where the module will be
optionally installed.</p>
<p><tt class="docutils literal"><span class="pre">static</span></tt> is set if the module should be built as a static library
(see <a class="reference" href="#builtin-modules-and-custom-interpreters">Builtin Modules and Custom Interpreters</a>).</p>
<p><tt class="docutils literal"><span class="pre">console</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">qt</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">opengl</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">threaded</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">warnings</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">debug</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">dir</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">makefile</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">installs</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">strip</span></tt> is set if the module should be stripped of unneeded symbols
after installation.  It is ignored if either <tt class="docutils literal"><span class="pre">debug</span></tt> or <tt class="docutils literal"><span class="pre">static</span></tt> is
set, or if the platform doesn't support it.</p>
<p class="last"><tt class="docutils literal"><span class="pre">export_all</span></tt> is set if all of the module's symbols should be exported
rather than just the module's initialisation function.  Exporting all
symbols increases the size of the module and slows down module load
times but may avoid problems with modules that use C++ exceptions.  All
symbols are exported if either <tt class="docutils literal"><span class="pre">debug</span></tt> or <tt class="docutils literal"><span class="pre">static</span></tt> is set, or if
the platform doesn't support it.</p>
</dd>
<dt>finalise(self)</dt>
<dd>This is a reimplementation of <tt class="docutils literal"><span class="pre">sipconfig.Makefile.finalise()</span></tt>.</dd>
<dt>generate_macros_and_rules(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_macros_and_rules()</span></tt>.</dd>
<dt>generate_target_clean(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_target_clean()</span></tt>.</dd>
<dt>generate_target_default(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_target_default()</span></tt>.</dd>
<dt>generate_target_install(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_target_install()</span></tt>.</dd>
<dt>module_as_lib(self, mname)</dt>
<dd><p class="first">This returns the name of a SIP v3.x module for when it is used as a
library to be linked against.  An exception will be raised if it is
used with SIP v4.x modules.</p>
<p><tt class="docutils literal"><span class="pre">mname</span></tt> is the name of the module.</p>
<p class="last">Returns the corresponding library name.</p>
</dd>
</dl>
</dd>
<dt>ParentMakefile(Makefile)</dt>
<dd><p class="first">This class encapsulates a Makefile that sits above a number of other
Makefiles in sub-directories.</p>
<dl class="last docutils">
<dt>__init__(self, configuration, subdirs, dir=None, makefile=&quot;Makefile&quot;, installs=None)</dt>
<dd><p class="first">Initialise the instance.</p>
<p><tt class="docutils literal"><span class="pre">configuration</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">subdirs</span></tt> is the sequence of sub-directories.</p>
<p><tt class="docutils literal"><span class="pre">dir</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">makefile</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p class="last"><tt class="docutils literal"><span class="pre">installs</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
</dd>
<dt>generate_macros_and_rules(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_macros_and_rules()</span></tt>.</dd>
<dt>generate_target_clean(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_target_clean()</span></tt>.</dd>
<dt>generate_target_default(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_target_default()</span></tt>.</dd>
<dt>generate_target_install(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_target_install()</span></tt>.</dd>
</dl>
</dd>
<dt>ProgramMakefile(Makefile)</dt>
<dd><p class="first">This class encapsulates a Makefile to build an executable program.</p>
<dl class="last docutils">
<dt>__init__(self, configuration, build_file=None, install_dir=None, console=0, qt=0, opengl=0, python=0, threaded=0, warnings=None, debug=0, dir=None, makefile=&quot;Makefile&quot;, installs=None, universal='')</dt>
<dd><p class="first">Initialise the instance.</p>
<p><tt class="docutils literal"><span class="pre">configuration</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">build_file</span></tt> is the name of the optional build file.  Build files are
generated using the <tt class="docutils literal"><span class="pre">-b</span></tt> SIP command line option.</p>
<p><tt class="docutils literal"><span class="pre">install_dir</span></tt> is the name of the directory where the executable
program will be optionally installed.</p>
<p><tt class="docutils literal"><span class="pre">console</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">qt</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">opengl</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">python</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">threaded</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">warnings</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">debug</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">dir</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">makefile</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p class="last"><tt class="docutils literal"><span class="pre">installs</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
</dd>
<dt>build_command(self, source)</dt>
<dd><p class="first">This creates a single command line that will create an executable
program from a single source file.</p>
<p><tt class="docutils literal"><span class="pre">source</span></tt> is the name of the source file.</p>
<p class="last">Returns a tuple of the name of the executable that will be created and
the command line.</p>
</dd>
<dt>finalise(self)</dt>
<dd>This is a reimplementation of <tt class="docutils literal"><span class="pre">sipconfig.Makefile.finalise()</span></tt>.</dd>
<dt>generate_macros_and_rules(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_macros_and_rules()</span></tt>.</dd>
<dt>generate_target_clean(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_target_clean()</span></tt>.</dd>
<dt>generate_target_default(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_target_default()</span></tt>.</dd>
<dt>generate_target_install(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_target_install()</span></tt>.</dd>
</dl>
</dd>
<dt>PythonModuleMakefile(Makefile)</dt>
<dd><p class="first">This class encapsulates a Makefile that installs a pure Python module.</p>
<dl class="last docutils">
<dt>__init__(self, configuration, dstdir, srcdir=None, dir=None, makefile=&quot;Makefile&quot;, installs=None)</dt>
<dd><p class="first">Initialise the instance.</p>
<p><tt class="docutils literal"><span class="pre">configuration</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">dstdir</span></tt> is the name of the directory in which the module's Python
code will be installed.</p>
<p><tt class="docutils literal"><span class="pre">srcdir</span></tt> is the name of the directory (relative to <tt class="docutils literal"><span class="pre">dir</span></tt>)
containing the module's Python code.  It defaults to the same
directory.</p>
<p><tt class="docutils literal"><span class="pre">dir</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">makefile</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
<p class="last"><tt class="docutils literal"><span class="pre">installs</span></tt> - see <tt class="docutils literal"><span class="pre">sipconfig.Makefile.__init__()</span></tt>.</p>
</dd>
<dt>generate_macros_and_rules(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_macros_and_rules()</span></tt>.</dd>
<dt>generate_target_install(self, mfile)</dt>
<dd>This is a reimplementation of
<tt class="docutils literal"><span class="pre">sipconfig.Makefile.generate_target_install()</span></tt>.</dd>
</dl>
</dd>
<dt>SIPModuleMakefile(ModuleMakefile)</dt>
<dd><p class="first">This class encapsulates a Makefile to build a SIP generated Python
extension module.</p>
<dl class="last docutils">
<dt>finalise(self)</dt>
<dd>This is a reimplementation of <tt class="docutils literal"><span class="pre">sipconfig.Makefile.finalise()</span></tt>.</dd>
</dl>
</dd>
</dl>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id265" id="building-your-extension-with-distutils" name="building-your-extension-with-distutils">13&nbsp;&nbsp;&nbsp;Building Your Extension with distutils</a></h1>
<p>To build the example in <a class="reference" href="#a-simple-c-example">A Simple C++ Example</a> using distutils, it is
sufficient to create a standard <tt class="docutils literal"><span class="pre">setup.py</span></tt>, listing <tt class="docutils literal"><span class="pre">word.sip</span></tt> among the
files to build, and hook-up SIP into distutils:</p>
<pre class="literal-block">
from distutils.core import setup, Extension
import sipdistutils

setup(
  name = 'word',
  versione = '1.0',
  ext_modules=[
    Extension(&quot;word&quot;, [&quot;word.sip&quot;, &quot;word.cpp&quot;]),
    ],

  cmdclass = {'build_ext': sipdistutils.build_ext}
)
</pre>
<p>As we can see, the above is a normal distutils setup script, with just a
special line which is needed so that SIP can see and process <tt class="docutils literal"><span class="pre">word.sip</span></tt>.
Then, running <tt class="docutils literal"><span class="pre">setup.py</span> <span class="pre">build</span></tt> will build our extension module.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id266" id="builtin-modules-and-custom-interpreters" name="builtin-modules-and-custom-interpreters">14&nbsp;&nbsp;&nbsp;Builtin Modules and Custom Interpreters</a></h1>
<p>Sometimes you want to create a custom Python interpreter with some modules
built in to the interpreter itself rather than being dynamically loaded.  To
do this the module must be created as a static library and linked with a
custom stub and the normal Python library.</p>
<p>To build the SIP module as a static library you must pass the <tt class="docutils literal"><span class="pre">-k</span></tt> command
line option to <tt class="docutils literal"><span class="pre">configure.py</span></tt>.  You should then build and install SIP as
normal.  (Note that, because the module is now a static library, you will not
be able to import it.)</p>
<p>To build a module you have created for your own library you must modify your
own configuration script to pass a non-zero value as the <tt class="docutils literal"><span class="pre">static</span></tt> argument
of the <tt class="docutils literal"><span class="pre">__init__()</span></tt> method of the <tt class="docutils literal"><span class="pre">ModuleMakefile</span></tt> class (or any derived
class you have created).  Normally you would make this configurable using a
command line option in the same way that SIP's <tt class="docutils literal"><span class="pre">configure.py</span></tt> handles it.</p>
<p>The next stage is to create a custom stub and a Makefile.  The SIP distribution
contains a directory called <tt class="docutils literal"><span class="pre">custom</span></tt> which contains example stubs and a
Python script that will create a correct Makefile.  Note that, if your copy of
SIP was part of a standard Linux distribution, the <tt class="docutils literal"><span class="pre">custom</span></tt> directory may
not be installed on your system.</p>
<p>The <tt class="docutils literal"><span class="pre">custom</span></tt> directory contains the following files.  They are provided as
examples - each needs to be modified according to your particular
requirements.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">mkcustom.py</span></tt> is a Python script that will create a Makefile which is
then used to build the custom interpreter.  Comments in the file describe
how it should be modified.</li>
<li><tt class="docutils literal"><span class="pre">custom.c</span></tt> is a stub for a custom interpreter on Linux/UNIX.  It
should also be used for a custom console interpreter on Windows (i.e.
like <tt class="docutils literal"><span class="pre">python.exe</span></tt>).  Comments in the file describe how it should be
modified.</li>
<li><tt class="docutils literal"><span class="pre">customw.c</span></tt> is a stub for a custom GUI interpreter on Windows (i.e.
like <tt class="docutils literal"><span class="pre">pythonw.exe</span></tt>).  Comments in the file describe how it should be
modified.</li>
</ul>
</blockquote>
<p>Note that this technique does not restrict how the interpreter can be used.
For example, it still allows users to write their own applications that can
import your builtin modules.  If you want to prevent users from doing that,
perhaps to protect a proprietary API, then take a look at the
<a class="reference" href="http://www.riverbankcomputing.com/software/vendorid/">VendorID</a> package.</p>
</div>
</div>
</body>
</html>
