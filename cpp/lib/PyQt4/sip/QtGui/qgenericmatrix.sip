// qgenericmatrix.sip generated by MetaSIP on Fri Sep 28 02:47:47 2012
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2012 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// If you are unsure which license is appropriate for your use, please
// contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (Qt_4_6_0 -)
// The implementation of QMatrix4x3.
class QMatrix4x3
{
%TypeHeaderCode
#include <qgenericmatrix.h>
%End

%PickleCode
        qreal data[12];

        // We want the data in row-major order.
        sipCpp->copyDataTo(data);

        sipRes = Py_BuildValue((char *)"dddddddddddd",
                data[0], data[1], data[2],
                data[3], data[4], data[5],
                data[6], data[7], data[8],
                data[9], data[10], data[11]);
%End

public:
    QMatrix4x3();
    QMatrix4x3(const QMatrix4x3 &other);
    explicit QMatrix4x3(SIP_PYOBJECT values /DocType="sequence-of-float"/);
%MethodCode
        qreal values[12];

        if ((sipError = qtgui_matrixDataFromSequence(a0, 12, values)) == sipErrorNone)
            sipCpp = new QMatrix4x3(values);
%End

    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        bool bad = false;
        int i;
        PyObject *m[12];
        qreal data[12];

        // The raw data is in column-major order but we want row-major order.
        sipCpp->copyDataTo(data);

        for (i = 0; i < 12; ++i)
        {
            m[i] = PyFloat_FromDouble(data[i]);

            if (!m[i])
                bad = true;
        }

        if (!bad)
        {
#if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtGui.QMatrix4x3("
                    "%R, %R, %R, "
                    "%R, %R, %R, "
                    "%R, %R, %R, "
                    "%R, %R, %R)",
                    m[0], m[1], m[2],
                    m[3], m[4], m[5],
                    m[6], m[7], m[8],
                    m[9], m[10], m[11]);
#else
            sipRes = PyString_FromString("PyQt4.QtGui.QMatrix4x3(");

            for (i = 0; i < 12; ++i)
            {
                if (i != 0)
                    PyString_ConcatAndDel(&sipRes, PyString_FromString(", "));

                PyString_ConcatAndDel(&sipRes, PyObject_Repr(m[i]));
            }

            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
#endif
        }

        for (i = 0; i < 12; ++i)
            Py_XDECREF(m[i]);
%End

    SIP_PYLIST data() /DocType="list-of-float"/;
%MethodCode
        sipError = qtgui_matrixDataAsList(12, sipCpp->constData(), &sipRes);
%End

    SIP_PYLIST copyDataTo() const /DocType="list-of-float"/;
%MethodCode
        qreal values[12];

        sipCpp->copyDataTo(values);
        sipError = qtgui_matrixDataAsList(12, values, &sipRes);
%End

    SIP_PYOBJECT __getitem__(SIP_PYOBJECT) const;
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 4, 3, &row, &column)) == sipErrorNone)
        {
            sipRes = PyFloat_FromDouble(sipCpp->operator()(row, column));

            if (!sipRes)
                sipError = sipErrorFail;
        }
%End

    void __setitem__(SIP_PYOBJECT, qreal);
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 4, 3, &row, &column)) == sipErrorNone)
            sipCpp->operator()(row, column) = a1;
%End

    bool isIdentity() const;
    void setToIdentity();
    void fill(qreal value);

    QMatrix3x4 transposed() const;

    QMatrix4x3 &operator+=(const QMatrix4x3 &);
    QMatrix4x3 &operator-=(const QMatrix4x3 &);

    QMatrix4x3 &operator*=(qreal);
    QMatrix4x3 &operator/=(qreal);

    bool operator==(const QMatrix4x3 &) const;
    bool operator!=(const QMatrix4x3 &) const;
};
%End
%If (Qt_4_6_0 -)
// The implementation of QMatrix4x2.
class QMatrix4x2
{
%TypeHeaderCode
#include <qgenericmatrix.h>
%End

%PickleCode
        qreal data[8];

        // We want the data in row-major order.
        sipCpp->copyDataTo(data);

        sipRes = Py_BuildValue((char *)"dddddddd",
                data[0], data[1],
                data[2], data[3],
                data[4], data[5],
                data[6], data[7]);
%End

public:
    QMatrix4x2();
    QMatrix4x2(const QMatrix4x2 &other);
    explicit QMatrix4x2(SIP_PYOBJECT values /DocType="sequence-of-float"/);
%MethodCode
        qreal values[8];

        if ((sipError = qtgui_matrixDataFromSequence(a0, 8, values)) == sipErrorNone)
            sipCpp = new QMatrix4x2(values);
%End

    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        bool bad = false;
        int i;
        PyObject *m[8];
        qreal data[8];

        // The raw data is in column-major order but we want row-major order.
        sipCpp->copyDataTo(data);

        for (i = 0; i < 8; ++i)
        {
            m[i] = PyFloat_FromDouble(data[i]);

            if (!m[i])
                bad = true;
        }

        if (!bad)
        {
#if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtGui.QMatrix4x2("
                    "%R, %R, "
                    "%R, %R, "
                    "%R, %R, "
                    "%R, %R)",
                    m[0], m[1],
                    m[2], m[3],
                    m[4], m[5],
                    m[6], m[7]);
#else
            sipRes = PyString_FromString("PyQt4.QtGui.QMatrix4x2(");

            for (i = 0; i < 8; ++i)
            {
                if (i != 0)
                    PyString_ConcatAndDel(&sipRes, PyString_FromString(", "));

                PyString_ConcatAndDel(&sipRes, PyObject_Repr(m[i]));
            }

            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
#endif
        }

        for (i = 0; i < 8; ++i)
            Py_XDECREF(m[i]);
%End

    SIP_PYLIST data() /DocType="list-of-float"/;
%MethodCode
        sipError = qtgui_matrixDataAsList(8, sipCpp->constData(), &sipRes);
%End

    SIP_PYLIST copyDataTo() const /DocType="list-of-float"/;
%MethodCode
        qreal values[8];

        sipCpp->copyDataTo(values);
        sipError = qtgui_matrixDataAsList(8, values, &sipRes);
%End

    SIP_PYOBJECT __getitem__(SIP_PYOBJECT) const;
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 4, 2, &row, &column)) == sipErrorNone)
        {
            sipRes = PyFloat_FromDouble(sipCpp->operator()(row, column));

            if (!sipRes)
                sipError = sipErrorFail;
        }
%End

    void __setitem__(SIP_PYOBJECT, qreal);
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 4, 2, &row, &column)) == sipErrorNone)
            sipCpp->operator()(row, column) = a1;
%End

    bool isIdentity() const;
    void setToIdentity();
    void fill(qreal value);

    QMatrix2x4 transposed() const;

    QMatrix4x2 &operator+=(const QMatrix4x2 &);
    QMatrix4x2 &operator-=(const QMatrix4x2 &);

    QMatrix4x2 &operator*=(qreal);
    QMatrix4x2 &operator/=(qreal);

    bool operator==(const QMatrix4x2 &) const;
    bool operator!=(const QMatrix4x2 &) const;
};
%End
%If (Qt_4_6_0 -)
// The implementation of QMatrix3x4.
class QMatrix3x4
{
%TypeHeaderCode
#include <qgenericmatrix.h>
%End

%PickleCode
        qreal data[12];

        // We want the data in row-major order.
        sipCpp->copyDataTo(data);

        sipRes = Py_BuildValue((char *)"dddddddddddd",
                data[0], data[1], data[2],
                data[3], data[4], data[5],
                data[6], data[7], data[8],
                data[9], data[10], data[11]);
%End

public:
    QMatrix3x4();
    QMatrix3x4(const QMatrix3x4 &other);
    explicit QMatrix3x4(SIP_PYOBJECT values /DocType="sequence-of-float"/);
%MethodCode
        qreal values[12];

        if ((sipError = qtgui_matrixDataFromSequence(a0, 12, values)) == sipErrorNone)
            sipCpp = new QMatrix3x4(values);
%End

    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        bool bad = false;
        int i;
        PyObject *m[12];
        qreal data[12];

        // The raw data is in column-major order but we want row-major order.
        sipCpp->copyDataTo(data);

        for (i = 0; i < 12; ++i)
        {
            m[i] = PyFloat_FromDouble(data[i]);

            if (!m[i])
                bad = true;
        }

        if (!bad)
        {
#if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtGui.QMatrix3x4("
                    "%R, %R, %R, "
                    "%R, %R, %R, "
                    "%R, %R, %R, "
                    "%R, %R, %R)",
                    m[0], m[1], m[2],
                    m[3], m[4], m[5],
                    m[6], m[7], m[8],
                    m[9], m[10], m[11]);
#else
            sipRes = PyString_FromString("PyQt4.QtGui.QMatrix3x4(");

            for (i = 0; i < 12; ++i)
            {
                if (i != 0)
                    PyString_ConcatAndDel(&sipRes, PyString_FromString(", "));

                PyString_ConcatAndDel(&sipRes, PyObject_Repr(m[i]));
            }

            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
#endif
        }

        for (i = 0; i < 12; ++i)
            Py_XDECREF(m[i]);
%End

    SIP_PYLIST data() /DocType="list-of-float"/;
%MethodCode
        sipError = qtgui_matrixDataAsList(12, sipCpp->constData(), &sipRes);
%End

    SIP_PYLIST copyDataTo() const /DocType="list-of-float"/;
%MethodCode
        qreal values[12];

        sipCpp->copyDataTo(values);
        sipError = qtgui_matrixDataAsList(12, values, &sipRes);
%End

    SIP_PYOBJECT __getitem__(SIP_PYOBJECT) const;
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 3, 4, &row, &column)) == sipErrorNone)
        {
            sipRes = PyFloat_FromDouble(sipCpp->operator()(row, column));

            if (!sipRes)
                sipError = sipErrorFail;
        }
%End

    void __setitem__(SIP_PYOBJECT, qreal);
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 3, 4, &row, &column)) == sipErrorNone)
            sipCpp->operator()(row, column) = a1;
%End

    bool isIdentity() const;
    void setToIdentity();
    void fill(qreal value);

    QMatrix4x3 transposed() const;

    QMatrix3x4 &operator+=(const QMatrix3x4 &);
    QMatrix3x4 &operator-=(const QMatrix3x4 &);

    QMatrix3x4 &operator*=(qreal);
    QMatrix3x4 &operator/=(qreal);

    bool operator==(const QMatrix3x4 &) const;
    bool operator!=(const QMatrix3x4 &) const;
};
%End
%If (Qt_4_6_0 -)
// The implementation of QMatrix3x3.
class QMatrix3x3
{
%TypeHeaderCode
#include <qgenericmatrix.h>
%End

%PickleCode
        qreal data[9];

        // We want the data in row-major order.
        sipCpp->copyDataTo(data);

        sipRes = Py_BuildValue((char *)"ddddddddd",
                data[0], data[1], data[2],
                data[3], data[4], data[5],
                data[6], data[7], data[8]);
%End

public:
    QMatrix3x3();
    QMatrix3x3(const QMatrix3x3 &other);
    explicit QMatrix3x3(SIP_PYOBJECT values /DocType="sequence-of-float"/);
%MethodCode
        qreal values[9];

        if ((sipError = qtgui_matrixDataFromSequence(a0, 9, values)) == sipErrorNone)
            sipCpp = new QMatrix3x3(values);
%End

    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        bool bad = false;
        int i;
        PyObject *m[9];
        qreal data[9];

        // The raw data is in column-major order but we want row-major order.
        sipCpp->copyDataTo(data);

        for (i = 0; i < 9; ++i)
        {
            m[i] = PyFloat_FromDouble(data[i]);

            if (!m[i])
                bad = true;
        }

        if (!bad)
        {
#if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtGui.QMatrix3x3("
                    "%R, %R, %R, "
                    "%R, %R, %R, "
                    "%R, %R, %R)",
                    m[0], m[1], m[2],
                    m[3], m[4], m[5],
                    m[6], m[7], m[8]);
#else
            sipRes = PyString_FromString("PyQt4.QtGui.QMatrix3x3(");

            for (i = 0; i < 9; ++i)
            {
                if (i != 0)
                    PyString_ConcatAndDel(&sipRes, PyString_FromString(", "));

                PyString_ConcatAndDel(&sipRes, PyObject_Repr(m[i]));
            }

            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
#endif
        }

        for (i = 0; i < 9; ++i)
            Py_XDECREF(m[i]);
%End

    SIP_PYLIST data() /DocType="list-of-float"/;
%MethodCode
        sipError = qtgui_matrixDataAsList(9, sipCpp->constData(), &sipRes);
%End

    SIP_PYLIST copyDataTo() const /DocType="list-of-float"/;
%MethodCode
        qreal values[9];

        sipCpp->copyDataTo(values);
        sipError = qtgui_matrixDataAsList(9, values, &sipRes);
%End

    SIP_PYOBJECT __getitem__(SIP_PYOBJECT) const;
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 3, 3, &row, &column)) == sipErrorNone)
        {
            sipRes = PyFloat_FromDouble(sipCpp->operator()(row, column));

            if (!sipRes)
                sipError = sipErrorFail;
        }
%End

    void __setitem__(SIP_PYOBJECT, qreal);
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 3, 3, &row, &column)) == sipErrorNone)
            sipCpp->operator()(row, column) = a1;
%End

    bool isIdentity() const;
    void setToIdentity();
    void fill(qreal value);

    QMatrix3x3 transposed() const;

    QMatrix3x3 &operator+=(const QMatrix3x3 &);
    QMatrix3x3 &operator-=(const QMatrix3x3 &);

    QMatrix3x3 &operator*=(qreal);
    QMatrix3x3 &operator/=(qreal);

    bool operator==(const QMatrix3x3 &) const;
    bool operator!=(const QMatrix3x3 &) const;
};
%End
%If (Qt_4_6_0 -)
// The implementation of QMatrix3x2.
class QMatrix3x2
{
%TypeHeaderCode
#include <qgenericmatrix.h>
%End

%PickleCode
        qreal data[6];

        // We want the data in row-major order.
        sipCpp->copyDataTo(data);

        sipRes = Py_BuildValue((char *)"dddddd",
                data[0], data[1],
                data[2], data[3],
                data[4], data[5]);
%End

public:
    QMatrix3x2();
    QMatrix3x2(const QMatrix3x2 &other);
    explicit QMatrix3x2(SIP_PYOBJECT values /DocType="sequence-of-float"/);
%MethodCode
        qreal values[6];

        if ((sipError = qtgui_matrixDataFromSequence(a0, 6, values)) == sipErrorNone)
            sipCpp = new QMatrix3x2(values);
%End

    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        bool bad = false;
        int i;
        PyObject *m[6];
        qreal data[6];

        // The raw data is in column-major order but we want row-major order.
        sipCpp->copyDataTo(data);

        for (i = 0; i < 6; ++i)
        {
            m[i] = PyFloat_FromDouble(data[i]);

            if (!m[i])
                bad = true;
        }

        if (!bad)
        {
#if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtGui.QMatrix3x2("
                    "%R, %R, "
                    "%R, %R, "
                    "%R, %R)",
                    m[0], m[1],
                    m[2], m[3],
                    m[4], m[5]);
#else
            sipRes = PyString_FromString("PyQt4.QtGui.QMatrix3x2(");

            for (i = 0; i < 6; ++i)
            {
                if (i != 0)
                    PyString_ConcatAndDel(&sipRes, PyString_FromString(", "));

                PyString_ConcatAndDel(&sipRes, PyObject_Repr(m[i]));
            }

            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
#endif
        }

        for (i = 0; i < 6; ++i)
            Py_XDECREF(m[i]);
%End

    SIP_PYLIST data() /DocType="list-of-float"/;
%MethodCode
        sipError = qtgui_matrixDataAsList(6, sipCpp->constData(), &sipRes);
%End

    SIP_PYLIST copyDataTo() const /DocType="list-of-float"/;
%MethodCode
        qreal values[6];

        sipCpp->copyDataTo(values);
        sipError = qtgui_matrixDataAsList(6, values, &sipRes);
%End

    SIP_PYOBJECT __getitem__(SIP_PYOBJECT) const;
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 3, 2, &row, &column)) == sipErrorNone)
        {
            sipRes = PyFloat_FromDouble(sipCpp->operator()(row, column));

            if (!sipRes)
                sipError = sipErrorFail;
        }
%End

    void __setitem__(SIP_PYOBJECT, qreal);
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 3, 2, &row, &column)) == sipErrorNone)
            sipCpp->operator()(row, column) = a1;
%End

    bool isIdentity() const;
    void setToIdentity();
    void fill(qreal value);

    QMatrix2x3 transposed() const;

    QMatrix3x2 &operator+=(const QMatrix3x2 &);
    QMatrix3x2 &operator-=(const QMatrix3x2 &);

    QMatrix3x2 &operator*=(qreal);
    QMatrix3x2 &operator/=(qreal);

    bool operator==(const QMatrix3x2 &) const;
    bool operator!=(const QMatrix3x2 &) const;
};
%End
%If (Qt_4_6_0 -)
// The implementation of QMatrix2x4.
class QMatrix2x4
{
%TypeHeaderCode
#include <qgenericmatrix.h>
%End

%PickleCode
        qreal data[8];

        // We want the data in row-major order.
        sipCpp->copyDataTo(data);

        sipRes = Py_BuildValue((char *)"dddddddd",
                data[0], data[1], data[2], data[3],
                data[4], data[5], data[6], data[7]);
%End

public:
    QMatrix2x4();
    QMatrix2x4(const QMatrix2x4 &other);
    explicit QMatrix2x4(SIP_PYOBJECT values /DocType="sequence-of-float"/);
%MethodCode
        qreal values[8];

        if ((sipError = qtgui_matrixDataFromSequence(a0, 8, values)) == sipErrorNone)
            sipCpp = new QMatrix2x4(values);
%End

    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        bool bad = false;
        int i;
        PyObject *m[8];
        qreal data[8];

        // The raw data is in column-major order but we want row-major order.
        sipCpp->copyDataTo(data);

        for (i = 0; i < 8; ++i)
        {
            m[i] = PyFloat_FromDouble(data[i]);

            if (!m[i])
                bad = true;
        }

        if (!bad)
        {
#if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtGui.QMatrix2x4("
                    "%R, %R, %R, %R, "
                    "%R, %R, %R, %R)",
                    m[0], m[1], m[2], m[3],
                    m[4], m[5], m[6], m[7]);
#else
            sipRes = PyString_FromString("PyQt4.QtGui.QMatrix2x4(");

            for (i = 0; i < 8; ++i)
            {
                if (i != 0)
                    PyString_ConcatAndDel(&sipRes, PyString_FromString(", "));

                PyString_ConcatAndDel(&sipRes, PyObject_Repr(m[i]));
            }

            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
#endif
        }

        for (i = 0; i < 8; ++i)
            Py_XDECREF(m[i]);
%End

    SIP_PYLIST data() /DocType="list-of-float"/;
%MethodCode
        sipError = qtgui_matrixDataAsList(8, sipCpp->constData(), &sipRes);
%End

    SIP_PYLIST copyDataTo() const /DocType="list-of-float"/;
%MethodCode
        qreal values[8];

        sipCpp->copyDataTo(values);
        sipError = qtgui_matrixDataAsList(8, values, &sipRes);
%End

    SIP_PYOBJECT __getitem__(SIP_PYOBJECT) const;
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 2, 4, &row, &column)) == sipErrorNone)
        {
            sipRes = PyFloat_FromDouble(sipCpp->operator()(row, column));

            if (!sipRes)
                sipError = sipErrorFail;
        }
%End

    void __setitem__(SIP_PYOBJECT, qreal);
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 2, 4, &row, &column)) == sipErrorNone)
            sipCpp->operator()(row, column) = a1;
%End

    bool isIdentity() const;
    void setToIdentity();
    void fill(qreal value);

    QMatrix4x2 transposed() const;

    QMatrix2x4 &operator+=(const QMatrix2x4 &);
    QMatrix2x4 &operator-=(const QMatrix2x4 &);

    QMatrix2x4 &operator*=(qreal);
    QMatrix2x4 &operator/=(qreal);

    bool operator==(const QMatrix2x4 &) const;
    bool operator!=(const QMatrix2x4 &) const;
};
%End
%If (Qt_4_6_0 -)
// The implementation of QMatrix2x3.
class QMatrix2x3
{
%TypeHeaderCode
#include <qgenericmatrix.h>
%End

%PickleCode
        qreal data[6];

        // We want the data in row-major order.
        sipCpp->copyDataTo(data);

        sipRes = Py_BuildValue((char *)"dddddd",
                data[0], data[1], data[2],
                data[3], data[4], data[5]);
%End

public:
    QMatrix2x3();
    QMatrix2x3(const QMatrix2x3 &other);
    explicit QMatrix2x3(SIP_PYOBJECT values /DocType="sequence-of-float"/);
%MethodCode
        qreal values[6];

        if ((sipError = qtgui_matrixDataFromSequence(a0, 6, values)) == sipErrorNone)
            sipCpp = new QMatrix2x3(values);
%End

    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        bool bad = false;
        int i;
        PyObject *m[6];
        qreal data[6];

        // The raw data is in column-major order but we want row-major order.
        sipCpp->copyDataTo(data);

        for (i = 0; i < 6; ++i)
        {
            m[i] = PyFloat_FromDouble(data[i]);

            if (!m[i])
                bad = true;
        }

        if (!bad)
        {
#if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtGui.QMatrix2x3("
                    "%R, %R, %R, "
                    "%R, %R, %R)",
                    m[0], m[1], m[2],
                    m[3], m[4], m[5]);
#else
            sipRes = PyString_FromString("PyQt4.QtGui.QMatrix2x3(");

            for (i = 0; i < 6; ++i)
            {
                if (i != 0)
                    PyString_ConcatAndDel(&sipRes, PyString_FromString(", "));

                PyString_ConcatAndDel(&sipRes, PyObject_Repr(m[i]));
            }

            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
#endif
        }

        for (i = 0; i < 6; ++i)
            Py_XDECREF(m[i]);
%End

    SIP_PYLIST data() /DocType="list-of-float"/;
%MethodCode
        sipError = qtgui_matrixDataAsList(6, sipCpp->constData(), &sipRes);
%End

    SIP_PYLIST copyDataTo() const /DocType="list-of-float"/;
%MethodCode
        qreal values[6];

        sipCpp->copyDataTo(values);
        sipError = qtgui_matrixDataAsList(6, values, &sipRes);
%End

    SIP_PYOBJECT __getitem__(SIP_PYOBJECT) const;
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 2, 3, &row, &column)) == sipErrorNone)
        {
            sipRes = PyFloat_FromDouble(sipCpp->operator()(row, column));

            if (!sipRes)
                sipError = sipErrorFail;
        }
%End

    void __setitem__(SIP_PYOBJECT, qreal);
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 2, 3, &row, &column)) == sipErrorNone)
            sipCpp->operator()(row, column) = a1;
%End

    bool isIdentity() const;
    void setToIdentity();
    void fill(qreal value);

    QMatrix3x2 transposed() const;

    QMatrix2x3 &operator+=(const QMatrix2x3 &);
    QMatrix2x3 &operator-=(const QMatrix2x3 &);

    QMatrix2x3 &operator*=(qreal);
    QMatrix2x3 &operator/=(qreal);

    bool operator==(const QMatrix2x3 &) const;
    bool operator!=(const QMatrix2x3 &) const;
};
%End
%If (Qt_4_6_0 -)
// The implementation of QMatrix2x2.
class QMatrix2x2
{
%TypeHeaderCode
#include <qgenericmatrix.h>
%End

%PickleCode
        qreal data[4];

        // We want the data in row-major order.
        sipCpp->copyDataTo(data);

        sipRes = Py_BuildValue((char *)"dddd",
                data[0], data[1],
                data[2], data[3]);
%End

public:
    QMatrix2x2();
    QMatrix2x2(const QMatrix2x2 &other);
    explicit QMatrix2x2(SIP_PYOBJECT values /DocType="sequence-of-float"/);
%MethodCode
        qreal values[4];

        if ((sipError = qtgui_matrixDataFromSequence(a0, 4, values)) == sipErrorNone)
            sipCpp = new QMatrix2x2(values);
%End

    SIP_PYOBJECT __repr__() const /DocType="str"/;
%MethodCode
        bool bad = false;
        int i;
        PyObject *m[4];
        qreal data[4];

        // The raw data is in column-major order but we want row-major order.
        sipCpp->copyDataTo(data);

        for (i = 0; i < 4; ++i)
        {
            m[i] = PyFloat_FromDouble(data[i]);

            if (!m[i])
                bad = true;
        }

        if (!bad)
        {
#if PY_MAJOR_VERSION >= 3
            sipRes = PyUnicode_FromFormat("PyQt4.QtGui.QMatrix2x2("
                    "%R, %R, "
                    "%R, %R)",
                    m[0], m[1],
                    m[2], m[3]);
#else
            sipRes = PyString_FromString("PyQt4.QtGui.QMatrix2x2(");

            for (i = 0; i < 4; ++i)
            {
                if (i != 0)
                    PyString_ConcatAndDel(&sipRes, PyString_FromString(", "));

                PyString_ConcatAndDel(&sipRes, PyObject_Repr(m[i]));
            }

            PyString_ConcatAndDel(&sipRes, PyString_FromString(")"));
#endif
        }

        for (i = 0; i < 4; ++i)
            Py_XDECREF(m[i]);
%End

    SIP_PYLIST data() /DocType="list-of-float"/;
%MethodCode
        sipError = qtgui_matrixDataAsList(4, sipCpp->constData(), &sipRes);
%End

    SIP_PYLIST copyDataTo() const /DocType="list-of-float"/;
%MethodCode
        qreal values[4];

        sipCpp->copyDataTo(values);
        sipError = qtgui_matrixDataAsList(4, values, &sipRes);
%End

    SIP_PYOBJECT __getitem__(SIP_PYOBJECT) const;
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 2, 2, &row, &column)) == sipErrorNone)
        {
            sipRes = PyFloat_FromDouble(sipCpp->operator()(row, column));

            if (!sipRes)
                sipError = sipErrorFail;
        }
%End

    void __setitem__(SIP_PYOBJECT, qreal);
%MethodCode
        int row, column;

        if ((sipError = qtgui_matrixParseIndex(a0, 2, 2, &row, &column)) == sipErrorNone)
            sipCpp->operator()(row, column) = a1;
%End

    bool isIdentity() const;
    void setToIdentity();
    void fill(qreal value);

    QMatrix2x2 transposed() const;

    QMatrix2x2 &operator+=(const QMatrix2x2 &);
    QMatrix2x2 &operator-=(const QMatrix2x2 &);

    QMatrix2x2 &operator*=(qreal);
    QMatrix2x2 &operator/=(qreal);

    bool operator==(const QMatrix2x2 &) const;
    bool operator!=(const QMatrix2x2 &) const;
};
%End
